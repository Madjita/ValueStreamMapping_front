{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : new P(function (resolve) {\n        resolve(result.value);\n      }).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nvar __generator = this && this.__generator || function (thisArg, body) {\n  var _ = {\n    label: 0,\n    sent: function () {\n      if (t[0] & 1) throw t[1];\n      return t[1];\n    },\n    trys: [],\n    ops: []\n  },\n      f,\n      y,\n      t,\n      g;\n  return g = {\n    next: verb(0),\n    \"throw\": verb(1),\n    \"return\": verb(2)\n  }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function () {\n    return this;\n  }), g;\n\n  function verb(n) {\n    return function (v) {\n      return step([n, v]);\n    };\n  }\n\n  function step(op) {\n    if (f) throw new TypeError(\"Generator is already executing.\");\n\n    while (_) try {\n      if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n      if (y = 0, t) op = [op[0] & 2, t.value];\n\n      switch (op[0]) {\n        case 0:\n        case 1:\n          t = op;\n          break;\n\n        case 4:\n          _.label++;\n          return {\n            value: op[1],\n            done: false\n          };\n\n        case 5:\n          _.label++;\n          y = op[1];\n          op = [0];\n          continue;\n\n        case 7:\n          op = _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n\n        default:\n          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {\n            _ = 0;\n            continue;\n          }\n\n          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {\n            _.label = op[1];\n            break;\n          }\n\n          if (op[0] === 6 && _.label < t[1]) {\n            _.label = t[1];\n            t = op;\n            break;\n          }\n\n          if (t && _.label < t[2]) {\n            _.label = t[2];\n\n            _.ops.push(op);\n\n            break;\n          }\n\n          if (t[2]) _.ops.pop();\n\n          _.trys.pop();\n\n          continue;\n      }\n\n      op = body.call(thisArg, _);\n    } catch (e) {\n      op = [6, e];\n      y = 0;\n    } finally {\n      f = t = 0;\n    }\n\n    if (op[0] & 5) throw op[1];\n    return {\n      value: op[0] ? op[1] : void 0,\n      done: true\n    };\n  }\n};\n\nimport { Connector, getBezierPoints, isEmptyVector } from '../objects/connector';\nimport { Node, BpmnSubEvent, BpmnAnnotation } from '../objects/node';\nimport { PathElement } from '../core/elements/path-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { OrthogonalSegment } from '../objects/connector';\nimport { Rect } from '../primitives/rect';\nimport { Diagram } from '../../diagram/diagram';\nimport { identityMatrix, rotateMatrix, transformPointByMatrix, scaleMatrix } from './../primitives/matrix';\nimport { cloneObject as clone, cloneObject, getBounds, getFunction, getIndex } from './../utility/base-util';\nimport { completeRegion, sort, findObjectIndex, intersect3, getAnnotationPosition } from './../utility/diagram-util';\nimport { updatePathElement, cloneBlazorObject, getUserHandlePosition, cloneSelectedObjects } from './../utility/diagram-util';\nimport { updateDefaultValues } from './../utility/diagram-util';\nimport { randomId, cornersPointsBeforeRotation } from './../utility/base-util';\nimport { Selector } from '../objects/node';\nimport { hasSelection, isSelected, hasSingleConnection, contains } from './actions';\nimport { DiagramEvent } from '../enum/enum';\nimport { BlazorAction } from '../enum/enum';\nimport { canSelect, canMove, canRotate, canDragSourceEnd, canDragTargetEnd, canSingleSelect, canDrag } from './../utility/constraints-util';\nimport { canMultiSelect, canContinuousDraw } from './../utility/constraints-util';\nimport { canPanX, canPanY, canPageEditable } from './../utility/constraints-util';\nimport { SnapConstraints, DiagramTools, DiagramAction, RealAction } from '../enum/enum';\nimport { getDiagramElement, getAdornerLayerSvg, getHTMLLayer, getAdornerLayer } from '../utility/dom-util';\nimport { Point } from '../primitives/point';\nimport { Size } from '../primitives/size';\nimport { getObjectType, getPoint, intersect2, getOffsetOfConnector, canShowCorner } from './../utility/diagram-util';\nimport { Layer } from '../diagram/layer';\nimport { SelectorConstraints, DiagramConstraints } from '../enum/enum';\nimport { remove, isBlazor, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { getOppositeDirection, getPortDirection, findAngle } from './../utility/connector';\nimport { swapBounds, findPoint, orthoConnection2Segment, getIntersection } from './../utility/connector';\nimport { ShapeAnnotation, PathAnnotation } from '../objects/annotation';\nimport { renderContainerHelper } from './container-interaction';\nimport { checkChildNodeInContainer, checkParentAsContainer, addChildToContainer } from './container-interaction';\nimport { renderStackHighlighter } from './container-interaction';\nimport { getConnectors, updateConnectorsProperties, canLaneInterchange, findLane } from './../utility/swim-lane-util';\nimport { swimLaneSelection, pasteSwimLane, gridSelection } from '../utility/swim-lane-util';\nimport { DeepDiffMapper } from '../utility/diff-map';\n/**\n * Defines the behavior of commands\n */\n\nvar CommandHandler =\n/** @class */\nfunction () {\n  function CommandHandler(diagram) {\n    /**   @private  */\n    this.clipboardData = {}; // private newNodeObject: Object[] = [];\n    // private newConnectorObject: Object[] = [];\n\n    /**   @private  */\n\n    this.diagramObject = {};\n    /**   @private  */\n\n    this.newSelectedObjects = {};\n    /**   @private  */\n\n    this.oldSelectedObjects = {};\n    /**   @private  */\n\n    this.connectorsTable = [];\n    /**   @private  */\n\n    this.processTable = {};\n    /**   @private  */\n\n    this.deepDiffer = new DeepDiffMapper();\n    /** @private */\n\n    this.isContainer = false;\n    this.childTable = {};\n    this.parentTable = {};\n    this.blazor = 'Blazor';\n    this.blazorInterop = 'sfBlazor';\n    this.cloneGroupChildCollection = [];\n    this.diagram = diagram;\n  }\n\n  Object.defineProperty(CommandHandler.prototype, \"snappingModule\", {\n    /**   @private  */\n    get: function () {\n      return this.diagram.snappingModule;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(CommandHandler.prototype, \"layoutAnimateModule\", {\n    /**   @private  */\n    get: function () {\n      return this.diagram.layoutAnimateModule;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  /**\n   * startTransaction method\\\n   *\n   * @returns {  void }    startTransaction method .\\\n   * @param {boolean} protectChange - provide the options value.\n   * @private\n   */\n\n  CommandHandler.prototype.startTransaction = function (protectChange) {\n    this.state = {\n      element: this.diagram.selectedItems,\n      backup: null\n    };\n\n    if (protectChange) {\n      this.diagram.protectPropertyChange(true);\n    }\n\n    getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'none';\n  };\n  /**\n   * endTransaction method\\\n   *\n   * @returns {  void }    endTransaction method .\\\n   * @param {boolean} protectChange - provide the options value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.endTransaction = function (protectChange) {\n    this.state = null;\n\n    if (protectChange) {\n      this.diagram.protectPropertyChange(false);\n    }\n\n    getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'all';\n  };\n  /**\n   * setFocus method\\\n   *\n   * @returns {  void }    setFocus method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.setFocus = function () {\n    document.getElementById(this.diagram.element.id).focus();\n  };\n  /**\n   * showTooltip method\\\n   *\n   * @returns {  void }    showTooltip method .\\\n   * @param {IElement} node - provide the options value.\n   * @param {PointModel} position - provide the position value.\n   * @param {string | HTMLElement} content - provide the content value.\n   * @param {string} toolName - provide the toolName value.\n   * @param {boolean} isTooltipVisible - provide the isTooltipVisible value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.showTooltip = function (node, position, content, toolName, isTooltipVisible) {\n    var _this = this;\n\n    var targetId;\n    var targetEle;\n\n    if (node instanceof Selector) {\n      if (node.nodes.length == 1 && node.connectors.length == 0) {\n        targetId = node.nodes[0].id;\n      } else if (node.nodes.length == 0 && node.connectors.length == 1) {\n        targetId = node.connectors[0].id;\n      } else {\n        targetEle = document.getElementById(this.diagram.element.id + '_SelectorElement');\n      }\n    } else if (node instanceof Node) {\n      targetId = node.id;\n    } else {\n      targetId = node.id;\n    }\n\n    if (isNullOrUndefined(targetEle) && !isNullOrUndefined(targetId)) {\n      targetEle = document.getElementById(targetId + '_groupElement');\n    }\n\n    if (isTooltipVisible) {\n      this.diagram.tooltipObject.position = 'BottomCenter';\n      this.diagram.tooltipObject.animation = {\n        open: {\n          delay: 0,\n          duration: 0\n        }\n      };\n      this.diagram.tooltipObject.openDelay = 0;\n      this.diagram.tooltipObject.closeDelay = 0;\n    }\n\n    if (this.diagram.selectedItems.setTooltipTemplate) {\n      var template = void 0;\n      var setTooltipTemplate = getFunction(this.diagram.selectedItems.setTooltipTemplate);\n\n      if (setTooltipTemplate) {\n        template = setTooltipTemplate(node, this.diagram);\n      }\n\n      if (template instanceof HTMLElement) {\n        content = template.cloneNode(true);\n      } else {\n        content = template ? template : content;\n      }\n    }\n\n    if (isBlazor() && isTooltipVisible) {\n      this.diagram.tooltipObject.close();\n    }\n\n    if (node.tooltip) {\n      this.diagram.tooltipObject.openOn = node.tooltip.openOn;\n    }\n\n    this.diagram.tooltipObject.content = content;\n    this.diagram.tooltipObject.offsetX = 0;\n    this.diagram.tooltipObject.offsetY = 0;\n\n    if (isBlazor()) {\n      this.diagram.tooltipObject.updateTooltip(this.diagram.element);\n    } else {\n      this.diagram.tooltipObject.refresh(targetEle);\n    }\n\n    if (isTooltipVisible) {\n      setTimeout(function () {\n        _this.diagram.tooltipObject.open(targetEle);\n      }, 1);\n    }\n  };\n  /**\n   * closeTooltip method\\\n   *\n   * @returns {  void }    closeTooltip method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.closeTooltip = function () {\n    this.diagram.tooltipObject.close();\n  };\n  /**\n   * canEnableDefaultTooltip method\\\n   *\n   * @returns {  boolean }    canEnableDefaultTooltip method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.canEnableDefaultTooltip = function () {\n    if (this.diagram.selectedItems.constraints & SelectorConstraints.ToolTip) {\n      return true;\n    } else {\n      return false;\n    }\n  };\n  /**\n   * updateSelector method\\\n   *\n   * @returns {  void }    updateSelector method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateSelector = function () {\n    this.diagram.updateSelector();\n  };\n  /**\n   * updateConnectorValue method\\\n   *\n   * @returns {  void }    updateConnectorValue method .\\\n   * @param {IBlazorConnectionChangeEventArgs} args - provide the options value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateConnectorValue = function (args) {\n    if (args.cancel) {\n      this.enableCloneObject(true);\n      this.ismouseEvents(true);\n      this.insertBlazorObject(args.connector);\n      var newChanges = {};\n      var oldChanges = {};\n      var connector = this.diagram.nameTable[args.connector.id];\n      var nodeEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n      var portEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n      var connectionEnd = args.connectorEnd === 'ConnectorTargetEnd';\n      var newValue = connectionEnd ? args.newValue.connectorTargetValue : args.newValue.connectorSourceValue;\n      var oldValue = connectionEnd ? args.oldValue.connectorTargetValue : args.oldValue.connectorSourceValue;\n      oldChanges[nodeEndId] = newValue.nodeId;\n      oldChanges[portEndId] = newValue.portId;\n      newChanges[nodeEndId] = oldValue.nodeId;\n      newChanges[portEndId] = oldValue.portId;\n\n      if (args.cancel && args.connectorEnd !== 'ConnectorTargetEnd') {\n        connector.sourceID = oldValue.nodeId;\n\n        if (args.connector.sourcePortID) {\n          connector.sourcePortID = oldValue.portId;\n        }\n\n        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n      }\n\n      if (args.cancel && args.connectorEnd === 'ConnectorTargetEnd') {\n        if (args.connector.targetPortID) {\n          connector.targetPortID = oldValue.portId;\n        }\n\n        connector.targetID = oldValue.nodeId;\n        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n      }\n    }\n  };\n  /**\n   * triggerEvent method\\\n   *\n   * @returns {  Promise<void | object | IBlazorConnectionChangeEventArgs> }    triggerEvent method .\\\n   * @param {DiagramEvent} event - provide the options value.\n   * @param {Object} args - provide the args value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.triggerEvent = function (event, args) {\n    return __awaiter(this, void 0, void 0, function () {\n      var temparg;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (event === DiagramEvent.drop || event === DiagramEvent.positionChange || event === DiagramEvent.connectionChange) {\n              if (this.diagram.currentSymbol) {\n                return [2\n                /*return*/\n                ];\n              }\n\n              if (event === DiagramEvent.drop) {\n                args.source = cloneBlazorObject(this.diagram);\n              }\n\n              if (this.diagram.currentDrawingObject && event !== DiagramEvent.positionChange) {\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            return [4\n            /*yield*/\n            , this.diagram.triggerEvent(event, args)];\n\n          case 1:\n            temparg = _a.sent();\n            return [2\n            /*return*/\n            , temparg];\n        }\n      });\n    });\n  };\n  /**\n   * dragOverElement method\\\n   *\n   * @returns { void }    dragOverElement method .\\\n   * @param {MouseEventArgs} args - provide the options value.\n   * @param {PointModel} currentPosition - provide the args value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragOverElement = function (args, currentPosition) {\n    if (this.diagram.currentSymbol) {\n      var dragOverArg = {\n        element: cloneBlazorObject(args.source),\n        target: cloneBlazorObject(args.target),\n        mousePosition: cloneBlazorObject(currentPosition),\n        diagram: cloneBlazorObject(this.diagram)\n      };\n      this.triggerEvent(DiagramEvent.dragOver, dragOverArg);\n    }\n  };\n  /**\n   * disConnect method\\\n   *\n   * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    disConnect method .\\\n   * @param {IElement} obj - provide the obj value.\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {boolean} canCancel - provide the canCancel value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.disConnect = function (obj, endPoint, canCancel) {\n    var checkBlazor = isBlazor();\n    var oldChanges = {};\n    var newChanges = {};\n    var returnargs;\n    var selectorModel;\n    var connector;\n\n    if (obj instanceof Selector) {\n      selectorModel = obj;\n      connector = selectorModel.connectors[0];\n    } else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n      connector = this.diagram.currentDrawingObject;\n    }\n\n    if (obj && connector && (hasSingleConnection(this.diagram) || this.diagram.currentDrawingObject)) {\n      if (isBlazor()) {\n        this.diagram.insertValue(cloneObject(connector), false);\n      }\n\n      if (endPoint && (endPoint === 'ConnectorSourceEnd' || endPoint === 'ConnectorTargetEnd')) {\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n\n        if (connector[nodeEndId]) {\n          //connector.sourceID || connector.targetID\n          oldChanges[nodeEndId] = connector[nodeEndId];\n          connector[nodeEndId] = '';\n          newChanges[nodeEndId] = connector[nodeEndId];\n\n          if (connector.sourcePortID || connector.targetPortID) {\n            oldChanges[portEndId] = connector[portEndId];\n            connector[portEndId] = '';\n            newChanges[portEndId] = connector[portEndId];\n          }\n\n          returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n        }\n      } else if (endPoint !== 'OrthoThumb' && endPoint !== 'SegmentEnd' && (connector.sourceID || connector.targetID)) {\n        oldChanges = {\n          sourceID: connector.sourceID,\n          sourcePortID: connector.sourcePortID,\n          targetID: connector.targetID,\n          targetPortID: connector.targetPortID\n        };\n        connector.sourceID = '';\n        connector.sourcePortID = '';\n        connector.targetID = '';\n        connector.targetPortID = '';\n        newChanges = {\n          sourceID: connector.sourceID,\n          sourcePortID: connector.sourcePortID,\n          targetID: connector.targetID,\n          targetPortID: connector.targetPortID\n        };\n        var arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: oldChanges,\n          newValue: newChanges,\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (isBlazor()) {\n          arg = {\n            connector: cloneBlazorObject(connector),\n            oldValue: {\n              connector: cloneBlazorObject(oldChanges)\n            },\n            newValue: {\n              connector: cloneBlazorObject(newChanges)\n            },\n            cancel: false,\n            state: 'Changed',\n            connectorEnd: endPoint\n          };\n          returnargs = arg;\n        }\n\n        if (!checkBlazor) {\n          this.triggerEvent(DiagramEvent.connectionChange, arg);\n        }\n\n        if (arg.cancel) {\n          connector.sourceID = oldChanges.sourceID;\n          connector.sourcePortID = oldChanges.sourcePortID;\n          connector.targetID = oldChanges.targetID;\n          connector.targetPortID = oldChanges.targetPortID;\n        } else {\n          this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n          this.diagram.updateDiagramObject(connector);\n          arg = {\n            connector: connector,\n            oldValue: oldChanges,\n            newValue: newChanges,\n            cancel: false,\n            state: 'Changed',\n            connectorEnd: endPoint\n          };\n\n          if (isBlazor()) {\n            arg = {\n              connector: cloneBlazorObject(connector),\n              oldValue: {\n                connector: oldChanges\n              },\n              newValue: {\n                connector: newChanges\n              },\n              cancel: false,\n              state: 'Changed',\n              connectorEnd: endPoint\n            };\n            returnargs = arg;\n          }\n\n          if (!checkBlazor) {\n            this.triggerEvent(DiagramEvent.connectionChange, arg);\n          }\n        }\n      }\n    }\n\n    return returnargs;\n  };\n\n  CommandHandler.prototype.connectionEventChange = function (connector, oldChanges, newChanges, endPoint, canCancel) {\n    var checkBlazor = isBlazor();\n    var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n    var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n    var connectedNode;\n\n    if (this.enableCloneObject) {\n      connectedNode = this.diagram.nameTable[newChanges[nodeEndId]];\n      var nodeObject = cloneObject(connectedNode);\n      this.diagram.insertValue(nodeObject, true);\n    }\n\n    var returnargs;\n    var arg = {\n      cancel: false,\n      state: 'Changing',\n      connectorEnd: endPoint,\n      connector: cloneBlazorObject(connector),\n      oldValue: {\n        nodeId: oldChanges[nodeEndId],\n        portId: oldChanges[portEndId]\n      },\n      newValue: {\n        nodeId: newChanges[nodeEndId],\n        portId: newChanges[portEndId]\n      }\n    };\n\n    if (isBlazor()) {\n      arg = {\n        connector: cloneBlazorObject(connector),\n        cancel: false,\n        state: 'Changing',\n        connectorEnd: endPoint,\n        oldValue: undefined,\n        newValue: undefined\n      };\n\n      if (endPoint === 'ConnectorSourceEnd') {\n        arg.oldValue = {\n          connectorSourceValue: {\n            portId: oldChanges[portEndId],\n            nodeId: oldChanges[nodeEndId]\n          }\n        };\n        arg.newValue = {\n          connectorSourceValue: {\n            nodeId: newChanges[nodeEndId],\n            portId: newChanges[portEndId]\n          }\n        };\n      } else {\n        arg.oldValue = {\n          connectorTargetValue: {\n            nodeId: oldChanges[nodeEndId],\n            portId: oldChanges[portEndId]\n          }\n        };\n        arg.newValue = {\n          connectorTargetValue: {\n            nodeId: newChanges[nodeEndId],\n            portId: newChanges[portEndId]\n          }\n        };\n      }\n\n      returnargs = arg;\n    }\n\n    if (!checkBlazor) {\n      this.triggerEvent(DiagramEvent.connectionChange, arg);\n    }\n\n    if (arg.cancel || isBlazor() && canCancel) {\n      connector[nodeEndId] = oldChanges[nodeEndId];\n      connector[portEndId] = oldChanges[portEndId];\n      newChanges = oldChanges;\n    } else {\n      this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n      this.diagram.updateDiagramObject(connector);\n      arg = {\n        connector: cloneBlazorObject(connector),\n        oldValue: {\n          nodeId: oldChanges[nodeEndId],\n          portId: oldChanges[portEndId]\n        },\n        newValue: {\n          nodeId: newChanges[nodeEndId],\n          portId: newChanges[portEndId]\n        },\n        cancel: false,\n        state: 'Changing',\n        connectorEnd: endPoint\n      };\n\n      if (isBlazor()) {\n        arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: undefined,\n          newValue: undefined,\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (endPoint === 'ConnectorSourceEnd') {\n          arg.newValue = {\n            connectorSourceValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n          arg.oldValue = {\n            connectorSourceValue: {\n              portId: oldChanges[portEndId],\n              nodeId: oldChanges[nodeEndId]\n            }\n          };\n        } else {\n          arg.oldValue = {\n            connectorTargetValue: {\n              nodeId: oldChanges[nodeEndId],\n              portId: oldChanges[portEndId]\n            }\n          };\n          arg.newValue = {\n            connectorTargetValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n        }\n\n        returnargs = arg;\n      }\n    }\n\n    if (this.enableCloneObject) {\n      if (connectedNode === undefined) {\n        connectedNode = this.diagram.nameTable[oldChanges[nodeEndId]];\n        var nodeObject = cloneObject(connectedNode);\n        this.diagram.insertValue(nodeObject, true);\n      }\n    }\n\n    return returnargs;\n  };\n  /**\n   * insertBlazorObject method\\\n   *\n   * @returns { void }    insertBlazorObject method .\\\n   * @param {IElement} object - provide the object value.\n   * @param {boolean} isNode - provide the isNode value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.insertBlazorObject = function (object, isNode) {\n    var node;\n    var connector;\n\n    if (object instanceof Selector) {\n      this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n\n      for (var i = 0; i < object.nodes.length; i++) {\n        node = this.diagram.getObject(object.nodes[i].id);\n        this.diagram.insertValue(cloneObject(node), true);\n      }\n\n      for (var i = 0; i < object.connectors.length; i++) {\n        connector = this.diagram.getObject(object.connectors[i].id);\n        this.diagram.insertValue(cloneObject(connector), false);\n      }\n    } else {\n      object = this.diagram.getObject(object.id);\n      this.diagram.insertValue(cloneObject(object), object instanceof Node ? true : false);\n    }\n  };\n  /**\n   * updatePropertiesToBlazor method\\\n   *\n   * @returns { void }    updatePropertiesToBlazor method .\\\n   * @param {MouseEventArgs} args - provide the args value.\n   * @param {PointModel} labelDrag - provide the labelDrag value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.updatePropertiesToBlazor = function (args, labelDrag) {\n    this.enableCloneObject(false);\n    this.ismouseEvents(false);\n    this.getBlazorOldValues(args, labelDrag);\n    this.updateBlazorSelector();\n  };\n  /**\n   * insertSelectedObjects method\\\n   *\n   * @returns { void }    insertSelectedObjects method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.insertSelectedObjects = function () {\n    this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n  };\n  /**\n   * findTarget method\\\n   *\n   * @returns { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel }    findTarget method .\\\n   * @param {DiagramElement} element - provide the element value.\n   * @param {IElement} argsTarget - provide the argsTarget value.\n   * @param {boolean} source - provide the source value.\n   * @param {boolean} connection - provide the connection value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.findTarget = function (element, argsTarget, source, connection) {\n    var target;\n\n    if (argsTarget instanceof Node) {\n      if (element && element.id === argsTarget.id + '_content') {\n        return argsTarget;\n      }\n\n      if (source && argsTarget.shape.type === 'Bpmn' && (!isBlazor() && argsTarget.shape.shape === 'Activity' || isBlazor() && argsTarget.shape.bpmnShape === 'Activity')) {\n        if (argsTarget.shape.activity.subProcess.type === 'Transaction') {\n          var transaction = argsTarget.shape.activity.subProcess.transaction;\n\n          if (transaction.success.visible && element.id.indexOf(argsTarget.id + '_success') === 0) {\n            return transaction.success;\n          }\n\n          if (transaction.cancel.visible && element.id.indexOf(argsTarget.id + '_cancel') === 0) {\n            return transaction.cancel;\n          }\n\n          if (transaction.failure.visible && element.id.indexOf(argsTarget.id + '_failure') === 0) {\n            return transaction.failure;\n          }\n        }\n      }\n\n      if (element instanceof PathElement) {\n        for (var i = 0; i < argsTarget.ports.length; i++) {\n          var port = argsTarget.ports[i];\n\n          if (element.id === argsTarget.id + '_' + port.id) {\n            return port;\n          }\n        }\n      }\n    }\n\n    if (!connection) {\n      var annotation = void 0;\n\n      for (var i = 0; i < argsTarget.annotations.length; i++) {\n        annotation = argsTarget.annotations[i];\n\n        if (element.id === argsTarget.id + '_' + annotation.id) {\n          return annotation;\n        }\n      }\n    }\n\n    return argsTarget;\n  };\n  /**\n   * canDisconnect method\\\n   *\n   * @returns { boolean }    canDisconnect method .\\\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {MouseEventArgs} args - provide the args value.\n   * @param {string} targetPortId - provide the targetPortId value.\n   * @param {string} targetNodeId - provide the targetNodeId value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.canDisconnect = function (endPoint, args, targetPortId, targetNodeId) {\n    var selector;\n    var connect;\n\n    if (args.source instanceof Selector) {\n      selector = args.source;\n      connect = selector.connectors[0];\n    } else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n      connect = this.diagram.currentDrawingObject;\n    }\n\n    var targetObject = this.findTarget(args.targetWrapper, args.target, endPoint === 'ConnectorSourceEnd', true);\n    var nodeEnd = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n    var portEnd = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n\n    if (connect[nodeEnd] !== targetNodeId || connect[portEnd] !== targetPortId) {\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * changeAnnotationDrag method\\\n   *\n   * @returns { void }    changeAnnotationDrag method .\\\n   * @param {MouseEventArgs} args - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.changeAnnotationDrag = function (args) {\n    var selectorModel;\n    var connector;\n\n    if (args.source && args.source.connectors && args.source.connectors.length && this.diagram.bpmnModule && this.diagram.bpmnModule.textAnnotationConnectors.indexOf(args.source.connectors[0]) > -1) {\n      if (args.source instanceof Selector) {\n        selectorModel = args.source;\n        connector = selectorModel.connectors[0];\n      }\n\n      var id = connector.id.split('_');\n      var annotationId = id[id.length - 1];\n      var nodeId = id[id.length - 3] || id[0];\n\n      if (args.target && args.target.id !== nodeId && (!isBlazor() && args.target.shape.shape !== 'TextAnnotation' || isBlazor() && args.target.shape.bpmnShape !== 'TextAnnotation')) {\n        this.diagram.startGroupAction();\n        var parentNode = this.diagram.nameTable[id[0]];\n        var clonedNode = this.getAnnotation(parentNode, id[1]);\n        var annotationNode = {\n          id: id[1] + randomId(),\n          angle: Point.findAngle(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n          text: clonedNode.text,\n          length: Point.distancePoints(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n          shape: {\n            shape: 'TextAnnotation',\n            type: 'Bpmn'\n          },\n          nodeId: clonedNode.nodeId\n        };\n        var annotationObj = new BpmnAnnotation(args.target.shape, 'annotations', annotationNode, true);\n        this.diagram.bpmnModule.checkAndRemoveAnnotations(this.diagram.nameTable[connector.targetID], this.diagram);\n        this.diagram.refreshCanvasLayers();\n        annotationObj.id = id[1];\n        this.diagram.addTextAnnotation(annotationObj, args.target);\n        this.diagram.endGroupAction();\n      } else if (connector) {\n        connector.sourceID = nodeId;\n        this.diagram.connectorPropertyChange(connector, {}, {\n          sourceID: nodeId\n        });\n        this.diagram.updateDiagramObject(connector);\n      }\n    }\n  };\n  /* tslint:disable */\n\n  /**\n   * connect method\\\n   *\n   * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    connect method .\\\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {MouseEventArgs} args - provide the args value.\n   * @param {boolean} canCancel - provide the canCancel value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.connect = function (endPoint, args, canCancel) {\n    var checkBlazor;\n    var newChanges = {};\n    var oldChanges = {};\n    var oldNodeId;\n    var oldPortId;\n    var selectorModel;\n    var connector;\n    var returnargs;\n\n    if (args.source instanceof Selector) {\n      selectorModel = args.source;\n      connector = selectorModel.connectors[0];\n    } else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n      connector = this.diagram.currentDrawingObject;\n    }\n\n    var target = this.findTarget(args.targetWrapper || args.sourceWrapper, args.target || args.actualObject, endPoint === 'ConnectorSourceEnd', true);\n    var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n    var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n\n    if (target instanceof Node) {\n      oldChanges[nodeEndId] = connector[nodeEndId];\n      connector[nodeEndId] = target.id;\n      newChanges[nodeEndId] = connector[nodeEndId];\n      oldChanges[portEndId] = connector[portEndId];\n      returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n    } else {\n      oldNodeId = connector[nodeEndId];\n      oldPortId = connector[portEndId];\n      connector[portEndId] = target.id;\n      connector[nodeEndId] = args.target && args.target.id || args.actualObject.id;\n      newChanges[nodeEndId] = connector[nodeEndId];\n      newChanges[portEndId] = connector[portEndId];\n      var arg = {\n        connector: cloneBlazorObject(connector),\n        oldValue: {\n          nodeId: oldNodeId,\n          portId: oldPortId\n        },\n        newValue: {\n          nodeId: newChanges[nodeEndId],\n          portId: newChanges[portEndId]\n        },\n        cancel: false,\n        state: 'Changing',\n        connectorEnd: endPoint\n      };\n\n      if (isBlazor()) {\n        arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: undefined,\n          newValue: undefined,\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (endPoint === 'ConnectorSourceEnd') {\n          arg.oldValue = {\n            connectorSourceValue: {\n              portId: oldChanges[portEndId],\n              nodeId: oldChanges[nodeEndId]\n            }\n          };\n          arg.newValue = {\n            connectorSourceValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n        } else {\n          arg.newValue = {\n            connectorTargetValue: {\n              portId: newChanges[portEndId],\n              nodeId: newChanges[nodeEndId]\n            }\n          };\n          arg.oldValue = {\n            connectorTargetValue: {\n              portId: oldChanges[portEndId],\n              nodeId: oldChanges[nodeEndId]\n            }\n          };\n        }\n\n        returnargs = arg;\n      }\n\n      if (!checkBlazor) {\n        this.triggerEvent(DiagramEvent.connectionChange, arg);\n      }\n\n      if (arg.cancel || isBlazor() && canCancel) {\n        connector[nodeEndId] = oldNodeId;\n        connector[portEndId] = oldPortId;\n        newChanges[nodeEndId] = oldNodeId;\n        newChanges[portEndId] = oldPortId;\n      } else {\n        this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n        this.diagram.updateDiagramObject(connector);\n        arg = {\n          connector: cloneBlazorObject(connector),\n          oldValue: {\n            nodeId: oldNodeId,\n            portId: oldPortId\n          },\n          newValue: {\n            nodeId: newChanges[nodeEndId],\n            portId: newChanges[portEndId]\n          },\n          cancel: false,\n          state: 'Changing',\n          connectorEnd: endPoint\n        };\n\n        if (isBlazor()) {\n          arg = {\n            newValue: undefined,\n            connector: cloneBlazorObject(connector),\n            oldValue: undefined,\n            cancel: false,\n            state: 'Changing',\n            connectorEnd: endPoint\n          };\n\n          if (endPoint === 'ConnectorSourceEnd') {\n            arg.oldValue = {\n              connectorSourceValue: {\n                portId: oldChanges[portEndId],\n                nodeId: oldChanges[nodeEndId]\n              }\n            };\n            arg.newValue = {\n              connectorTargetValue: {\n                portId: newChanges[portEndId],\n                nodeId: newChanges[nodeEndId]\n              }\n            };\n          } else {\n            arg.oldValue = {\n              connectorTargetValue: {\n                portId: oldChanges[portEndId],\n                nodeId: oldChanges[nodeEndId]\n              }\n            };\n            arg.newValue = {\n              connectorTargetValue: {\n                portId: newChanges[portEndId],\n                nodeId: newChanges[nodeEndId]\n              }\n            };\n          }\n        }\n      }\n    }\n\n    this.renderHighlighter(args, undefined, endPoint === 'ConnectorSourceEnd');\n    return returnargs;\n  };\n  /* tslint:enable */\n\n  /** @private */\n\n  /**\n   * cut method\\\n   *\n   * @returns { void }    cut method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.cut = function () {\n    var index;\n    this.clipboardData.pasteIndex = 0;\n\n    if (this.diagram.undoRedoModule) {\n      this.diagram.historyManager.startGroupAction();\n    }\n\n    this.clipboardData.clipObject = this.copyObjects();\n\n    if (this.diagram.undoRedoModule) {\n      this.diagram.historyManager.endGroupAction();\n    }\n\n    if (this.diagram.mode !== 'SVG') {\n      this.diagram.refreshDiagramLayer();\n    }\n  };\n\n  CommandHandler.prototype.UpdateBlazorDiagramModelLayers = function (layer, isRemove) {\n    var blazorInterop = 'sfBlazor';\n    var updatedModel = cloneBlazorObject(layer);\n    var blazor = 'Blazor';\n\n    if (window && window[blazor]) {\n      var obj = {\n        'methodName': 'UpdateBlazorDiagramModelLayers',\n        'diagramobj': JSON.stringify(updatedModel),\n        'isRemove': isRemove\n      };\n\n      if (!this.diagram.isLoading) {\n        window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n      }\n    }\n  };\n  /**\n   * addLayer method\\\n   *\n   * @returns { void }    addLayer method .\\\n   * @param {LayerModel} layer - provide the endPoint value.\n   * @param {Object[]} objects - provide the args value.\n   * @param {boolean} isServerUpdate - provide the canCancel value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.addLayer = function (layer, objects, isServerUpdate) {\n    if (isServerUpdate === void 0) {\n      isServerUpdate = true;\n    }\n\n    layer.id = layer.id || randomId();\n    layer.zIndex = this.diagram.layers.length;\n    var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n    this.diagram.enableServerDataBinding(false);\n    layer = new Layer(this.diagram, 'layers', layer, true);\n    this.diagram.enableServerDataBinding(isEnableServerDatabind);\n    layer.objectZIndex = -1;\n    layer.zIndexTable = {};\n    this.diagram.layers.push(layer);\n\n    if (isServerUpdate) {\n      this.UpdateBlazorDiagramModelLayers(layer, false);\n    }\n\n    this.diagram.layerZIndexTable[layer.zIndex] = layer.id;\n    this.diagram.activeLayer = layer;\n    var layers = layer.objects;\n\n    if (objects) {\n      for (var i = 0; i < objects.length; i++) {\n        this.diagram.add(objects[i]);\n      }\n    }\n  };\n  /**\n   * getObjectLayer method\\\n   *\n   * @returns { LayerModel }    getObjectLayer method .\\\n   * @param {string} objectName - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.getObjectLayer = function (objectName) {\n    var layers = this.diagram.layers;\n\n    for (var i = 0; i < layers.length; i++) {\n      var objIndex = layers[i].objects.indexOf(objectName);\n\n      if (objIndex > -1) {\n        return layers[i];\n      }\n    }\n\n    return this.diagram.activeLayer;\n  };\n  /**\n   * getLayer method\\\n   *\n   * @returns { LayerModel }    getLayer method .\\\n   * @param {string} layerName - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.getLayer = function (layerName) {\n    var layers = this.diagram.layers;\n\n    for (var i = 0; i < layers.length; i++) {\n      if (layers[i].id === layerName) {\n        return layers[i];\n      }\n    }\n\n    return undefined;\n  };\n  /**\n   * removeLayer method\\\n   *\n   * @returns { void }    removeLayer method .\\\n   * @param {string} layerId - provide the endPoint value.\n   * @param {boolean} isServerUpdate - provide the endPoint value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeLayer = function (layerId, isServerUpdate) {\n    if (isServerUpdate === void 0) {\n      isServerUpdate = true;\n    }\n\n    var layers = this.getLayer(layerId);\n\n    if (layers) {\n      var index = this.diagram.layers.indexOf(layers);\n      var layerObject = layers.objects;\n\n      for (var i = layerObject.length - 1; i >= 0; i--) {\n        this.diagram.unSelect(this.diagram.nameTable[layerObject[i]]);\n        this.diagram.remove(this.diagram.nameTable[layerObject[i]]);\n\n        if (layers.id !== 'default_layer') {\n          if (this.diagram.activeLayer.id === layerId) {\n            this.diagram.activeLayer = this.diagram.layers[this.diagram.layers.length - 1];\n          }\n        }\n      }\n\n      if (isServerUpdate) {\n        this.UpdateBlazorDiagramModelLayers(this.diagram.layers[index], true);\n      }\n\n      delete this.diagram.layerZIndexTable[layers.zIndex];\n      this.diagram.layers.splice(index, 1);\n\n      if (this.diagram.mode !== 'SVG') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * moveObjects method\\\n   *\n   * @returns { void }    moveObjects method .\\\n   * @param {string[]]} objects - provide the objects value.\n   * @param {string} targetLayer - provide the targetLayer value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.moveObjects = function (objects, targetLayer) {\n    var layer = this.getLayer(targetLayer) || this.diagram.activeLayer;\n    this.diagram.setActiveLayer(layer.id);\n    var targerNodes;\n\n    for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {\n      var i = objects_1[_i];\n      var layer_1 = this.getObjectLayer(i);\n      var index = layer_1.objects.indexOf(i);\n\n      if (index > -1) {\n        targerNodes = this.diagram.nameTable[i];\n        this.diagram.unSelect(targerNodes);\n        this.diagram.remove(this.diagram.nameTable[i]);\n        this.diagram.add(targerNodes);\n      }\n    }\n  };\n  /**\n   * cloneLayer method\\\n   *\n   * @returns { void }    cloneLayer method .\\\n   * @param {string[]} layerName - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.cloneLayer = function (layerName) {\n    var layers = this.diagram.layers;\n    var layer = this.getLayer(layerName);\n\n    if (layer) {\n      var cloneObject_1 = [];\n      var newlayer = {\n        id: layerName + '_' + randomId(),\n        objects: [],\n        visible: true,\n        lock: false\n      };\n      this.addLayer(newlayer, null, true);\n      newlayer.zIndex = this.diagram.layers.length - 1;\n      var multiSelect = cloneObject_1.length !== 1;\n\n      for (var _i = 0, _a = layer.objects; _i < _a.length; _i++) {\n        var obj = _a[_i];\n        cloneObject_1.push(this.diagram.nameTable[obj]);\n      }\n\n      this.paste(cloneObject_1);\n    }\n  };\n  /**\n   * copy method\\\n   *\n   * @returns { void }    copy method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.copy = function () {\n    this.clipboardData.pasteIndex = 1;\n    this.clipboardData.clipObject = this.copyObjects();\n    return this.clipboardData.clipObject;\n  };\n  /**\n   * copyObjects method\\\n   *\n   * @returns { Object[] }    copyObjects method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.copyObjects = function () {\n    var selectedItems = [];\n    var obj = [];\n    this.clipboardData.childTable = {};\n\n    if (this.diagram.selectedItems.connectors.length > 0) {\n      selectedItems = this.diagram.selectedItems.connectors;\n\n      for (var j = 0; j < selectedItems.length; j++) {\n        var element = void 0;\n\n        if (this.diagram.bpmnModule && this.diagram.bpmnModule.textAnnotationConnectors.indexOf(selectedItems[j]) > -1) {\n          element = cloneObject(this.diagram.nameTable[selectedItems[j].targetID]);\n        } else {\n          element = cloneObject(selectedItems[j]);\n        }\n\n        obj.push(element);\n      }\n    }\n\n    if (this.diagram.selectedItems.nodes.length > 0) {\n      selectedItems = selectedItems.concat(this.diagram.selectedItems.nodes);\n\n      for (var j = 0; j < this.diagram.selectedItems.nodes.length; j++) {\n        if (!selectedItems[j].isPhase) {\n          var node = clone(this.diagram.selectedItems.nodes[j]);\n\n          if (node.wrapper && node.offsetX !== node.wrapper.offsetX) {\n            node.offsetX = node.wrapper.offsetX;\n          }\n\n          if (node.wrapper && node.offsetY !== node.wrapper.offsetY) {\n            node.offsetY = node.wrapper.offsetY;\n          }\n\n          var processTable = {};\n          this.copyProcesses(node);\n          obj.push(clone(node));\n          var matrix = identityMatrix();\n          rotateMatrix(matrix, -node.rotateAngle, node.offsetX, node.offsetY);\n\n          if (node.children) {\n            var childTable = this.clipboardData.childTable;\n            var tempNode = void 0;\n            var elements = [];\n            var nodes = this.getAllDescendants(node, elements, true);\n\n            for (var i = 0; i < nodes.length; i++) {\n              tempNode = this.diagram.nameTable[nodes[i].id];\n              var clonedObject = childTable[tempNode.id] = clone(tempNode);\n              var newOffset = transformPointByMatrix(matrix, {\n                x: clonedObject.wrapper.offsetX,\n                y: clonedObject.wrapper.offsetY\n              });\n\n              if (tempNode instanceof Node) {\n                clonedObject.offsetX = newOffset.x;\n                clonedObject.offsetY = newOffset.y;\n                clonedObject.rotateAngle -= node.rotateAngle;\n              }\n            }\n\n            this.clipboardData.childTable = childTable;\n          }\n\n          if (node.shape.type === 'SwimLane') {\n            var swimlane = this.diagram.getObject(this.diagram.selectedItems.nodes[j].id);\n            var childTable = this.clipboardData.childTable;\n            var connectorsList = getConnectors(this.diagram, swimlane.wrapper.children[0], 0, true);\n\n            for (var i = 0; i < connectorsList.length; i++) {\n              var connector = this.diagram.getObject(connectorsList[i]);\n              childTable[connector.id] = clone(connector);\n            }\n          }\n\n          if (node && node.isLane) {\n            var childTable = this.clipboardData.childTable;\n            var swimlane = this.diagram.getObject(node.parentId);\n            var lane = findLane(node, this.diagram);\n            childTable[node.id] = cloneObject(lane);\n            childTable[node.id].width = swimlane.wrapper.actualSize.width;\n          }\n        }\n      }\n    }\n\n    if (this.clipboardData.pasteIndex === 0) {\n      this.startGroupAction();\n\n      for (var _i = 0, selectedItems_1 = selectedItems; _i < selectedItems_1.length; _i++) {\n        var item = selectedItems_1[_i];\n\n        if (this.diagram.nameTable[item.id]) {\n          if (this.diagram.bpmnModule && this.diagram.bpmnModule.textAnnotationConnectors.indexOf(item) > -1) {\n            this.diagram.remove(this.diagram.nameTable[item.targetID]);\n          } else {\n            this.diagram.remove(item);\n          }\n        }\n      }\n\n      this.endGroupAction();\n    }\n\n    this.sortByZIndex(obj, 'zIndex');\n    return obj;\n  };\n\n  CommandHandler.prototype.copyProcesses = function (node) {\n    if (node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length > 0) {\n      var processes = node.shape.activity.subProcess.processes;\n\n      for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {\n        var i = processes_1[_i];\n        this.processTable[i] = clone(this.diagram.nameTable[i]);\n\n        if (this.processTable[i].shape.activity.subProcess.processes && this.processTable[i].shape.activity.subProcess.processes.length > 0) {\n          this.copyProcesses(this.processTable[i]);\n        }\n      }\n\n      this.clipboardData.processTable = this.processTable;\n    }\n  };\n  /**\n   * group method\\\n   *\n   * @returns { void }    group method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.group = function () {\n    this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n    var propName = 'isProtectedOnChange';\n    var protectedChange = this.diagram[propName];\n    this.diagram.protectPropertyChange(true);\n    this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n    var selectedItems = [];\n    var obj = {}; //let group: Node | Connector;\n\n    obj.id = 'group' + randomId();\n    obj = new Node(this.diagram, 'nodes', obj, true);\n    obj.children = [];\n    selectedItems = this.diagram.selectedItems.nodes;\n    selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);\n\n    for (var i = 0; i < selectedItems.length; i++) {\n      if (!selectedItems[i].parentId) {\n        obj.children.push(selectedItems[i].id);\n      }\n    }\n\n    var group = this.diagram.add(obj);\n\n    if (group) {\n      this.select(group);\n    }\n\n    var entry = {\n      type: 'Group',\n      undoObject: obj,\n      redoObject: obj,\n      category: 'Internal'\n    };\n    this.addHistoryEntry(entry);\n    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n    this.diagram.protectPropertyChange(protectedChange);\n    this.updateBlazorSelector();\n  };\n  /**\n   * unGroup method\\\n   *\n   * @returns {  void }    unGroup method .\\\n   * @param {NodeModel} obj - provide the angle value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.unGroup = function (obj) {\n    var propName = 'isProtectedOnChange';\n    var protectedChange = this.diagram[propName];\n    this.diagram.protectPropertyChange(true);\n    this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n    var selectedItems = [];\n\n    if (obj) {\n      selectedItems.push(obj);\n    } else {\n      selectedItems = this.diagram.selectedItems.nodes;\n    }\n\n    this.diagram.startGroupAction();\n\n    for (var i = 0; i < selectedItems.length; i++) {\n      var node = selectedItems[i];\n      var undoObject = cloneObject(node);\n      var childCollection = [];\n\n      for (var k = 0; k < node.children.length; k++) {\n        childCollection.push(node.children[k]);\n      }\n\n      if (node.children) {\n        if (node.ports && node.ports.length > 0) {\n          this.diagram.removePorts(node, node.ports);\n        }\n\n        if (node.annotations && node.annotations.length > 0 && (!isBlazor() || isBlazor() && node.annotations[0].content !== '')) {\n          this.diagram.removeLabels(node, node.annotations);\n        }\n\n        var parentNode = this.diagram.nameTable[node.parentId];\n\n        for (var j = node.children.length - 1; j >= 0; j--) {\n          this.diagram.nameTable[node.children[j]].parentId = '';\n          this.diagram.deleteChild(this.diagram.nameTable[node.children[j]], node);\n\n          if (node.parentId && node.children[j]) {\n            this.diagram.addChild(parentNode, node.children[j]);\n          }\n        }\n\n        this.resetDependentConnectors(node.inEdges, true);\n        this.resetDependentConnectors(node.outEdges, false);\n        var entry = {\n          type: 'UnGroup',\n          undoObject: undoObject,\n          redoObject: undoObject,\n          category: 'Internal'\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(entry);\n        }\n\n        if (node.parentId) {\n          this.diagram.deleteChild(node, parentNode);\n        }\n      }\n\n      this.diagram.removeNode(node, childCollection);\n      this.clearSelection();\n    }\n\n    this.diagram.endGroupAction();\n    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n    this.diagram.protectPropertyChange(protectedChange);\n  };\n\n  CommandHandler.prototype.resetDependentConnectors = function (edges, isInEdges) {\n    for (var i = 0; i < edges.length; i++) {\n      var newConnector = this.diagram.nameTable[edges[i]];\n      var undoObject = cloneObject(newConnector);\n      var newProp = void 0;\n\n      if (isInEdges) {\n        newConnector.targetID = '';\n        newConnector.targetPortID = '';\n        newProp = {\n          targetID: newConnector.targetID,\n          targetPortID: newConnector.targetPortID\n        };\n      } else {\n        newConnector.sourceID = '';\n        newConnector.sourcePortID = '';\n        newProp = {\n          sourceID: newConnector.sourceID,\n          sourcePortID: newConnector.sourcePortID\n        };\n      }\n\n      this.diagram.connectorPropertyChange(newConnector, {}, newProp);\n      var entry = {\n        type: 'ConnectionChanged',\n        undoObject: {\n          connectors: [undoObject],\n          nodes: []\n        },\n        redoObject: {\n          connectors: [cloneObject(newConnector)],\n          nodes: []\n        },\n        category: 'Internal'\n      };\n\n      if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n        this.addHistoryEntry(entry);\n      }\n    }\n  };\n  /**\n   * paste method\\\n   *\n   * @returns { void }    paste method .\\\n   * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.paste = function (obj) {\n    if (obj || this.clipboardData.clipObject) {\n      this.diagram.protectPropertyChange(true);\n      var copiedItems = obj ? this.getNewObject(obj) : this.clipboardData.clipObject;\n\n      if (copiedItems) {\n        var multiSelect = copiedItems.length !== 1;\n        var groupAction = false;\n        var objectTable = {};\n        var keyTable = {};\n\n        if (this.clipboardData.pasteIndex !== 0) {\n          this.clearSelection();\n        }\n\n        if (this.diagram.undoRedoModule) {\n          groupAction = true;\n          this.diagram.historyManager.startGroupAction();\n        }\n\n        for (var _i = 0, copiedItems_1 = copiedItems; _i < copiedItems_1.length; _i++) {\n          var copy = copiedItems_1[_i];\n          objectTable[copy.id] = copy;\n        }\n\n        var copiedObject = [];\n\n        if (multiSelect) {\n          // This bool is also consider to prevent selection change event is triggered after every object clone\n          this.diagram.isServerUpdate = true;\n        }\n\n        for (var j = 0; j < copiedItems.length; j++) {\n          var copy = copiedItems[j];\n\n          if (getObjectType(copy) === Connector) {\n            var clonedObj = clone(copy);\n            var nodeId = clonedObj.sourceID;\n            clonedObj.sourceID = '';\n\n            if (objectTable[nodeId] && keyTable[nodeId]) {\n              clonedObj.sourceID = keyTable[nodeId];\n            }\n\n            nodeId = clonedObj.targetID;\n            clonedObj.targetID = '';\n\n            if (objectTable[nodeId] && keyTable[nodeId]) {\n              clonedObj.targetID = keyTable[nodeId];\n            }\n\n            var newObj = this.cloneConnector(clonedObj, multiSelect);\n            copiedObject.push(newObj);\n            keyTable[copy.id] = newObj.id;\n          } else {\n            var newNode = this.cloneNode(copy, multiSelect);\n\n            if (isBlazor() && newNode && newNode.children && newNode.children.length > 0) {\n              copiedObject = copiedObject.concat(this.cloneGroupChildCollection);\n              this.cloneGroupChildCollection = [];\n            } else {\n              copiedObject.push(newNode);\n            } //bpmn text annotations will not be pasted\n\n\n            if (newNode) {\n              keyTable[copy.id] = newNode.id;\n              var edges = copy.inEdges;\n\n              if (edges) {\n                for (var _a = 0, edges_1 = edges; _a < edges_1.length; _a++) {\n                  var edge = edges_1[_a];\n\n                  if (objectTable[edge] && keyTable[edge]) {\n                    var newConnector = this.diagram.nameTable[keyTable[edge]];\n                    newConnector.targetID = keyTable[copy.id];\n                    this.diagram.connectorPropertyChange(newConnector, {\n                      targetID: '',\n                      targetPortID: ''\n                    }, {\n                      targetID: newConnector.targetID,\n                      targetPortID: newConnector.targetPortID\n                    });\n                  }\n                }\n              }\n\n              edges = copy.outEdges;\n\n              if (edges) {\n                for (var _b = 0, edges_2 = edges; _b < edges_2.length; _b++) {\n                  var edge = edges_2[_b];\n\n                  if (objectTable[edge] && keyTable[edge]) {\n                    var newConnector = this.diagram.nameTable[keyTable[edge]];\n                    newConnector.sourceID = keyTable[copy.id];\n                    this.diagram.connectorPropertyChange(newConnector, {\n                      sourceID: '',\n                      sourcePortID: ''\n                    }, {\n                      sourceID: newConnector.sourceID,\n                      sourcePortID: newConnector.sourcePortID\n                    });\n                  }\n                }\n              }\n            }\n          }\n        }\n\n        if (multiSelect) {\n          this.diagram.isServerUpdate = false;\n          this.diagram.UpdateBlazorDiagramModelCollection(copiedItems[0], copiedObject);\n          this.getBlazorOldValues();\n          this.diagram.select(copiedObject, true);\n        }\n\n        if (groupAction === true) {\n          this.diagram.historyManager.endGroupAction();\n          groupAction = false;\n        }\n\n        if (this.diagram.mode !== 'SVG') {\n          this.diagram.refreshDiagramLayer();\n        }\n\n        this.clipboardData.pasteIndex++;\n        this.diagram.protectPropertyChange(false);\n      }\n    }\n  };\n\n  CommandHandler.prototype.getNewObject = function (obj) {\n    var newObj;\n    var newobjs = [];\n    this.clipboardData.pasteIndex = 1;\n\n    for (var i = 0; i < obj.length; i++) {\n      newObj = cloneObject(obj[i]);\n      newobjs.push(newObj);\n    }\n\n    return newobjs;\n  };\n\n  CommandHandler.prototype.cloneConnector = function (connector, multiSelect) {\n    //let newConnector: Node | Connector;\n    var cloneObject = clone(connector);\n    this.translateObject(cloneObject);\n    cloneObject.zIndex = -1;\n    var newConnector = this.diagram.add(cloneObject);\n\n    if (!this.diagram.isServerUpdate) {\n      this.selectObjects([newConnector], multiSelect);\n    }\n\n    return newConnector;\n  };\n\n  CommandHandler.prototype.cloneNode = function (node, multiSelect, children, groupnodeID) {\n    var newNode;\n    var connectorsTable = {};\n    var cloneObject = clone(node);\n    var process;\n    var temp = this.diagram.nameTable[node.parentId];\n\n    if (node.shape && node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length) {\n      process = cloneObject.shape.activity.subProcess.processes;\n      cloneObject.zIndex = -1;\n      cloneObject.shape.activity.subProcess.processes = undefined;\n    }\n\n    if (node.shape && node.shape.type === 'SwimLane') {\n      pasteSwimLane(node, this.diagram, this.clipboardData);\n    } else if (temp && temp.shape.type === 'SwimLane') {\n      pasteSwimLane(clone(temp), this.diagram, this.clipboardData, node, true);\n    } else if (node.children && node.children.length && (!children || !children.length)) {\n      newNode = this.cloneGroup(node, multiSelect);\n    } else if (node.shape && (!isBlazor() && node.shape.shape === 'TextAnnotation' || isBlazor() && node.shape.bpmnShape === 'TextAnnotation') && node.id.indexOf('_textannotation_') !== -1 && this.diagram.nameTable[node.id]) {\n      var checkAnnotation = node.id.split('_textannotation_'); //const parentNode: Node;\n\n      var annotation = this.diagram.nameTable[node.id];\n\n      for (var j = 0; j < annotation.inEdges.length; j++) {\n        var connector = this.diagram.nameTable[annotation.inEdges[j]];\n\n        if (connector) {\n          var parentNode = this.diagram.nameTable[connector.sourceID];\n          var clonedNode = this.getAnnotation(parentNode, checkAnnotation[1]);\n          var annotationNode = {\n            id: checkAnnotation[1] + randomId(),\n            angle: clonedNode.angle,\n            text: clonedNode.text,\n            length: clonedNode.length,\n            shape: {\n              shape: 'TextAnnotation',\n              type: 'Bpmn'\n            },\n            nodeId: clonedNode.nodeId\n          };\n          this.diagram.addTextAnnotation(annotationNode, parentNode);\n        }\n      }\n    } else {\n      this.translateObject(cloneObject, groupnodeID);\n      cloneObject.zIndex = -1;\n\n      if (children) {\n        cloneObject.children = children;\n      }\n\n      newNode = this.diagram.add(cloneObject);\n    }\n\n    for (var _i = 0, _a = Object.keys(connectorsTable); _i < _a.length; _i++) {\n      var i = _a[_i];\n      this.diagram.add(connectorsTable[i]);\n    }\n\n    if (process && process.length) {\n      newNode.shape.activity.subProcess.processes = process;\n      this.cloneSubProcesses(newNode);\n    }\n\n    if (newNode && !this.diagram.isServerUpdate) {\n      this.selectObjects([newNode], multiSelect);\n    }\n\n    return newNode;\n  };\n\n  CommandHandler.prototype.getAnnotation = function (parent, annotationId) {\n    var currentAnnotation = parent.shape.annotations;\n\n    if (currentAnnotation && currentAnnotation.length) {\n      for (var g = 0; g <= currentAnnotation.length; g++) {\n        if (currentAnnotation[g].id === annotationId) {\n          return currentAnnotation[g];\n        }\n      }\n    }\n\n    return undefined;\n  };\n\n  CommandHandler.prototype.cloneSubProcesses = function (node) {\n    var connector = [];\n    var temp = {};\n\n    if (node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length) {\n      var process = node.shape.activity.subProcess.processes;\n\n      for (var g = 0; g < process.length; g++) {\n        var child = this.diagram.nameTable[process[g]] || this.clipboardData.processTable[process[g]];\n\n        for (var _i = 0, _a = child.outEdges; _i < _a.length; _i++) {\n          var j = _a[_i];\n\n          if (connector.indexOf(j) < 0) {\n            connector.push(j);\n          }\n        }\n\n        for (var _b = 0, _c = child.inEdges; _b < _c.length; _b++) {\n          var j = _c[_b];\n\n          if (connector.indexOf(j) < 0) {\n            connector.push(j);\n          }\n        }\n\n        var innerChild = cloneObject(this.clipboardData.processTable[process[g]]);\n        innerChild.processId = node.id;\n        var newNode = this.cloneNode(innerChild, false);\n        temp[process[g]] = newNode.id;\n        process[g] = newNode.id;\n        this.diagram.addProcess(newNode, node.id);\n\n        for (var _d = 0, connector_1 = connector; _d < connector_1.length; _d++) {\n          var i = connector_1[_d];\n          var node_1 = this.diagram.nameTable[i] || this.diagram.connectorTable[i];\n          var clonedNode = cloneObject(node_1);\n\n          if (temp[clonedNode.sourceID] && temp[clonedNode.targetID]) {\n            clonedNode.zIndex = -1;\n            clonedNode.id += randomId();\n            clonedNode.sourceID = temp[clonedNode.sourceID];\n            clonedNode.targetID = temp[clonedNode.targetID];\n            connector.splice(connector.indexOf(i), 1);\n            this.diagram.add(clonedNode);\n          }\n        }\n      }\n    }\n  };\n\n  CommandHandler.prototype.cloneGroup = function (obj, multiSelect) {\n    var value;\n    var newChildren = [];\n    var children = [];\n    var connectorObj = [];\n    var newObj;\n    var oldID = [];\n    children = children.concat(obj.children);\n    var id = randomId();\n    var objectCollection = [];\n    this.diagram.blazorActions |= BlazorAction.GroupClipboardInProcess;\n\n    if (this.clipboardData.childTable || obj.children.length > 0) {\n      for (var i = 0; i < children.length; i++) {\n        var childObj = void 0;\n\n        if (this.clipboardData.childTable) {\n          childObj = this.clipboardData.childTable[children[i]];\n        } else {\n          childObj = this.diagram.nameTable[children[i]];\n        }\n\n        childObj.parentId = '';\n\n        if (childObj) {\n          if (getObjectType(childObj) === Connector) {\n            connectorObj.push(childObj);\n          } else {\n            newObj = this.cloneNode(childObj, multiSelect, undefined, id);\n            oldID.push(childObj.id);\n            newChildren.push(newObj.id);\n            objectCollection.push(newObj);\n          }\n        }\n      }\n    }\n\n    for (var k = 0; k < connectorObj.length; k++) {\n      if (connectorObj[k].sourceID || connectorObj[k].targetID) {\n        for (var j = 0; j < oldID.length; j++) {\n          if (connectorObj[k].sourceID === oldID[j]) {\n            connectorObj[k].sourceID += id;\n          }\n\n          if (connectorObj[k].targetID === oldID[j]) {\n            connectorObj[k].targetID += id;\n          }\n        }\n      }\n\n      newObj = this.cloneConnector(connectorObj[k], multiSelect);\n      newChildren.push(newObj.id);\n      objectCollection.push(newObj);\n    }\n\n    var parentObj = this.cloneNode(obj, multiSelect, newChildren);\n    objectCollection.push(parentObj);\n\n    if (parentObj && parentObj.container && parentObj.shape && parentObj.shape.type === 'UmlClassifier') {\n      this.diagram.updateDiagramObject(parentObj);\n      parentObj.wrapper.measure(new Size());\n    }\n\n    this.diagram.blazorActions &= ~BlazorAction.GroupClipboardInProcess;\n\n    if (!this.diagram.isServerUpdate) {\n      this.diagram.UpdateBlazorDiagramModelCollection(undefined, objectCollection, undefined, true);\n    } else {\n      this.cloneGroupChildCollection = objectCollection;\n    }\n\n    return parentObj;\n  };\n  /**\n   * translateObject method\\\n   *\n   * @returns { Object[] }    translateObject method .\\\n   * @param {Node | Connector} obj - provide the objects value.\n   * @param {string} groupnodeID - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.translateObject = function (obj, groupnodeID) {\n    obj.id += groupnodeID || randomId();\n    var diff = this.clipboardData.pasteIndex * 10;\n\n    if (getObjectType(obj) === Connector) {\n      obj.sourcePoint = {\n        x: obj.sourcePoint.x + diff,\n        y: obj.sourcePoint.y + diff\n      };\n      obj.targetPoint = {\n        x: obj.targetPoint.x + diff,\n        y: obj.targetPoint.y + diff\n      };\n\n      if (obj.type === 'Bezier') {\n        var segments = obj.segments;\n\n        for (var i = 0; i < segments.length; i++) {\n          if (!Point.isEmptyPoint(segments[i].point1)) {\n            segments[i].point1 = {\n              x: segments[i].point1.x + diff,\n              y: segments[i].point1.y + diff\n            };\n          }\n\n          if (!Point.isEmptyPoint(segments[i].point2)) {\n            segments[i].point2 = {\n              x: segments[i].point2.x + diff,\n              y: segments[i].point2.y + diff\n            };\n          }\n        }\n      }\n\n      if (obj.type === 'Straight' || obj.type === 'Bezier') {\n        if (obj.segments && obj.segments.length > 0) {\n          var segments = obj.segments;\n\n          for (var i = 0; i < segments.length - 1; i++) {\n            segments[i].point.x += diff;\n            segments[i].point.y += diff;\n          }\n        }\n      }\n    } else {\n      obj.offsetX += diff;\n      obj.offsetY += diff;\n    }\n  };\n  /**\n   * drawObject method\\\n   *\n   * @returns { Node | Connector }    drawObject method .\\\n   * @param {Node | Connector} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.drawObject = function (obj) {\n    var oldProtectPropertyChangeValue;\n\n    if (isBlazor()) {\n      oldProtectPropertyChangeValue = this.diagram.getProtectPropertyChangeValue();\n      this.diagram.protectPropertyChange(true);\n    }\n\n    var newObj; //let cloneObject: Node | Connector;\n\n    if (obj && obj.shape) {\n      if (obj.shape.type === 'Text') {\n        obj.width = this.diagram.drawingObject.width ? this.diagram.drawingObject.width : 50;\n        obj.height = this.diagram.drawingObject.height ? this.diagram.drawingObject.height : 20;\n      }\n    }\n\n    var cloneObject = clone(this.diagram.drawingObject);\n\n    for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n      var prop = _a[_i];\n      cloneObject[prop] = obj[prop];\n    }\n\n    if (getObjectType(this.diagram.drawingObject) === Node) {\n      newObj = new Node(this.diagram, 'nodes', cloneObject, true);\n      newObj.id = (this.diagram.drawingObject.id || 'node') + randomId();\n    } else {\n      newObj = new Connector(this.diagram, 'connectors', cloneObject, true);\n      newObj.id = (this.diagram.drawingObject.id || 'connector') + randomId();\n    }\n\n    if (isBlazor()) {\n      updateDefaultValues(newObj, cloneObject, getObjectType(this.diagram.drawingObject) === Node ? this.diagram.nodeDefaults : this.diagram.connectorDefaults);\n    }\n\n    this.diagram.initObject(newObj);\n    this.diagram.updateDiagramObject(newObj);\n    this.diagram.currentDrawingObject = newObj;\n\n    if (isBlazor()) {\n      this.diagram.protectPropertyChange(oldProtectPropertyChangeValue);\n    }\n\n    return newObj;\n  };\n  /**\n   * addObjectToDiagram method\\\n   *\n   * @returns { void }    addObjectToDiagram method .\\\n   * @param {Node | Connector} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.addObjectToDiagram = function (obj) {\n    //let newObj: Node | Connector;\n    this.diagram.removeFromAQuad(obj);\n    this.diagram.removeObjectsFromLayer(this.diagram.nameTable[obj.id]);\n    delete this.diagram.nameTable[obj.id];\n    var newObj = this.diagram.add(obj);\n\n    if (this.diagram.mode !== 'SVG') {\n      this.diagram.refreshDiagramLayer();\n    }\n\n    this.selectObjects([newObj]);\n\n    if (obj && !canContinuousDraw(this.diagram)) {\n      this.diagram.tool &= ~DiagramTools.DrawOnce;\n      this.diagram.currentDrawingObject = undefined;\n    }\n  };\n  /**\n   * addObjectToDiagram method\\\n   *\n   * @returns { void }    addObjectToDiagram method .\\\n   * @param {boolean} enable - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.enableServerDataBinding = function (enable) {\n    this.diagram.enableServerDataBinding(enable);\n  };\n  /**\n   * addText method\\\n   *\n   * @returns { void }    addText method .\\\n   * @param {boolean} obj - provide the objects value.\n   * @param {PointModel} currentPosition - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.addText = function (obj, currentPosition) {\n    var annotation = this.diagram.findElementUnderMouse(obj, currentPosition);\n    this.diagram.startTextEdit(obj, annotation instanceof TextElement ? annotation.id.split('_')[1] : undefined);\n  };\n\n  CommandHandler.prototype.updateArgsObject = function (obj, arg1, argValue) {\n    if (obj) {\n      var connector = void 0;\n\n      for (var i = 0; i < obj.length; i++) {\n        connector = getObjectType(obj[i]) === Connector;\n\n        if (connector) {\n          // In Blazor web assembly, deserialize the object. Itb takes time. - Suganthi\n          //argValue.connectors.push(cloneBlazorObject(obj[i]));\n          argValue.connectorCollection.push(obj[i].id);\n        } else {\n          //argValue.nodes.push(cloneBlazorObject(obj[i]));\n          argValue.nodeCollection.push(obj[i].id);\n        } //connector ? argValue.connectors.push(cloneBlazorObject(obj[i])) : argValue.nodes.push(cloneBlazorObject(obj[i]));\n\n      }\n    }\n  };\n\n  CommandHandler.prototype.updateSelectionChangeEventArgs = function (arg, obj, oldValue) {\n    if (isBlazor()) {\n      arg = {\n        cause: this.diagram.diagramActions,\n        newValue: {},\n        oldValue: {},\n        state: arg.state,\n        type: arg.type,\n        cancel: false\n      };\n      var argOldValue = arg.oldValue;\n      var argNewValue = arg.newValue;\n      argOldValue.connectors = [];\n      argOldValue.nodes = [];\n      argNewValue.connectors = [];\n      argNewValue.nodes = [];\n      argOldValue.nodeCollection = [];\n      argOldValue.connectorCollection = [];\n      argNewValue.nodeCollection = [];\n      argNewValue.connectorCollection = [];\n      this.updateArgsObject(this.getSelectedObject(), arg, argNewValue);\n      this.updateArgsObject(oldValue, arg, argOldValue);\n      return arg;\n    }\n\n    return arg;\n  };\n  /**\n   * isUserHandle method\\\n   *\n   * @returns { boolean }    isUserHandle method .\\\n   * @param {PointModel} position - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.isUserHandle = function (position) {\n    var handle = this.diagram.selectedItems;\n\n    if (handle.wrapper && canShowCorner(handle.constraints, 'UserHandle')) {\n      for (var _i = 0, _a = handle.userHandles; _i < _a.length; _i++) {\n        var obj = _a[_i];\n\n        if (obj.visible) {\n          var paddedBounds = getUserHandlePosition(handle, obj, this.diagram.scroller.transform);\n\n          if (contains(position, paddedBounds, obj.size / (2 * this.diagram.scroller.transform.scale))) {\n            return true;\n          }\n        }\n      }\n    }\n\n    return false;\n  };\n  /**\n   * selectObjects method\\\n   *\n   * @returns { Promise<void> }    selectObjects method .\\\n   * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n   * @param {boolean} multipleSelection - provide the objects value.\n   * @param {(NodeModel | ConnectorModel)[]} oldValue - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.selectObjects = function (obj, multipleSelection, oldValue) {\n    return __awaiter(this, void 0, void 0, function () {\n      var arg, select, canDoMultipleSelection, canDoSingleSelection, i, newObj, i_1, parentNode, blazorArgs, eventObj, selectedObjects, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            arg = {\n              oldValue: oldValue ? oldValue : this.getSelectedObject(),\n              newValue: obj,\n              cause: this.diagram.diagramActions,\n              state: 'Changing',\n              type: 'Addition',\n              cancel: false\n            };\n            this.diagram.enableServerDataBinding(false);\n            select = true;\n\n            if (!isBlazor()) {\n              this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            } else {\n              this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n            }\n\n            canDoMultipleSelection = canMultiSelect(this.diagram);\n            canDoSingleSelection = canSingleSelect(this.diagram);\n\n            if (canDoSingleSelection || canDoMultipleSelection) {\n              if (!canDoMultipleSelection && (obj.length > 1 || multipleSelection && obj.length === 1)) {\n                if (obj.length === 1) {\n                  this.clearSelection();\n                } else {\n                  return [2\n                  /*return*/\n                  ];\n                }\n              }\n\n              if (!canDoSingleSelection && obj.length === 1 && (!multipleSelection || !hasSelection(this.diagram))) {\n                this.clearSelection();\n                return [2\n                /*return*/\n                ];\n              }\n            }\n\n            if (!!arg.cancel) return [3\n            /*break*/\n            , 5];\n\n            for (i = 0; i < obj.length; i++) {\n              newObj = obj[i];\n\n              if (newObj) {\n                select = true;\n\n                if (!hasSelection(this.diagram)) {\n                  this.select(newObj, i > 0 || multipleSelection, true);\n                } else {\n                  if ((i > 0 || multipleSelection) && newObj.children && !newObj.parentId) {\n                    for (i_1 = 0; i_1 < this.diagram.selectedItems.nodes.length; i_1++) {\n                      parentNode = this.diagram.nameTable[this.diagram.selectedItems.nodes[i_1].parentId];\n\n                      if (parentNode) {\n                        parentNode = this.findParent(parentNode);\n\n                        if (parentNode) {\n                          if (newObj.id === parentNode.id) {\n                            this.selectGroup(newObj);\n                          }\n                        }\n                      }\n                    }\n                  }\n\n                  this.selectProcesses(newObj);\n                  select = this.selectBpmnSubProcesses(newObj);\n\n                  if (select) {\n                    this.select(newObj, i > 0 || multipleSelection, true);\n                  }\n                }\n              }\n            }\n\n            arg = {\n              oldValue: oldValue ? oldValue : [],\n              newValue: this.getSelectedObject(),\n              cause: this.diagram.diagramActions,\n              state: 'Changed',\n              type: 'Addition',\n              cancel: false\n            };\n            this.diagram.renderSelector(multipleSelection || obj && obj.length > 1);\n            this.updateBlazorSelectorModel(oldValue);\n\n            if (isBlazor() && this.diagram.selectionChange) {\n              arg = this.updateSelectionChangeEventArgs(arg, obj, oldValue ? oldValue : []);\n              this.updateBlazorSelector();\n            }\n\n            if (!!isBlazor()) return [3\n            /*break*/\n            , 1];\n            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            return [3\n            /*break*/\n            , 4];\n\n          case 1:\n            blazorArgs = void 0;\n            if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3\n            /*break*/\n            , 3];\n            eventObj = {\n              'EventName': 'selectionChange',\n              args: JSON.stringify(arg)\n            };\n            return [4\n            /*yield*/\n            , window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n\n          case 2:\n            blazorArgs = _a.sent();\n            _a.label = 3;\n\n          case 3:\n            // let blazorArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            if (blazorArgs && blazorArgs.cancel) {\n              selectedObjects = [];\n\n              if (blazorArgs.oldValue.nodes.length > 0) {\n                selectedObjects = blazorArgs.oldValue.nodes;\n              }\n\n              if (blazorArgs.oldValue.connectors.length > 0) {\n                selectedObjects = selectedObjects.concat(blazorArgs.oldValue.connectors);\n              }\n\n              if (selectedObjects) {\n                if (selectedObjects.length > 0) {\n                  for (i = 0; i < selectedObjects.length; i++) {\n                    this.select(this.diagram.nameTable[selectedObjects[i].id], i !== 0 && selectedObjects.length > 1 ? true : false);\n                  }\n                } else {\n                  this.clearSelection();\n                }\n              }\n            }\n\n            _a.label = 4;\n\n          case 4:\n            this.diagram.enableServerDataBinding(true);\n            this.updateBlazorSelector();\n            _a.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * updateBlazorSelector method\\\n   *\n   * @returns { void }    updateBlazorSelector method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateBlazorSelector = function () {\n    if (isBlazor() && this.oldSelectedObjects) {\n      this.newSelectedObjects = cloneSelectedObjects(this.diagram);\n      var result = this.deepDiffer.map(cloneObject(this.newSelectedObjects), this.oldSelectedObjects);\n      var diffValue = this.deepDiffer.frameObject({}, result);\n      var diff = this.deepDiffer.removeEmptyValues(diffValue);\n      diff.nodes = [];\n\n      for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {\n        diff.nodes.push(this.diagram.selectedItems.nodes[i].id);\n      }\n\n      diff.connectors = [];\n\n      for (var i = 0; i < this.diagram.selectedItems.connectors.length; i++) {\n        diff.connectors.push(this.diagram.selectedItems.connectors[i].id);\n      }\n\n      var blazorInterop = 'sfBlazor';\n      var blazor = 'Blazor';\n\n      if (window && window[blazor]) {\n        var obj = {\n          'methodName': 'UpdateBlazorProperties',\n          'diagramobj': {\n            selectedItems: diff\n          }\n        };\n        window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n      }\n\n      this.oldSelectedObjects = undefined;\n      this.newSelectedObjects = undefined;\n    }\n  };\n  /**\n   * findParent method\\\n   *\n   * @returns { Node }    findParent method .\\\n   * @param {Node} node - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.findParent = function (node) {\n    if (node.parentId) {\n      node = this.diagram.nameTable[node.parentId];\n      this.findParent(node);\n    }\n\n    return node;\n  };\n\n  CommandHandler.prototype.selectProcesses = function (newObj) {\n    if (this.hasProcesses(newObj)) {\n      var processes = newObj.shape.activity.subProcess.processes;\n\n      for (var i = 0; i < processes.length; i++) {\n        var innerChild = this.diagram.nameTable[processes[i]];\n\n        if (this.hasProcesses(innerChild)) {\n          this.selectObjects([innerChild], true);\n        }\n\n        this.unSelect(innerChild);\n      }\n    }\n  };\n\n  CommandHandler.prototype.selectGroup = function (newObj) {\n    for (var j = 0; j < newObj.children.length; j++) {\n      var innerChild = this.diagram.nameTable[newObj.children[j]];\n\n      if (innerChild.children) {\n        this.selectGroup(innerChild);\n      }\n\n      this.unSelect(this.diagram.nameTable[newObj.children[j]]);\n    }\n  };\n\n  CommandHandler.prototype.selectBpmnSubProcesses = function (node) {\n    var select = true;\n    var parent;\n\n    if (node.processId) {\n      if (isSelected(this.diagram, this.diagram.nameTable[node.processId])) {\n        select = false;\n      } else {\n        select = this.selectBpmnSubProcesses(this.diagram.nameTable[node.processId]);\n      }\n    } else if (node instanceof Connector) {\n      if (node.sourceID && this.diagram.nameTable[node.sourceID] && this.diagram.nameTable[node.sourceID].processId) {\n        parent = this.diagram.nameTable[node.sourceID].processId;\n      }\n\n      if (node.targetID && this.diagram.nameTable[node.targetID] && this.diagram.nameTable[node.targetID].processId) {\n        parent = this.diagram.nameTable[node.targetID].processId;\n      }\n\n      if (parent) {\n        if (isSelected(this.diagram, this.diagram.nameTable[parent])) {\n          return false;\n        } else {\n          select = this.selectBpmnSubProcesses(this.diagram.nameTable[parent]);\n        }\n      }\n    } else if (node.parentId && this.diagram.nameTable[node.parentId] && this.diagram.nameTable[node.parentId].shape.type === 'UmlClassifier') {\n      if (isSelected(this.diagram, this.diagram.nameTable[node.parentId])) {\n        select = false;\n      }\n    }\n\n    return select;\n  };\n\n  CommandHandler.prototype.hasProcesses = function (node) {\n    if (node) {\n      if (node.shape.type === 'Bpmn' && node.shape.activity && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length > 0) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * select method\\\n   *\n   * @returns { void }    select method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n   * @param {boolean} multipleSelection - provide the objects value.\n   * @param {boolean} preventUpdate - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.select = function (obj, multipleSelection, preventUpdate) {\n    var hasLayer = this.getObjectLayer(obj.id);\n\n    if (canSelect(obj) && !(obj instanceof Selector) && !isSelected(this.diagram, obj) && hasLayer && !hasLayer.lock && hasLayer.visible && obj.wrapper.visible) {\n      multipleSelection = hasSelection(this.diagram) ? multipleSelection : false;\n\n      if (!multipleSelection) {\n        this.clearSelection();\n      }\n\n      this.diagram.enableServerDataBinding(false);\n      var selectorModel = this.diagram.selectedItems;\n      var convert = obj;\n\n      if (convert instanceof Node) {\n        if (obj.isHeader) {\n          var node = this.diagram.nameTable[obj.parentId];\n          selectorModel.nodes.push(node);\n        } else {\n          selectorModel.nodes.push(obj);\n        }\n      } else {\n        selectorModel.connectors.push(obj);\n      }\n\n      if (!multipleSelection) {\n        selectorModel.init(this.diagram);\n\n        if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n          var wrapper = gridSelection(this.diagram, selectorModel);\n\n          if (wrapper) {\n            selectorModel.wrapper.children[0] = wrapper;\n          }\n\n          selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n          selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n          selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n        }\n      } else {\n        selectorModel.wrapper.rotateAngle = selectorModel.rotateAngle = 0;\n        selectorModel.wrapper.children.push(obj.wrapper);\n      }\n\n      if (!preventUpdate) {\n        this.diagram.renderSelector(multipleSelection);\n      }\n\n      this.diagram.enableServerDataBinding(true);\n    }\n  };\n\n  CommandHandler.prototype.getObjectCollectionId = function (isNode, clearSelection) {\n    var id = [];\n    var i = 0;\n    var selectedObject = isNode ? this.diagram.selectedItems.nodes : this.diagram.selectedItems.connectors;\n\n    while (!clearSelection && i < selectedObject.length) {\n      id[i] = selectedObject[i].id;\n      i++;\n    }\n\n    return id;\n  };\n\n  CommandHandler.prototype.updateBlazorSelectorModel = function (oldItemsCollection, clearSelection) {\n    var blazorInterop = 'sfBlazor';\n\n    if (window && window[blazorInterop]) {\n      var i = 0;\n      var nodes = [];\n      var connectors = [];\n      var oldItems = [];\n\n      while (oldItemsCollection && i < oldItemsCollection.length) {\n        oldItems[i] = oldItemsCollection[i].id;\n        i++;\n      }\n\n      i = 0;\n      nodes = this.getObjectCollectionId(true, clearSelection);\n      connectors = this.getObjectCollectionId(false, clearSelection);\n      var items = {\n        nodes: nodes,\n        connectors: connectors\n      };\n      var newItems = cloneBlazorObject(items);\n\n      if (window[blazorInterop].updateDiagramCollection) {\n        window[blazorInterop].updateDiagramCollection.call(this.diagram, 'selectedItems', newItems, oldItems, false, true);\n      }\n    }\n  };\n  /**\n   * labelSelect method\\\n   *\n   * @returns { void }    labelSelect method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n   * @param {DiagramElement} textWrapper - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.labelSelect = function (obj, textWrapper) {\n    this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n    var selectorModel = this.diagram.selectedItems;\n    var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n    this.diagram.allowServerDataBinding = false;\n    selectorModel.nodes = selectorModel.connectors = [];\n    this.diagram.allowServerDataBinding = isEnableServerDatabind;\n\n    if (obj instanceof Node) {\n      selectorModel.nodes[0] = obj;\n    } else {\n      selectorModel.connectors[0] = obj;\n    }\n\n    selectorModel.annotation = this.findTarget(textWrapper, obj);\n    selectorModel.init(this.diagram);\n    this.diagram.renderSelector(false);\n    this.updateBlazorSelector();\n  };\n  /**\n   * unSelect method\\\n   *\n   * @returns { void }    unSelect method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.unSelect = function (obj) {\n    var objArray = [];\n    objArray.push(obj);\n    var arg = {\n      oldValue: objArray,\n      newValue: [],\n      cause: this.diagram.diagramActions,\n      state: 'Changing',\n      type: 'Removal',\n      cancel: false\n    };\n\n    if (!this.diagram.currentSymbol) {\n      if (!isBlazor()) {\n        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n      }\n    }\n\n    if (isSelected(this.diagram, obj)) {\n      var selectormodel = this.diagram.selectedItems;\n      var index = void 0;\n\n      if (obj instanceof Node) {\n        index = selectormodel.nodes.indexOf(obj, 0);\n        selectormodel.nodes.splice(index, 1);\n      } else {\n        index = selectormodel.connectors.indexOf(obj, 0);\n        selectormodel.connectors.splice(index, 1);\n      }\n\n      arg = {\n        oldValue: objArray,\n        newValue: [],\n        cause: this.diagram.diagramActions,\n        state: 'Changed',\n        type: 'Removal',\n        cancel: false\n      };\n      this.updateBlazorSelectorModel(objArray);\n      arg = {\n        oldValue: cloneBlazorObject(objArray),\n        newValue: [],\n        cause: this.diagram.diagramActions,\n        state: 'Changed',\n        type: 'Removal',\n        cancel: arg.cancel\n      };\n\n      if (!arg.cancel) {\n        index = selectormodel.wrapper.children.indexOf(obj.wrapper, 0);\n        selectormodel.wrapper.children.splice(index, 1);\n        this.diagram.updateSelector();\n\n        if (!this.diagram.currentSymbol) {\n          if (isBlazor()) {\n            arg = this.updateSelectionChangeEventArgs(arg, [], objArray);\n            this.updateBlazorSelector();\n\n            if (window && window[this.blazor] && this.diagram.selectionChange) {\n              var eventObj = {\n                'EventName': 'selectionChange',\n                args: JSON.stringify(arg)\n              };\n              window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram);\n            }\n          } else {\n            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n          }\n        }\n      }\n    }\n  };\n  /**\n   * getChildElements method\\\n   *\n   * @returns { string[] }    getChildElements method .\\\n   * @param {DiagramElement[]} child - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.getChildElements = function (child) {\n    var children = [];\n\n    for (var i = 0; i < child.length; i++) {\n      var childNode = child[i];\n\n      if (childNode.children && childNode.children.length > 0) {\n        children.concat(this.getChildElements(childNode.children));\n      } else {\n        children.push(childNode.id);\n\n        if (childNode instanceof TextElement) {\n          children.push(childNode.id + '_text');\n        }\n      }\n    }\n\n    return children;\n  };\n  /**\n   * moveSvgNode method\\\n   *\n   * @returns { void }    moveSvgNode method .\\\n   * @param {string} nodeId - provide the objects value.\n   * @param {string} targetID - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.moveSvgNode = function (nodeId, targetID) {\n    var diagramDiv = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n    var backNode = getDiagramElement(nodeId + '_groupElement', this.diagram.element.id);\n    diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n  };\n  /**\n   * sendLayerBackward method\\\n   *\n   * @returns { void }    sendLayerBackward method .\\\n   * @param {string} layerName - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendLayerBackward = function (layerName) {\n    var layer = this.getLayer(layerName);\n\n    if (layer && layer.zIndex !== 0) {\n      var index = layer.zIndex;\n\n      if (this.diagram.mode === 'SVG') {\n        var currentLayerObject = layer.objects;\n        var targetObject = this.getLayer(this.diagram.layerZIndexTable[index - 1]).objects[0];\n\n        if (targetObject) {\n          for (var _i = 0, currentLayerObject_1 = currentLayerObject; _i < currentLayerObject_1.length; _i++) {\n            var obj = currentLayerObject_1[_i];\n            this.moveSvgNode(obj, targetObject);\n          }\n        }\n      }\n\n      var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index - 1]);\n      targetLayer.zIndex = targetLayer.zIndex + 1;\n      layer.zIndex = layer.zIndex - 1;\n      var temp = this.diagram.layerZIndexTable[index];\n      this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index - 1];\n      this.diagram.layerZIndexTable[index - 1] = temp;\n\n      if (this.diagram.mode === 'Canvas') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * bringLayerForward method\\\n   *\n   * @returns { void }    bringLayerForward method .\\\n   * @param {string} layerName - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.bringLayerForward = function (layerName) {\n    var layer = this.getLayer(layerName);\n\n    if (layer && layer.zIndex < this.diagram.layers.length - 1) {\n      var index = layer.zIndex;\n      var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index + 1]);\n\n      if (this.diagram.mode === 'SVG') {\n        var currentLayerObject = layer.objects[0];\n        var targetLayerObjects = targetLayer.objects;\n\n        for (var _i = 0, targetLayerObjects_1 = targetLayerObjects; _i < targetLayerObjects_1.length; _i++) {\n          var obj = targetLayerObjects_1[_i];\n\n          if (obj) {\n            this.moveSvgNode(obj, currentLayerObject);\n          }\n        }\n      }\n\n      targetLayer.zIndex = targetLayer.zIndex - 1;\n      layer.zIndex = layer.zIndex + 1;\n      var temp = this.diagram.layerZIndexTable[index];\n      this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index + 1];\n      this.diagram.layerZIndexTable[index + 1] = temp;\n\n      if (this.diagram.mode === 'Canvas') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * sendToBack method\\\n   *\n   * @returns { void }    sendToBack method .\\\n   * @param {NodeModel | ConnectorModel} object - provide the objects value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendToBack = function (object) {\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || object) {\n      var objectId = object && object.id;\n      objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var index = this.diagram.nameTable[objectId].zIndex;\n      var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n      var zIndexTable = this.diagram.layers[layerNum].zIndexTable;\n      var undoObject = cloneObject(this.diagram.selectedItems); //Checks whether the selected node is the only node in the node array.\n      //Checks whether it is not a group and the nodes behind it are not it’s children.\n\n      if (this.diagram.nodes.length !== 1 && (this.diagram.nameTable[objectId].children === undefined || this.checkObjectBehind(objectId, zIndexTable, index))) {\n        for (var i = index; i > 0; i--) {\n          if (zIndexTable[i]) {\n            //When there are empty records in the zindex table\n            if (!zIndexTable[i - 1]) {\n              zIndexTable[i - 1] = zIndexTable[i];\n              this.diagram.nameTable[zIndexTable[i - 1]].zIndex = i;\n              delete zIndexTable[i];\n            } else {\n              //bringing the objects forward\n              zIndexTable[i] = zIndexTable[i - 1];\n              this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n            }\n          }\n        }\n\n        zIndexTable[0] = this.diagram.nameTable[objectId].id;\n        this.diagram.nameTable[objectId].zIndex = 0;\n\n        if (this.diagram.mode === 'SVG') {\n          var i = 1;\n          var target = zIndexTable[i]; // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.\n\n          while (!target && i < index) {\n            target = zIndexTable[++i];\n          } // EJ2-46656 - CR issue fix\n\n\n          target = this.resetTargetNode(objectId, target, i, zIndexTable);\n          target = this.diagram.nameTable[target].parentId ? this.checkParentExist(target) : target;\n          this.moveSvgNode(objectId, target);\n          this.updateNativeNodeIndex(objectId);\n        } else {\n          this.diagram.refreshCanvasLayers();\n        }\n\n        var redoObject = cloneObject(this.diagram.selectedItems);\n        var entry = {\n          type: 'SendToBack',\n          category: 'Internal',\n          undoObject: undoObject,\n          redoObject: redoObject\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(entry);\n        }\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n\n    if (isBlazor()) {\n      this.getZIndexObjects();\n    }\n  };\n\n  CommandHandler.prototype.resetTargetNode = function (objectId, target, i, zIndexTable) {\n    if (this.diagram.nameTable[objectId].shape.type === 'SwimLane' && this.diagram.nameTable[target].parentId != undefined && this.diagram.nameTable[target].parentId != \"\" && this.diagram.nameTable[this.diagram.nameTable[target].parentId].isLane) {\n      i = i + 1;\n      target = zIndexTable[i];\n      return target = this.resetTargetNode(objectId, target, i, zIndexTable);\n    } else {\n      return target;\n    }\n  };\n\n  CommandHandler.prototype.getZIndexObjects = function () {\n    var element = [];\n    var i;\n    var j;\n\n    for (i = 0; i < this.diagram.nodes.length; i++) {\n      element.push(this.diagram.nodes[i]);\n    }\n\n    for (j = 0; j < this.diagram.connectors.length; j++) {\n      element.push(this.diagram.connectors[j]);\n    }\n\n    this.updateBlazorZIndex(element);\n  };\n\n  CommandHandler.prototype.updateBlazorZIndex = function (element) {\n    var blazorInterop = 'sfBlazor';\n    var blazor = 'Blazor';\n    var diagramobject = {};\n    var nodeObject = [];\n    var connectorObject = [];\n    var k;\n\n    if (element && element.length > 0) {\n      for (k = 0; k < element.length; k++) {\n        var elementObject = element[k];\n\n        if (elementObject instanceof Node) {\n          nodeObject.push(this.getBlazorObject(elementObject));\n        } else if (elementObject instanceof Connector) {\n          connectorObject.push(this.getBlazorObject(elementObject));\n        }\n      }\n    }\n\n    diagramobject = {\n      nodes: nodeObject,\n      connectors: connectorObject\n    };\n\n    if (window && window[blazor]) {\n      var obj = {\n        'methodName': 'UpdateBlazorProperties',\n        'diagramobj': diagramobject\n      };\n      window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n    }\n  };\n\n  CommandHandler.prototype.getBlazorObject = function (objectName) {\n    var object = {\n      sfIndex: getIndex(this.diagram, objectName.id),\n      zIndex: objectName.zIndex\n    };\n    return object;\n  }; //Checks whether the target is a child node.\n\n\n  CommandHandler.prototype.checkParentExist = function (target) {\n    var objBehind = target;\n\n    while (this.diagram.nameTable[objBehind].parentId) {\n      objBehind = this.diagram.nameTable[objBehind].parentId;\n    }\n\n    return objBehind;\n  }; //Checks whether the selected node is not a parent of another node.\n\n\n  CommandHandler.prototype.checkObjectBehind = function (objectId, zIndexTable, index) {\n    for (var i = 0; i < index; i++) {\n      var z = zIndexTable[i];\n\n      if (objectId !== this.diagram.nameTable[z].parentId) {\n        return true;\n      }\n    }\n\n    return false;\n  };\n  /**\n   * bringToFront method\\\n   *\n   * @returns {  void  }    bringToFront method .\\\n   *  @param {NodeModel | ConnectorModel } obj - Provide the nodeArray element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.bringToFront = function (obj) {\n    var _this = this;\n\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || obj) {\n      var objectName_1 = obj && obj.id;\n      objectName_1 = objectName_1 || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectName_1));\n      var zIndexTable_1 = this.diagram.layers[layerNum].zIndexTable;\n      var undoObject = cloneObject(this.diagram.selectedItems); //find the maximum zIndex of the tabel\n\n      var tabelLength = Number(Object.keys(zIndexTable_1).sort(function (a, b) {\n        return Number(a) - Number(b);\n      }).reverse()[0]);\n      var index = this.diagram.nameTable[objectName_1].zIndex;\n      var oldzIndexTable_1 = [];\n\n      for (var i = 0; i <= tabelLength; i++) {\n        oldzIndexTable_1.push(zIndexTable_1[i]);\n      }\n\n      for (var i = index; i < tabelLength; i++) {\n        //When there are empty records in the zindex table\n        if (zIndexTable_1[i]) {\n          if (!zIndexTable_1[i + 1]) {\n            zIndexTable_1[i + 1] = zIndexTable_1[i];\n            this.diagram.nameTable[zIndexTable_1[i + 1]].zIndex = i;\n            delete zIndexTable_1[i];\n          } else {\n            //bringing the objects backward\n            zIndexTable_1[i] = zIndexTable_1[i + 1];\n            this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n          }\n        }\n      }\n\n      zIndexTable_1[tabelLength] = this.diagram.nameTable[objectName_1].id;\n      this.diagram.nameTable[objectName_1].zIndex = tabelLength;\n\n      if (this.diagram.mode === 'SVG') {\n        var diagramLayer = this.diagram.diagramLayer; //const child: string[] = this.getChildElements(this.diagram.nameTable[objectName].wrapper.children);\n        //const targerNodes: Object = [];\n\n        var element = getDiagramElement(objectName_1 + '_groupElement', this.diagram.element.id);\n        var nodes = this.diagram.selectedItems.nodes;\n\n        if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {\n          element.parentNode.removeChild(element);\n\n          for (var j = 0; j < this.diagram.views.length; j++) {\n            element = getDiagramElement(objectName_1 + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'), this.diagram.views[j]);\n            var lastChildNode = element.parentNode.lastChild;\n            lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);\n          }\n\n          var htmlLayer = getHTMLLayer(this.diagram.element.id);\n          this.diagram.diagramRenderer.renderElement(this.diagram.nameTable[objectName_1].wrapper, diagramLayer, htmlLayer);\n        } else {\n          Object.keys(zIndexTable_1).forEach(function (key) {\n            var zIndexValue = zIndexTable_1[key];\n\n            if (zIndexValue !== objectName_1 && _this.diagram.nameTable[zIndexValue].parentId !== objectName_1) {\n              //EJ2-42101 - SendToBack and BringToFront not working for connector with group node\n              //Added @Dheepshiva to restrict the objects with lower zIndex\n              if (zIndexValue !== undefined && oldzIndexTable_1.indexOf(objectName_1) < oldzIndexTable_1.indexOf(zIndexValue)) {\n                var objectNode = _this.diagram.nameTable[objectName_1];\n                var zIndexNode = _this.diagram.nameTable[zIndexValue];\n\n                if (objectNode.parentId === '' && zIndexNode.parentId === '' && zIndexNode.parentId === undefined && objectNode.parentId !== zIndexNode.id) {\n                  _this.moveSvgNode(zIndexValue, objectName_1);\n\n                  _this.updateNativeNodeIndex(objectName_1);\n                } else {\n                  if (_this.checkGroupNode(objectName_1, zIndexValue, _this.diagram.nameTable)) {\n                    _this.moveSvgNode(zIndexValue, objectName_1);\n\n                    _this.updateNativeNodeIndex(objectName_1);\n                  }\n                }\n              }\n            }\n          });\n        }\n      } else {\n        this.diagram.refreshCanvasLayers();\n      }\n\n      var redoObject = cloneObject(this.diagram.selectedItems);\n      var entry = {\n        type: 'BringToFront',\n        category: 'Internal',\n        undoObject: undoObject,\n        redoObject: redoObject\n      };\n\n      if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n        this.addHistoryEntry(entry);\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n\n    if (isBlazor()) {\n      this.getZIndexObjects();\n    }\n  };\n\n  CommandHandler.prototype.checkGroupNode = function (selectedNodeName, layerObject, nameTable) {\n    return nameTable[layerObject].parentId === nameTable[selectedNodeName].parentId;\n  };\n  /**\n   * sortByZIndex method\\\n   *\n   * @returns {  Object[] }    sortByZIndex method .\\\n   *  @param { Object[] } nodeArray - Provide the nodeArray element .\n   *  @param { string } sortID - Provide the sortID element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.sortByZIndex = function (nodeArray, sortID) {\n    var id = sortID ? sortID : 'zIndex';\n    nodeArray = nodeArray.sort(function (a, b) {\n      return a[id] - b[id];\n    });\n    return nodeArray;\n  };\n  /**\n   * orderCommands method\\\n   *\n   * @returns {  void }    orderCommands method .\\\n   *  @param { boolean } isRedo - Provide the previousObject element .\n   *  @param { Selector } selector - Provide the previousObject element .\n   *  @param { EntryType } action - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.orderCommands = function (isRedo, selector, action) {\n    var selectedObject = selector.nodes;\n    selectedObject = selectedObject.concat(selector.connectors);\n\n    if (isRedo) {\n      if (action === 'SendBackward') {\n        this.sendBackward(selectedObject[0]);\n      } else if (action === 'SendForward') {\n        this.sendForward(selectedObject[0]);\n      } else if (action === 'BringToFront') {\n        this.bringToFront(selectedObject[0]);\n      } else if (action === 'SendToBack') {\n        this.sendToBack(selectedObject[0]);\n      }\n    } else {\n      var startZIndex = selectedObject[0].zIndex;\n      var endZIndex = this.diagram.nameTable[selectedObject[0].id].zIndex;\n      var undoObject = selectedObject[0];\n      var layer = this.getObjectLayer(undoObject.id);\n      var layerIndex = layer.zIndex;\n      var zIndexTable = layer.zIndexTable;\n\n      if (action === 'SendBackward' || action === 'SendForward') {\n        for (var i = 0; i < selectedObject.length; i++) {\n          var undoObject_1 = selectedObject[i];\n          var layer_2 = this.diagram.layers.indexOf(this.getObjectLayer(undoObject_1.id));\n          var node = this.diagram.nameTable[selectedObject[i].id];\n          node.zIndex = undoObject_1.zIndex;\n          this.diagram.layers[layer_2].zIndexTable[undoObject_1.zIndex] = undoObject_1.id;\n        }\n      } else if (action === 'BringToFront') {\n        var k = 1;\n\n        for (var j = endZIndex; j > startZIndex; j--) {\n          if (zIndexTable[j]) {\n            if (!zIndexTable[j - k]) {\n              zIndexTable[j - k] = zIndexTable[j];\n              this.diagram.nameTable[zIndexTable[j - k]].zIndex = j;\n              delete zIndexTable[j];\n            } else {\n              zIndexTable[j] = zIndexTable[j - k];\n              this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n            }\n          }\n        }\n      } else if (action === 'SendToBack') {\n        for (var j = endZIndex; j < startZIndex; j++) {\n          if (zIndexTable[j]) {\n            if (!zIndexTable[j + 1]) {\n              zIndexTable[j + 1] = zIndexTable[j];\n              this.diagram.nameTable[zIndexTable[j + 1]].zIndex = j;\n              delete zIndexTable[j];\n            } else {\n              zIndexTable[j] = zIndexTable[j + 1];\n              this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n            }\n          }\n        }\n      }\n\n      if (action === 'BringToFront' || action === 'SendToBack') {\n        var node = this.diagram.nameTable[selectedObject[0].id];\n        node.zIndex = undoObject.zIndex;\n        this.diagram.layers[layerIndex].zIndexTable[undoObject.zIndex] = undoObject.id;\n      }\n\n      if (this.diagram.mode === 'SVG') {\n        if (action === 'SendBackward') {\n          this.moveObject(selectedObject[1].id, selectedObject[0].id);\n        } else if (action === 'SendForward') {\n          this.moveObject(selectedObject[0].id, selectedObject[1].id);\n        } else if (action === 'BringToFront') {\n          this.moveObject(selectedObject[0].id, zIndexTable[selectedObject[0].zIndex + 1]);\n        } else if (action === 'SendToBack') {\n          var layer_3 = this.getObjectLayer(selectedObject[0].id);\n\n          for (var i = 0; i <= selectedObject[0].zIndex; i++) {\n            if (layer_3.objects[i] !== selectedObject[0].id) {\n              this.moveSvgNode(layer_3.objects[i], selectedObject[0].id);\n              this.updateNativeNodeIndex(selectedObject[0].id);\n            }\n          }\n        }\n      } else {\n        this.diagram.refreshCanvasLayers();\n      }\n    }\n  };\n\n  CommandHandler.prototype.moveObject = function (sourceId, targetId) {\n    if (targetId) {\n      this.moveSvgNode(sourceId, targetId);\n      this.updateNativeNodeIndex(sourceId, targetId);\n    }\n  };\n  /**\n   * sendForward method\\\n   *\n   * @returns {  void }    sendForward method .\\\n   *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendForward = function (obj) {\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || obj) {\n      var nodeId = obj && obj.id;\n      nodeId = nodeId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var layerIndex = this.diagram.layers.indexOf(this.getObjectLayer(nodeId));\n      var zIndexTable = this.diagram.layers[layerIndex].zIndexTable; //const tabelLength: number = Object.keys(zIndexTable).length;\n\n      var index = this.diagram.nameTable[nodeId];\n      var intersectArray = [];\n      var temp = this.diagram.spatialSearch.findObjects(index.wrapper.bounds);\n\n      if (temp.length > 2) {\n        temp = this.sortByZIndex(temp);\n      }\n\n      for (var _i = 0, temp_1 = temp; _i < temp_1.length; _i++) {\n        var i = temp_1[_i];\n\n        if (index.id !== i.id) {\n          var currentLayer = this.getObjectLayer(i.id).zIndex;\n\n          if (layerIndex === currentLayer && Number(this.diagram.nameTable[nodeId].zIndex) < Number(i.zIndex) && index.wrapper.bounds.intersects(i.wrapper.bounds)) {\n            intersectArray.push(i);\n            break;\n          }\n        }\n      }\n\n      if (intersectArray.length > 0) {\n        var overlapObject = intersectArray[0].zIndex;\n        var currentObject = index.zIndex;\n        var temp_2 = zIndexTable[overlapObject]; //swap the nodes\n\n        var undoObject = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n        this.diagram.nameTable[temp_2] instanceof Node ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) : undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n        this.diagram.layers[0].zIndexTable[overlapObject] = index.id;\n        this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n        this.diagram.layers[0].zIndexTable[currentObject] = intersectArray[0].id;\n        this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n\n        if (this.diagram.mode === 'SVG') {\n          this.moveSvgNode(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n          this.updateNativeNodeIndex(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n        } else {\n          this.diagram.refreshCanvasLayers();\n        }\n\n        var redo = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line\n\n        this.diagram.nameTable[temp_2] instanceof Node ? redo.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) : redo.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n        var historyEntry = {\n          type: 'SendForward',\n          category: 'Internal',\n          undoObject: undoObject,\n          redoObject: redo\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(historyEntry);\n        }\n      }\n\n      if (isBlazor()) {\n        var elements = [];\n        elements.push(index);\n        elements.push(intersectArray[intersectArray.length - 1]);\n        this.updateBlazorZIndex(elements);\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n  };\n  /**\n   * sendBackward method\\\n   *\n   * @returns {  void }    sendBackward method .\\\n   *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.sendBackward = function (obj) {\n    this.diagram.protectPropertyChange(true);\n\n    if (hasSelection(this.diagram) || obj) {\n      var objectId = obj && obj.id;\n      objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id : this.diagram.selectedItems.connectors[0].id);\n      var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n      var zIndexTable = this.diagram.layers[layerNum].zIndexTable; //const tabelLength: number = Object.keys(zIndexTable).length;\n\n      var node = this.diagram.nameTable[objectId];\n      var intersectArray = [];\n      var temp = this.diagram.spatialSearch.findObjects(node.wrapper.bounds);\n\n      if (temp.length > 2) {\n        temp = this.sortByZIndex(temp);\n      }\n\n      for (var _i = 0, temp_3 = temp; _i < temp_3.length; _i++) {\n        var i = temp_3[_i];\n\n        if (node.id !== i.id) {\n          var currentLayer = this.getObjectLayer(i.id).zIndex;\n\n          if (layerNum === currentLayer && Number(this.diagram.nameTable[objectId].zIndex) > Number(i.zIndex) && node.wrapper.bounds.intersects(i.wrapper.bounds)) {\n            intersectArray.push(i);\n          }\n        }\n      }\n\n      if (intersectArray.length > 0) {\n        var overlapObject = intersectArray[intersectArray.length - 1].zIndex;\n        var currentObject = node.zIndex;\n        var temp_4 = zIndexTable[overlapObject];\n        var undoObject = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line\n\n        this.diagram.nameTable[temp_4] instanceof Node ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) : undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4])); //swap the nodes\n\n        zIndexTable[overlapObject] = node.id;\n        this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n        zIndexTable[currentObject] = intersectArray[intersectArray.length - 1].id;\n        this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n\n        if (this.diagram.mode === 'SVG') {\n          if (!(node.children && node.children.length > 0)) {\n            var tempChild = zIndexTable[intersectArray[intersectArray.length - 1].zIndex];\n\n            if (intersectArray[intersectArray.length - 1].children && intersectArray[intersectArray.length - 1].children.length !== 0) {\n              var tempParent = intersectArray[intersectArray.length - 1];\n              tempChild = tempParent.children[0];\n            }\n\n            var checkChild = this.diagram.getObject(tempChild);\n\n            if (checkChild.children && checkChild.children.length !== 0) {\n              tempChild = checkChild.children[0];\n            }\n\n            this.moveSvgNode(objectId, tempChild);\n            this.updateNativeNodeIndex(objectId, tempChild);\n\n            if (isBlazor()) {\n              var elements = [];\n              elements.push(node);\n              elements.push(intersectArray[intersectArray.length - 1]);\n              this.updateBlazorZIndex(elements);\n            }\n          }\n        } else {\n          this.diagram.refreshCanvasLayers();\n        }\n\n        var redoObject = cloneObject(this.diagram.selectedItems); // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n\n        this.diagram.nameTable[temp_4] instanceof Node ? redoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) : redoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4]));\n        var entry = {\n          type: 'SendBackward',\n          category: 'Internal',\n          undoObject: undoObject,\n          redoObject: redoObject\n        };\n\n        if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n          this.addHistoryEntry(entry);\n        } //swap the nodes\n\n      }\n    }\n\n    this.diagram.protectPropertyChange(false);\n  };\n  /**\n   * updateNativeNodeIndex method\\\n   *\n   * @returns {  void }    updateNativeNodeIndex method .\\\n   *  @param { string } nodeId - Provide the previousObject element .\n   *  @param { string } targetID - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateNativeNodeIndex = function (nodeId, targetID) {\n    var node = this.diagram.selectedItems.nodes[0] || this.diagram.getObject(targetID);\n\n    for (var i = 0; i < this.diagram.views.length; i++) {\n      if (node && (node.shape.type === 'HTML' || node.shape.type === 'Native')) {\n        var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';\n        var backNode = getDiagramElement(nodeId + id, this.diagram.views[i]);\n        var diagramDiv = targetID ? getDiagramElement(targetID + id, this.diagram.views[i]) : backNode.parentElement.firstChild;\n\n        if (backNode.parentNode.id === diagramDiv.parentNode.id) {\n          diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n        }\n      }\n    }\n  };\n  /**\n   * initSelectorWrapper method\\\n   *\n   * @returns {  void }    initSelectorWrapper method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.initSelectorWrapper = function () {\n    var selectorModel = this.diagram.selectedItems;\n    selectorModel.init(this.diagram);\n\n    if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n      selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n      selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n      selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n    }\n  };\n  /**\n   * doRubberBandSelection method\\\n   *\n   * @returns {  void }    doRubberBandSelection method .\\\n   *  @param { Rect } region - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.doRubberBandSelection = function (region) {\n    this.clearSelectionRectangle();\n    var selArray = [];\n    var rubberArray = [];\n    selArray = this.diagram.getNodesConnectors(selArray);\n\n    if (this.diagram.selectedItems.rubberBandSelectionMode === 'CompleteIntersect') {\n      rubberArray = completeRegion(region, selArray);\n    } else {\n      rubberArray = this.diagram.spatialSearch.findObjects(region);\n    }\n\n    if (rubberArray.length) {\n      this.selectObjects(rubberArray, true);\n    }\n  };\n\n  CommandHandler.prototype.clearSelectionRectangle = function () {\n    var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n    var element = adornerSvg.getElementById(this.diagram.element.id + '_diagramAdorner_selected_region');\n\n    if (element) {\n      remove(element);\n    }\n  };\n  /**\n   * dragConnectorEnds method\\\n   *\n   * @returns {  void }    dragConnectorEnds method .\\\n   *  @param { string } endPoint - Provide the previousObject element .\n   *  @param { IElement } obj - Provide the previousObject element .\n   *  @param { PointModel } point - Provide the point element .\n   *  @param { BezierSegmentModel } segment - Provide the segment element .\n   *  @param { IElement } target - Provide the target element .\n   *  @param { string } targetPortId - Provide the targetPortId element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragConnectorEnds = function (endPoint, obj, point, segment, target, targetPortId) {\n    var selectorModel;\n    var connector; //let node: Node;\n\n    var tx; //let segmentPoint: PointModel;\n\n    var ty; //let index: number;\n\n    var checkBezierThumb = false;\n\n    if (obj instanceof Selector) {\n      selectorModel = obj;\n      connector = selectorModel.connectors[0];\n    } else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n      this.clearSelection();\n      connector = this.diagram.currentDrawingObject;\n    }\n\n    if (endPoint === 'BezierSourceThumb' || endPoint === 'BezierTargetThumb') {\n      checkBezierThumb = true;\n    }\n\n    if (endPoint === 'ConnectorSourceEnd' || endPoint === 'BezierSourceThumb') {\n      tx = point.x - (checkBezierThumb ? segment.bezierPoint1.x : connector.sourcePoint.x);\n      ty = point.y - (checkBezierThumb ? segment.bezierPoint1.y : connector.sourcePoint.y);\n      return this.dragSourceEnd(connector, tx, ty, null, point, endPoint, undefined, target, targetPortId, undefined, segment);\n    } else {\n      tx = point.x - (checkBezierThumb ? segment.bezierPoint2.x : connector.targetPoint.x);\n      ty = point.y - (checkBezierThumb ? segment.bezierPoint2.y : connector.targetPoint.y);\n      return this.dragTargetEnd(connector, tx, ty, null, point, endPoint, undefined, segment);\n    }\n  };\n  /**\n   * getSelectedObject method\\\n   *\n   * @returns {  void }    getSelectedObject method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.getSelectedObject = function () {\n    var selectormodel = this.diagram.selectedItems;\n    return selectormodel.nodes.concat(selectormodel.connectors);\n  };\n  /**\n   * updateBlazorProperties method\\\n   *\n   * @returns {  void }    updateBlazorProperties method .\\\n   *  @param { boolean } isObjectInteraction - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateBlazorProperties = function (isObjectInteraction) {\n    var blazorInterop = 'sfBlazor';\n    var blazor = 'Blazor';\n\n    if (!isObjectInteraction) {\n      if (window && window[blazor]) {\n        var obj = {\n          'methodName': 'UpdateBlazorProperties',\n          'diagramobj': this.diagramObject\n        };\n        window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n      }\n    } else {\n      if (window && window[blazor] && JSON.stringify(this.deepDiffer.diagramObject) !== '{}') {\n        var obj = {\n          'methodName': 'UpdateBlazorProperties',\n          'diagramobj': this.deepDiffer.diagramObject\n        };\n\n        if (!this.diagram.isLoading) {\n          window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n        }\n      }\n    } //this.diagram.enableServerDataBinding(true);\n\n\n    this.deepDiffer.newNodeObject = [];\n    this.deepDiffer.newConnectorObject = [];\n    this.diagramObject = [];\n    this.diagram.oldNodeObjects = [];\n    this.diagram.oldConnectorObjects = [];\n  };\n  /**\n   * enableCloneObject method\\\n   *\n   * @returns {  void }    enableCloneObject method .\\\n   *  @param { boolean } value - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.enableCloneObject = function (value) {\n    if (!this.diagram.lineRoutingModule || !(this.diagram.constraints & DiagramConstraints.LineRouting)) {\n      this.diagram.canEnableBlazorObject = value;\n    }\n  };\n  /**\n   * ismouseEvents method\\\n   *\n   * @returns {  void }    ismouseEvents method .\\\n   *  @param { boolean } value - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.ismouseEvents = function (value) {\n    if (value) {\n      this.diagram.blazorActions = this.diagram.addConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n    } else {\n      this.diagram.blazorActions = this.diagram.removeConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n    }\n  };\n  /**\n   * updateLayerObject method\\\n   *\n   * @returns {  void }    updateLayerObject method .\\\n   *  @param { object } oldDiagram - Provide the previousObject element .\n   *  @param { boolean } temp - Provide the temp element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateLayerObject = function (oldDiagram, temp) {\n    if (isBlazor()) {\n      var diffLayers = {};\n      diffLayers = this.deepDiffer.getLayerObject(oldDiagram, temp, this.diagram);\n      this.diagramObject = diffLayers;\n      this.updateBlazorProperties();\n    }\n  };\n  /* tslint:enable:no-string-literal */\n\n  /**\n   * getDiagramOldValues method\\\n   *\n   * @returns {  void }    getDiagramOldValues method .\\\n   *  @param { object } oldDiagram - Provide the previousObject element .\n   *  @param { string[] } attribute - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.getDiagramOldValues = function (oldDiagram, attribute) {\n    var newDiagram = {};\n\n    for (var i = 0; i < attribute.length; i++) {\n      newDiagram[attribute[i]] = cloneObject(this.diagram[attribute[i]]);\n    }\n\n    var newObject = cloneObject(newDiagram);\n    var result = this.deepDiffer.map(newObject, oldDiagram);\n    var diffValue = this.deepDiffer.frameObject({}, result);\n    var diff = this.deepDiffer.removeEmptyValues(diffValue);\n    diff = this.deepDiffer.changeSegments(diff, newObject);\n    this.diagramObject = diff;\n\n    if (!(this.diagram.blazorActions & BlazorAction.ClearObject)) {\n      this.updateBlazorProperties();\n    }\n  };\n  /* tslint:disable */\n\n  /**\n   * getBlazorOldValues method\\\n   *\n   * @returns {  void }    getBlazorOldValues method .\\\n   *  @param { MouseEventArgs } args - Provide the previousObject element .\n   *  @param { boolean } labelDrag - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.getBlazorOldValues = function (args, labelDrag) {\n    if (isBlazor()) {\n      var oldNodeObject = this.diagram.oldNodeObjects;\n\n      for (var i = 0; i < oldNodeObject.length; i++) {\n        if (oldNodeObject[i].id) {\n          if (this.diagram.oldNodeObjects[i] instanceof Node) {\n            this.diagram.oldNodeObjects[i] = cloneBlazorObject(this.diagram.oldNodeObjects[i]);\n          }\n\n          this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldNodeObject[i].id], args, labelDrag, this.diagram);\n        }\n      }\n\n      var oldConnectorObject = this.diagram.oldConnectorObjects;\n\n      for (var i = 0; i < oldConnectorObject.length; i++) {\n        if (oldConnectorObject[i].id) {\n          if (this.diagram.oldConnectorObjects[i] instanceof Connector) {\n            this.diagram.oldConnectorObjects[i] = cloneBlazorObject(this.diagram.oldConnectorObjects[i]);\n          }\n\n          this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldConnectorObject[i].id], args, labelDrag, this.diagram);\n        }\n      }\n\n      if (oldNodeObject.length > 0 || oldConnectorObject.length > 0) {\n        this.updateBlazorProperties(true);\n      }\n    }\n  };\n  /**\n   * getObjectChanges method\\\n   *\n   * @returns {  void }    getObjectChanges method .\\\n   *  @param { Object[] } previousObject - Provide the previousObject element .\n   *  @param { Object[] } currentObject - Provide the previousObject element .\n   *  @param { Object[] } previousObject - Provide the previousObject element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.getObjectChanges = function (previousObject, currentObject, changedNodes) {\n    for (var i = 0; i < previousObject.length; i++) {\n      var value = this.deepDiffer.map(currentObject[i], previousObject[i]);\n      var result = this.deepDiffer.frameObject({}, value);\n      var change = this.deepDiffer.removeEmptyValues(result);\n\n      if (change.children) {\n        change.children = cloneObject(currentObject[i]).children;\n      }\n\n      change = this.deepDiffer.changeSegments(change, currentObject[i]);\n      change.sfIndex = getIndex(this.diagram, currentObject[i].id);\n      changedNodes.push(change);\n    }\n  };\n  /**\n   * clearObjectSelection method\\\n   *\n   * @returns {  void }    clearObjectSelection method .\\\n   *  @param { (NodeModel | ConnectorModel) } mouseDownElement - Provide the triggerAction element .\n   * @private\n   */\n  // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node\n\n\n  CommandHandler.prototype.clearObjectSelection = function (mouseDownElement) {\n    var selectedItems = this.diagram.selectedItems;\n    var list = [];\n    list = list.concat(selectedItems.nodes, selectedItems.connectors);\n\n    if (list.indexOf(mouseDownElement) === -1) {\n      this.clearSelection(list.length > 0 ? true : false);\n      this.selectObjects([mouseDownElement], true);\n    }\n  };\n  /**\n   * clearSelection method\\\n   *\n   * @returns {  void }    clearSelection method .\\\n   *  @param { boolean } triggerAction - Provide the triggerAction element .\n   *  @param { boolean } isTriggered - Provide the isTriggered element .\n   * @private\n   */\n\n\n  CommandHandler.prototype.clearSelection = function (triggerAction, isTriggered) {\n    return __awaiter(this, void 0, void 0, function () {\n      var enableServerDataBinding, selectormodel, arrayNodes, arg, blazarArgs, eventObj, selectNodes, i;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            enableServerDataBinding = this.diagram.allowServerDataBinding;\n            this.diagram.enableServerDataBinding(false);\n            if (!hasSelection(this.diagram)) return [3\n            /*break*/\n            , 5];\n            selectormodel = this.diagram.selectedItems;\n            arrayNodes = this.getSelectedObject();\n\n            if (this.diagram.currentSymbol) {\n              this.diagram.previousSelectedObject = arrayNodes;\n            }\n\n            arg = {\n              oldValue: arrayNodes,\n              newValue: [],\n              cause: this.diagram.diagramActions,\n              state: 'Changing',\n              type: 'Removal',\n              cancel: false\n            };\n            this.updateBlazorSelectorModel(arrayNodes, true);\n\n            if (triggerAction) {\n              if (!isBlazor()) {\n                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n              } else {\n                this.oldSelectedObjects = cloneObject(selectormodel);\n              }\n            }\n\n            if (!!arg.cancel) return [3\n            /*break*/\n            , 4];\n            selectormodel.offsetX = 0;\n            selectormodel.offsetY = 0;\n            selectormodel.width = 0;\n            selectormodel.height = 0;\n            selectormodel.rotateAngle = 0;\n            selectormodel.nodes = [];\n            selectormodel.connectors = [];\n            selectormodel.wrapper = null;\n            selectormodel.annotation = undefined;\n            this.diagram.clearSelectorLayer();\n            if (!triggerAction) return [3\n            /*break*/\n            , 4];\n            arg = {\n              oldValue: cloneBlazorObject(arrayNodes),\n              newValue: [],\n              cause: this.diagram.diagramActions,\n              state: 'Changed',\n              type: 'Removal',\n              cancel: false\n            };\n\n            if (isBlazor()) {\n              arg = this.updateSelectionChangeEventArgs(arg, [], arrayNodes);\n              this.updateBlazorSelector();\n            }\n\n            if (!!isBlazor()) return [3\n            /*break*/\n            , 1];\n            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            return [3\n            /*break*/\n            , 4];\n\n          case 1:\n            blazarArgs = void 0;\n            if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3\n            /*break*/\n            , 3];\n            eventObj = {\n              'EventName': 'selectionChange',\n              args: JSON.stringify(arg)\n            };\n            return [4\n            /*yield*/\n            , window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n\n          case 2:\n            blazarArgs = _a.sent();\n            _a.label = 3;\n\n          case 3:\n            // let blazarArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            if (blazarArgs && blazarArgs.cancel && !isTriggered) {\n              selectNodes = [];\n\n              if (blazarArgs.oldValue.nodes.length > 0) {\n                selectNodes = blazarArgs.oldValue.nodes;\n              }\n\n              if (blazarArgs.oldValue.connectors.length > 0) {\n                selectNodes = selectNodes.concat(blazarArgs.oldValue.connectors);\n              }\n\n              if (selectNodes) {\n                for (i = 0; i < selectNodes.length; i++) {\n                  this.select(this.diagram.nameTable[selectNodes[i].id], i !== 0 && selectNodes.length > 1 ? true : false);\n                }\n              }\n            }\n\n            _a.label = 4;\n\n          case 4:\n            this.updateBlazorSelector();\n            this.diagram.enableServerDataBinding(enableServerDataBinding);\n            _a.label = 5;\n\n          case 5:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n  /**\n   * clearSelectedItems method\\\n   *\n   * @returns {  void }    clearSelectedItems method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.clearSelectedItems = function () {\n    var selectedNodes = this.diagram.selectedItems.nodes ? this.diagram.selectedItems.nodes.length : 0;\n    var selectedConnectors = this.diagram.selectedItems.connectors ? this.diagram.selectedItems.connectors.length : 0;\n    this.clearSelection(selectedNodes + selectedConnectors > 0 ? true : false);\n  };\n  /**\n   * removeStackHighlighter method\\\n   *\n   * @returns {  void }    removeStackHighlighter method .\\\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeStackHighlighter = function () {\n    var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n    var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');\n\n    if (highlighter) {\n      highlighter.parentNode.removeChild(highlighter);\n    }\n  };\n  /**\n   * @param {End} args - provide the args  value.\n   * @param {IElement} target - provide the target  value.\n   * @private\n   */\n\n\n  CommandHandler.prototype.renderStackHighlighter = function (args, target) {\n    var source = this.diagram.selectedItems.nodes[0];\n    var symbolDrag;\n    var node;\n    var selectorModel;\n\n    if (!target) {\n      var objects = this.diagram.findObjectsUnderMouse(args.position);\n      target = this.diagram.findObjectUnderMouse(objects, 'Drag', true);\n\n      if (target && !(target.isLane || target.isPhase || target.isHeader)) {\n        for (var i = 0; i < objects.length; i++) {\n          var laneNode = this.diagram.nameTable[objects[i].id];\n\n          if (!laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {\n            target = laneNode;\n            this.diagram.parentObject = target;\n          }\n        }\n      }\n    }\n\n    if (source && target && target.isLane && source.shape && !source.shape.isPhase) {\n      node = this.diagram.nameTable[target.parentId];\n\n      if (this.diagram.currentSymbol && node.shape.type === 'SwimLane') {\n        symbolDrag = true;\n      }\n\n      if (source && !source.parentId && source.shape.type !== 'SwimLane' || source && source.parentId && this.diagram.nameTable[source.parentId] && this.diagram.nameTable[source.parentId].isLane && source.parentId !== target.parentId && source.parentId !== target.id) {\n        selectorModel = this.diagram.selectedItems;\n        var canvas = gridSelection(this.diagram, selectorModel, target.id, true);\n\n        if (canvas) {\n          selectorModel.wrapper.children[0] = canvas;\n        }\n\n        this.diagram.renderSelector(false, true);\n        selectorModel.wrapper.children[0] = selectorModel.nodes[0].wrapper;\n      }\n    }\n\n    if (source && target && target.parentId && source.shape && source.shape.isPhase) {\n      var node_2 = this.diagram.nameTable[target.parentId];\n\n      if (node_2.shape.type === 'SwimLane') {\n        this.diagram.selectedItems.wrapper.children[0] = this.diagram.nameTable[target.parentId].wrapper;\n        this.diagram.renderSelector(false, true);\n      }\n    }\n\n    if (symbolDrag && this.diagram.currentSymbol.shape.isLane || source && target && source.parentId && target.parentId && !source.isPhase && source.parentId === target.parentId && source.id !== target.id && node && node.container && (node.container.type === 'Stack' || node.container.type === 'Grid')) {\n      var canvas = void 0;\n      var value = node.container.orientation === 'Vertical';\n      var isVertical = node.container === 'Stack' ? value : !value;\n\n      if (node.container.type === 'Grid' && target.isLane && (!this.diagram.currentSymbol && node.shape.orientation === 'Horizontal' && target.rowIndex !== source.rowIndex || node.shape.orientation === 'Vertical' && target.columnIndex !== source.columnIndex || this.diagram.currentSymbol && this.diagram.currentSymbol.shape.orientation === node.container.orientation)) {\n        selectorModel = this.diagram.selectedItems;\n\n        if (source.isLane && canLaneInterchange(source, this.diagram) || !source.isLane) {\n          canvas = gridSelection(this.diagram, selectorModel, target.id, symbolDrag);\n        }\n      }\n\n      var wrapper = node.container.type === 'Stack' ? target.wrapper : canvas;\n\n      if (wrapper) {\n        renderStackHighlighter(wrapper, isVertical, args.position, this.diagram, false, true);\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.insertBlazorConnector = function (obj) {\n    if (obj instanceof Selector) {\n      for (var i = 0; i < obj.connectors.length; i++) {\n        this.diagram.insertBlazorConnector(obj.connectors[i]);\n      }\n    } else {\n      this.diagram.insertBlazorConnector(obj);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.drag = function (obj, tx, ty) {\n    var tempNode;\n    var elements = [];\n\n    if (canMove(obj) && this.checkBoundaryConstraints(tx, ty, obj.wrapper.bounds) && canPageEditable(this.diagram)) {\n      if (obj instanceof Node) {\n        var oldValues = {\n          offsetX: obj.offsetX,\n          offsetY: obj.offsetY\n        };\n        obj.offsetX += tx;\n        obj.offsetY += ty;\n\n        if (obj.children && !obj.container) {\n          if (!checkParentAsContainer(this.diagram, obj, true)) {\n            this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.isGroupDragging;\n          }\n\n          var nodes = this.getAllDescendants(obj, elements);\n\n          for (var i = 0; i < nodes.length; i++) {\n            tempNode = this.diagram.nameTable[nodes[i].id];\n            this.drag(tempNode, tx, ty);\n          }\n\n          this.updateInnerParentProperties(obj);\n          this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.isGroupDragging;\n        }\n\n        if (checkParentAsContainer(this.diagram, obj, true)) {\n          checkChildNodeInContainer(this.diagram, obj);\n        } else {\n          if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n            obj.wrapper.measureChildren = true;\n          }\n\n          this.diagram.nodePropertyChange(obj, oldValues, {\n            offsetX: obj.offsetX,\n            offsetY: obj.offsetY\n          }, undefined, undefined, false);\n          obj.wrapper.measureChildren = false;\n        }\n\n        if (obj.shape.type === 'SwimLane' && !this.diagram.currentSymbol) {\n          var grid = obj.wrapper.children[0];\n          var connectors = getConnectors(this.diagram, grid, 0, true);\n          updateConnectorsProperties(connectors, this.diagram);\n        }\n      } else {\n        var connector = obj;\n        var oldValues = {\n          sourcePoint: connector.sourcePoint,\n          targetPoint: connector.targetPoint\n        };\n        var update = connector.type === 'Bezier' ? true : false;\n        var hasEnds = false;\n\n        if (!connector.sourceWrapper) {\n          this.dragSourceEnd(connector, tx, ty, true, null, '', update);\n        } else {\n          hasEnds = true;\n        }\n\n        if (!connector.targetWrapper) {\n          this.dragTargetEnd(connector, tx, ty, true, null, '', update);\n        } else {\n          hasEnds = true;\n        }\n\n        var canDragPoints = false;\n\n        if (obj instanceof Connector) {\n          canDragPoints = true;\n        }\n\n        if (!hasEnds || canDragPoints) {\n          this.dragControlPoint(connector, tx, ty, true);\n          var conn = {\n            sourcePoint: connector.sourcePoint,\n            targetPoint: connector.targetPoint\n          };\n          this.diagram.connectorPropertyChange(connector, oldValues, conn);\n        }\n      }\n    }\n  };\n  /**   @private  */\n\n\n  CommandHandler.prototype.connectorSegmentChange = function (actualObject, existingInnerBounds, isRotate) {\n    var tx;\n    var ty;\n    var segmentChange = true;\n\n    if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {\n      if (actualObject.outEdges.length > 0) {\n        for (var k = 0; k < actualObject.outEdges.length; k++) {\n          var connector = this.diagram.nameTable[actualObject.outEdges[k]];\n\n          if (connector.targetID !== '') {\n            segmentChange = this.isSelected(this.diagram.nameTable[connector.targetID]) ? false : true;\n          } else {\n            segmentChange = this.isSelected(this.diagram.nameTable[connector.id]) ? false : true;\n          }\n\n          if (connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 1) {\n            if (!isRotate) {\n              if (segmentChange) {\n                switch (connector.segments[0].direction) {\n                  case 'Bottom':\n                    tx = actualObject.wrapper.bounds.bottomCenter.x - existingInnerBounds.bottomCenter.x;\n                    ty = actualObject.wrapper.bounds.bottomCenter.y - existingInnerBounds.bottomCenter.y;\n                    break;\n\n                  case 'Top':\n                    tx = actualObject.wrapper.bounds.topCenter.x - existingInnerBounds.topCenter.x;\n                    ty = actualObject.wrapper.bounds.topCenter.y - existingInnerBounds.topCenter.y;\n                    break;\n\n                  case 'Left':\n                    tx = actualObject.wrapper.bounds.middleLeft.x - existingInnerBounds.middleLeft.x;\n                    ty = actualObject.wrapper.bounds.middleLeft.y - existingInnerBounds.middleLeft.y;\n                    break;\n\n                  case 'Right':\n                    tx = actualObject.wrapper.bounds.middleRight.x - existingInnerBounds.middleRight.x;\n                    ty = actualObject.wrapper.bounds.middleRight.y - existingInnerBounds.middleRight.y;\n                    break;\n                }\n\n                this.dragSourceEnd(connector, tx, ty, true, null, 'ConnectorSourceEnd', undefined, undefined, undefined, actualObject.parentId && this.diagram.diagramActions & DiagramAction.isGroupDragging ? false : true);\n              }\n            } else {\n              var firstSegment = connector.segments[0];\n              var secondSegment = connector.segments[1];\n              var cornerPoints = swapBounds(actualObject.wrapper, actualObject.wrapper.corners, actualObject.wrapper.bounds);\n              var sourcePoint = findPoint(cornerPoints, firstSegment.direction);\n              sourcePoint = getIntersection(connector, connector.sourceWrapper, sourcePoint, {\n                x: connector.sourceWrapper.offsetX,\n                y: connector.sourceWrapper.offsetY\n              }, false);\n              var source = {\n                corners: undefined,\n                point: sourcePoint,\n                margin: undefined,\n                direction: firstSegment.direction\n              };\n              var target = {\n                corners: undefined,\n                point: secondSegment.points[1],\n                margin: undefined,\n                direction: undefined\n              };\n              var intermediatePoints = orthoConnection2Segment(source, target);\n              firstSegment.length = Point.distancePoints(intermediatePoints[0], intermediatePoints[1]);\n\n              if (secondSegment.direction && secondSegment.length) {\n                secondSegment.length = Point.distancePoints(intermediatePoints[1], intermediatePoints[2]);\n              }\n            }\n          }\n        }\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.updateEndPoint = function (connector, oldChanges) {\n    var conn = {\n      sourcePoint: connector.sourcePoint,\n      targetPoint: connector.targetPoint,\n      sourceID: connector.sourceID ? connector.sourceID : undefined,\n      targetID: connector.targetID ? connector.targetID : undefined,\n      sourcePortID: connector.sourcePortID ? connector.sourcePortID : undefined,\n      targetPortID: connector.targetPortID ? connector.targetPortID : undefined,\n      segments: connector.segments ? connector.segments : undefined\n    };\n    var newValue = {\n      sourcePoint: connector.sourcePoint,\n      targetPoint: connector.targetPoint\n    };\n\n    if (connector.sourceID) {\n      newValue.sourceID = connector.sourceID;\n    }\n\n    if (connector.targetID) {\n      newValue.targetID = connector.targetID;\n    }\n\n    if (connector.sourcePortID) {\n      newValue.sourcePortID = connector.sourcePortID;\n    }\n\n    if (connector.targetPortID) {\n      newValue.targetPortID = connector.targetPortID;\n    }\n\n    if (connector.segments) {\n      newValue.segments = connector.segments;\n    }\n\n    this.diagram.connectorPropertyChange(connector, oldChanges ? oldChanges : {}, newValue); // this.diagram.refreshDiagramLayer();\n\n    this.diagram.updateSelector();\n  };\n  /**\n   * @param obj\n   * @param tx\n   * @param ty\n   * @param preventUpdate\n   * @param point\n   * @param endPoint\n   * @param update\n   * @param target\n   * @param targetPortId\n   * @param isDragSource\n   * @param segment\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragSourceEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, target, targetPortId, isDragSource, segment) {\n    var connector = this.diagram.nameTable[obj.id];\n    var oldChanges = {};\n    var checkBoundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n\n    if (canDragSourceEnd(connector) && checkBoundaryConstraints && endPoint !== 'BezierSourceThumb' && canPageEditable(this.diagram)) {\n      oldChanges = {\n        sourcePoint: connector.sourcePoint\n      };\n      connector.sourcePoint.x += tx;\n      connector.sourcePoint.y += ty;\n\n      if (endPoint === 'ConnectorSourceEnd' && connector.type === 'Orthogonal') {\n        this.changeSegmentLength(connector, target, targetPortId, isDragSource);\n      }\n\n      if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n        this.updatePathElementOffset(connector);\n      }\n    }\n\n    if (connector.type === 'Bezier') {\n      oldChanges = {\n        sourcePoint: connector.sourcePoint\n      };\n\n      if (segment) {\n        this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorSourceEnd' : endPoint, tx, ty, segment, point, !update);\n      } else {\n        for (var i = 0; i < obj.segments.length; i++) {\n          this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorSourceEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n        }\n      }\n    }\n\n    if (!preventUpdate) {\n      this.updateEndPoint(connector, oldChanges);\n    }\n\n    if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n      this.diagram.refreshCanvasLayers();\n    }\n\n    return checkBoundaryConstraints;\n  };\n  /**\n   * Update Path Element offset\n   */\n\n\n  CommandHandler.prototype.updatePathElementOffset = function (connector) {\n    connector.wrapper.children.splice(3, 1);\n    var pathElement = new PathElement();\n    var anglePoints = connector.intermediatePoints;\n    pathElement = updatePathElement(anglePoints, connector);\n    connector.wrapper.children.splice(3, 0, pathElement);\n  };\n  /**\n   * Upadte the connector segments when change the source node\n   */\n\n\n  CommandHandler.prototype.changeSegmentLength = function (connector, target, targetPortId, isDragSource) {\n    if (connector.segments && connector.segments[0].direction !== null && (!target && connector.sourceID === '' || isDragSource)) {\n      var first = connector.segments[0];\n      var second = connector.segments[1];\n      var node = this.diagram.nameTable[connector.sourceID];\n      var secPoint = void 0;\n      first.points[0] = connector.sourcePoint;\n\n      if (first.direction === 'Top' || first.direction === 'Bottom') {\n        first.points[first.points.length - 1].x = connector.sourcePoint.x;\n        second.points[0].y = first.points[first.points.length - 1].y;\n      } else {\n        first.points[first.points.length - 1].y = connector.sourcePoint.y;\n        second.points[0].x = first.points[first.points.length - 1].x;\n      }\n\n      if (first.direction && (first.length || first.length === 0)) {\n        first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n      }\n\n      if (second.direction && (second.length || second.length === 0)) {\n        second.length = Point.distancePoints(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n        second.direction = Point.direction(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n      }\n\n      if (connector.sourcePortID !== '' && first.length < 10) {\n        if (connector.segments.length > 2) {\n          var next = connector.segments[2];\n          var nextDirection = Point.direction(next.points[0], next.points[1]);\n\n          if (first.direction === getOppositeDirection(nextDirection)) {\n            if (first.direction === 'Right') {\n              next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleRight.x + 20;\n            } else if (first.direction === 'Left') {\n              next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleLeft.x - 20;\n            } else if (first.direction === 'Top') {\n              next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.topCenter.y - 20;\n            } else {\n              next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.bottomCenter.y + 20;\n            }\n\n            if (next.direction && next.length) {\n              next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n            }\n\n            first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n          } else if (first.direction === nextDirection && next.direction && next.length) {\n            if (first.direction === 'Top' || first.direction === 'Bottom') {\n              next.points[0] = first.points[0];\n              next.points[next.points.length - 1].x = next.points[0].x;\n            } else {\n              next.points[0] = first.points[0];\n              next.points[next.points.length - 1].y = next.points[0].y;\n            }\n\n            next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n            connector.segments.splice(0, 2);\n          } else {\n            first.length = 20;\n          }\n        } else {\n          first.length = 20;\n        }\n      } else if (first.length < 1) {\n        if (connector.sourceID !== '') {\n          if (second.direction === 'Right') {\n            secPoint = node.wrapper.corners.middleRight;\n            second.points[second.points.length - 1].y = secPoint.y;\n          } else if (second.direction === 'Left') {\n            secPoint = node.wrapper.corners.middleLeft;\n            second.points[second.points.length - 1].y = secPoint.y;\n          } else if (second.direction === 'Top') {\n            secPoint = node.wrapper.corners.topCenter;\n            second.points[second.points.length - 1].x = secPoint.x;\n          } else {\n            secPoint = node.wrapper.corners.bottomCenter;\n            second.points[second.points.length - 1].x = secPoint.x;\n          }\n\n          second.length = Point.distancePoints(secPoint, second.points[second.points.length - 1]);\n\n          if (connector.segments.length > 2) {\n            var next = connector.segments[2];\n\n            if (next.direction && next.length) {\n              next.length = Point.distancePoints(second.points[second.points.length - 1], next.points[next.points.length - 1]);\n            }\n          }\n\n          connector.segments.splice(0, 1);\n        } else {\n          connector.segments.splice(0, 1);\n        }\n      }\n    } else {\n      if (target && !targetPortId && connector.sourceID !== target.id && connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n        this.changeSourceEndToNode(connector, target);\n      }\n\n      if (target && targetPortId && connector.sourcePortID !== targetPortId && connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n        this.changeSourceEndToPort(connector, target, targetPortId);\n      }\n    }\n  };\n  /**\n   * Change the connector endPoint to port\n   */\n\n\n  CommandHandler.prototype.changeSourceEndToPort = function (connector, target, targetPortId) {\n    var port = this.diagram.getWrapper(target.wrapper, targetPortId);\n    var point = {\n      x: port.offsetX,\n      y: port.offsetY\n    };\n    var direction = getPortDirection(point, cornersPointsBeforeRotation(target.wrapper), target.wrapper.bounds, false);\n    var firstSegment = connector.segments[0];\n    var secondSegment = connector.segments[1];\n\n    if (firstSegment.direction !== direction) {\n      var segments = [];\n      var segValues = {};\n\n      if (firstSegment.direction === getOppositeDirection(direction)) {\n        segValues = {};\n        var segValues1 = void 0;\n\n        if (direction === 'Top' || direction === 'Bottom') {\n          segValues1 = direction === 'Top' ? {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(firstSegment.points[0].y - point.y)\n          } : {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(point.y - firstSegment.points[0].y)\n          };\n          segValues = firstSegment.points[0].x > point.x ? {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: 'Right',\n            length: firstSegment.points[0].x - point.x\n          } : {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: 'Left',\n            length: point.x - firstSegment.points[0].x\n          };\n        } else {\n          segValues1 = direction === 'Right' ? {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(firstSegment.points[0].x - point.x)\n          } : {\n            type: 'Orthogonal',\n            isTerminal: true,\n            direction: direction,\n            length: Math.abs(point.x - firstSegment.points[0].x)\n          };\n          segValues = firstSegment.points[0].y > point.y ? {\n            type: 'Orthogonal',\n            direction: 'Top',\n            isTerminal: true,\n            length: firstSegment.points[0].y - point.y\n          } : {\n            type: 'Orthogonal',\n            direction: 'Bottom',\n            isTerminal: true,\n            length: point.y - firstSegment.points[0].y\n          };\n        }\n\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues1, true));\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n      } else {\n        segValues = {\n          type: 'Orthogonal',\n          direction: direction,\n          length: 20,\n          isTerminal: true\n        };\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n      }\n\n      if (firstSegment.direction !== getOppositeDirection(direction)) {\n        if (direction === 'Top' || direction === 'Bottom') {\n          firstSegment.points[0].x = point.x;\n          firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = direction === 'Top' ? point.y - 20 : point.y + 20;\n        } else {\n          firstSegment.points[0].y = point.y;\n          firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = direction === 'Right' ? point.x + 20 : point.x - 20;\n        }\n\n        firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n        secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n      }\n\n      connector.segments = segments.concat(connector.segments);\n    } else {\n      firstSegment.points[0] = point;\n\n      if (direction === 'Top' || direction === 'Bottom') {\n        firstSegment.points[firstSegment.points.length - 1].x = point.x;\n      } else {\n        firstSegment.points[firstSegment.points.length - 1].y = point.y;\n      }\n\n      firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n      secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n    }\n  };\n  /**\n   * @param connector\n   * @param changeTerminal\n   * @private\n  Remove terinal segment in initial\n   */\n\n\n  CommandHandler.prototype.removeTerminalSegment = function (connector, changeTerminal) {\n    for (var i = 0; i < connector.segments.length - 2; i++) {\n      var segment = connector.segments[0];\n\n      if (segment.isTerminal) {\n        if (changeTerminal) {\n          segment.isTerminal = false;\n        } else {\n          connector.segments.splice(i, 1);\n          i--;\n        }\n      }\n    }\n  };\n  /**\n   * Change the connector endPoint from point to node\n   */\n\n\n  CommandHandler.prototype.changeSourceEndToNode = function (connector, target) {\n    this.removeTerminalSegment(connector);\n    var sourceWrapper = target.wrapper.children[0].corners;\n    var sourcePoint;\n    var sourcePoint2;\n    var firstSegment = connector.segments[0];\n    var nextSegment = connector.segments[1];\n    var segments = [];\n\n    if (firstSegment.direction === 'Right' || firstSegment.direction === 'Left') {\n      sourcePoint = firstSegment.direction === 'Left' ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n\n      if (firstSegment.length > sourceWrapper.width || firstSegment.direction === 'Left' && sourcePoint.x >= firstSegment.points[0].x || firstSegment.direction === 'Right' && sourcePoint.x <= firstSegment.points[0].x) {\n        firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = sourcePoint.y;\n        firstSegment.points[0].x = sourcePoint.x;\n        firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n        nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n      } else {\n        var direction = void 0;\n\n        if (nextSegment.direction) {\n          direction = nextSegment.direction;\n        } else {\n          direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n        }\n\n        sourcePoint2 = direction === 'Bottom' ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n\n        if (nextSegment.length && nextSegment.direction) {\n          nextSegment.length = direction === 'Top' ? firstSegment.points[firstSegment.points.length - 1].y - (sourcePoint2.y + 20) : sourcePoint2.y + 20 - firstSegment.points[firstSegment.points.length - 1].y;\n        }\n\n        firstSegment.length = firstSegment.points[firstSegment.points.length - 1].x - sourcePoint2.x;\n        firstSegment.direction = firstSegment.length > 0 ? 'Right' : 'Left';\n        var segValues = {\n          type: 'Orthogonal',\n          direction: direction,\n          length: 20\n        };\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n        connector.segments = segments.concat(connector.segments);\n      }\n    } else {\n      sourcePoint = firstSegment.direction === 'Bottom' ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n\n      if (firstSegment.length > sourceWrapper.height || firstSegment.direction === 'Top' && sourcePoint.y >= firstSegment.points[0].y || firstSegment.direction === 'Bottom' && sourcePoint.y <= firstSegment.points[0].y) {\n        firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = sourcePoint.x;\n        firstSegment.points[0].y = sourcePoint.y;\n        firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n        nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n      } else {\n        sourcePoint2 = nextSegment.direction === 'Left' ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n        var direction = void 0;\n\n        if (nextSegment.direction) {\n          direction = nextSegment.direction;\n        } else {\n          direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n        }\n\n        if (nextSegment.length && nextSegment.direction) {\n          nextSegment.length = direction === 'Left' ? firstSegment.points[firstSegment.points.length - 1].x - (sourcePoint2.x + 20) : sourcePoint2.x + 20 - firstSegment.points[firstSegment.points.length - 1].x;\n        }\n\n        firstSegment.length = firstSegment.points[firstSegment.points.length - 1].y - sourcePoint2.y;\n        firstSegment.direction = firstSegment.length > 0 ? 'Bottom' : 'Top';\n        var segValues = {\n          type: 'Orthogonal',\n          direction: direction,\n          length: 20\n        };\n        segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n        connector.segments = segments.concat(connector.segments);\n      }\n    }\n  }; //Translate the bezier points during the interaction\n\n\n  CommandHandler.prototype.translateBezierPoints = function (connector, value, tx, ty, seg, point, update) {\n    var index = connector.segments.indexOf(seg);\n    var segment = connector.segments[index];\n\n    if (segment) {\n      if (value === 'BezierSourceThumb' && (segment.vector1.angle || segment.vector1.distance)) {\n        segment.vector1 = {\n          distance: connector.distance(connector.sourcePoint, point),\n          angle: Point.findAngle(connector.sourcePoint, point)\n        };\n      } else if (value === 'BezierTargetThumb' && (segment.vector2.angle || segment.vector2.distance)) {\n        segment.vector2 = {\n          distance: connector.distance(connector.targetPoint, point),\n          angle: Point.findAngle(connector.targetPoint, point)\n        };\n      } else if ((value === 'ConnectorSourceEnd' && !connector.sourceID || value === 'ConnectorTargetEnd' && !connector.targetID) && update && isEmptyVector(segment.vector1) && isEmptyVector(segment.vector2)) {\n        if (Point.isEmptyPoint(segment.point1)) {\n          segment.bezierPoint1 = getBezierPoints(connector.sourcePoint, connector.targetPoint);\n        }\n\n        if (Point.isEmptyPoint(segment.point2)) {\n          segment.bezierPoint2 = getBezierPoints(connector.targetPoint, connector.sourcePoint);\n        }\n      } else if (value === 'BezierSourceThumb' || value === 'ConnectorSourceEnd' && !update && isEmptyVector(segment.vector1)) {\n        segment.bezierPoint1.x += tx;\n        segment.bezierPoint1.y += ty;\n\n        if (!Point.isEmptyPoint(segment.point1) || update) {\n          segment.point1 = {\n            x: segment.bezierPoint1.x,\n            y: segment.bezierPoint1.y\n          };\n        }\n      } else if (value === 'BezierTargetThumb' || value === 'ConnectorTargetEnd' && !update && isEmptyVector(segment.vector2)) {\n        segment.bezierPoint2.x += tx;\n        segment.bezierPoint2.y += ty;\n\n        if (!Point.isEmptyPoint(segment.point2) || update) {\n          segment.point2 = {\n            x: segment.bezierPoint2.x,\n            y: segment.bezierPoint2.y\n          };\n        }\n      }\n    }\n  };\n  /**\n   * dragTargetEnd method \\\n   *\n   * @returns { void }     dragTargetEnd method .\\\n   * @param {ConnectorModel} obj - provide the obj value.\n   * @param {number} tx - provide the tx value.\n   * @param {number} ty - provide the ty value.\n   * @param {boolean} preventUpdate - provide the preventUpdate value.\n   * @param {PointModel} point - provide the point value.\n   * @param {string} endPoint - provide the endPoint value.\n   * @param {boolean} update - provide the update value.\n   * @param {OrthogonalSegmentModel | BezierSegmentModel | StraightSegmentModel} segment - provide the segment value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragTargetEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, segment) {\n    var connector = this.diagram.nameTable[obj.id];\n    var oldChanges;\n    var boundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n\n    if (canDragTargetEnd(connector) && endPoint !== 'BezierTargetThumb' && boundaryConstraints && canPageEditable(this.diagram)) {\n      oldChanges = {\n        targetPoint: connector.targetPoint\n      };\n      connector.targetPoint.x += tx;\n      connector.targetPoint.y += ty;\n\n      if (endPoint === 'ConnectorTargetEnd' && connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 0) {\n        var prev = connector.segments[connector.segments.length - 2];\n\n        if (prev && connector.segments[connector.segments.length - 1].points.length === 2) {\n          if (prev.direction === 'Left' || prev.direction === 'Right') {\n            prev.points[prev.points.length - 1].x = connector.targetPoint.x;\n          } else {\n            prev.points[prev.points.length - 1].y = connector.targetPoint.y;\n          }\n\n          prev.length = Point.distancePoints(prev.points[0], prev.points[prev.points.length - 1]);\n          prev.direction = Point.direction(prev.points[0], prev.points[prev.points.length - 1]);\n        }\n      }\n\n      if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n        this.updatePathElementOffset(connector);\n      }\n    }\n\n    if (connector.type === 'Bezier') {\n      oldChanges = {\n        targetPoint: connector.targetPoint\n      };\n\n      if (segment) {\n        this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorTargetEnd' : endPoint, tx, ty, segment, point, !update);\n      } else {\n        for (var i = 0; i < obj.segments.length; i++) {\n          this.translateBezierPoints(obj, endPoint === '' ? 'ConnectorTargetEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n        }\n      }\n    }\n\n    if (!preventUpdate) {\n      this.updateEndPoint(connector, oldChanges);\n    }\n\n    if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n      this.diagram.refreshCanvasLayers();\n    }\n\n    return boundaryConstraints;\n  };\n  /**\n   * dragControlPoint method \\\n   *\n   * @returns { void }     dragControlPoint method .\\\n   * @param {ConnectorModel} obj - provide the obj value.\n   * @param {number} tx - provide the tx value.\n   * @param {number} ty - provide the ty value.\n   * @param {boolean} preventUpdate - provide the preventUpdate value.\n   * @param {number} segmentNumber - provide the segmentNumber value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dragControlPoint = function (obj, tx, ty, preventUpdate, segmentNumber) {\n    var connector = this.diagram.nameTable[obj.id];\n\n    if ((connector.type === 'Straight' || connector.type === 'Bezier') && connector.segments.length > 0) {\n      if (segmentNumber !== undefined && connector.segments[segmentNumber]) {\n        connector.segments[segmentNumber].point.x += tx;\n        connector.segments[segmentNumber].point.y += ty;\n      } else {\n        for (var i = 0; i < connector.segments.length - 1; i++) {\n          connector.segments[i].point.x += tx;\n          connector.segments[i].point.y += ty;\n        }\n      }\n\n      if (!preventUpdate) {\n        this.updateEndPoint(connector);\n      }\n    }\n\n    return true;\n  };\n  /**\n   * rotatePropertyChnage method \\\n   *\n   * @returns { void }     rotatePropertyChnage method .\\\n   * @param {number} angle - provide the obj value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.rotatePropertyChnage = function (angle) {\n    var selectedItems = this.diagram.selectedItems;\n    var objects = [];\n    objects = objects.concat(selectedItems.nodes);\n    objects = objects.concat(selectedItems.connectors);\n    var pivotValue = {\n      x: selectedItems.offsetX,\n      y: selectedItems.offsetY\n    };\n    this.rotateObjects(selectedItems, objects, angle - selectedItems.rotateAngle, pivotValue);\n    selectedItems.wrapper.rotateAngle = selectedItems.rotateAngle = angle;\n    this.diagram.updateSelector();\n  };\n  /**\n   * rotateObjects method \\\n   *\n   * @returns { void }     rotateObjects method .\\\n   * @param {NodeModel | SelectorModel} parent - provide the parent value.\n   * @param {(NodeModel | ConnectorModel)[]} objects - provide the objects value.\n   * @param {number} angle - provide the angle value.\n   * @param {PointModel} pivot - provide the pivot value.\n   * @param {boolean} includeParent - provide the includeParent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.rotateObjects = function (parent, objects, angle, pivot, includeParent) {\n    pivot = pivot || {};\n    var matrix = identityMatrix();\n    rotateMatrix(matrix, angle, pivot.x, pivot.y);\n    var oldValues;\n\n    for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {\n      var obj = objects_2[_i];\n\n      if (obj instanceof Node) {\n        if (canRotate(obj) && canPageEditable(this.diagram)) {\n          if (includeParent !== false || parent !== obj) {\n            oldValues = {\n              rotateAngle: obj.rotateAngle\n            };\n            obj.rotateAngle += angle;\n            obj.rotateAngle = (obj.rotateAngle + 360) % 360;\n            var newOffset = transformPointByMatrix(matrix, {\n              x: obj.offsetX,\n              y: obj.offsetY\n            });\n            obj.offsetX = newOffset.x;\n            obj.offsetY = newOffset.y;\n            this.diagram.nodePropertyChange(obj, {}, {\n              offsetX: obj.offsetX,\n              offsetY: obj.offsetY,\n              rotateAngle: obj.rotateAngle\n            });\n          }\n\n          if (obj.processId) {\n            var parent_1 = this.diagram.nameTable[obj.processId];\n            var bound = this.diagram.bpmnModule.getChildrenBound(parent_1, obj.id, this.diagram);\n            this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n          }\n\n          if (obj.children && obj.children.length && !obj.container) {\n            this.getChildren(obj, objects);\n          }\n        }\n      } else {\n        this.rotatePoints(obj, angle, pivot || {\n          x: obj.wrapper.offsetX,\n          y: obj.wrapper.offsetY\n        });\n      }\n\n      this.diagram.updateDiagramObject(obj);\n    }\n\n    this.diagram.refreshCanvasLayers();\n    this.diagram.updateSelector();\n  };\n  /**\n   * snapConnectorEnd method \\\n   *\n   * @returns { PointModel }     snapConnectorEnd method .\\\n   * @param {PointModel} currentPosition - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.snapConnectorEnd = function (currentPosition) {\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines && this.snappingModule) {\n      this.diagram.snappingModule.snapConnectorEnd(currentPosition);\n    }\n\n    return currentPosition;\n  };\n  /**\n   * snapAngle method \\\n   *\n   * @returns { number }     snapAngle method .\\\n   * @param {number} angle - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.snapAngle = function (angle) {\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines && this.snappingModule) {\n      return this.snappingModule.snapAngle(this.diagram, angle);\n    } else {\n      return 0;\n    }\n  };\n  /**\n   * rotatePoints method \\\n   *\n   * @returns { number }     rotatePoints method .\\\n   * @param {Connector} conn - provide the parent value.\n   * @param {number} angle - provide the parent value.\n   * @param {PointModel} pivot - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.rotatePoints = function (conn, angle, pivot) {\n    if (!conn.sourceWrapper || !conn.targetWrapper) {\n      var matrix = identityMatrix();\n      rotateMatrix(matrix, angle, pivot.x, pivot.y);\n      conn.sourcePoint = transformPointByMatrix(matrix, conn.sourcePoint);\n      conn.targetPoint = transformPointByMatrix(matrix, conn.targetPoint);\n\n      if (conn.shape.type === 'Bpmn' && conn.shape.sequence === 'Default') {\n        this.updatePathElementOffset(conn);\n      }\n\n      var newProp = {\n        sourcePoint: conn.sourcePoint,\n        targetPoint: conn.targetPoint\n      };\n      this.diagram.connectorPropertyChange(conn, {}, newProp);\n    }\n  };\n\n  CommandHandler.prototype.updateInnerParentProperties = function (tempNode) {\n    var elements = [];\n    var protect = 'isProtectedOnChange';\n    var protectChange = this.diagram[protect];\n    this.diagram.protectPropertyChange(true);\n    var innerParents = this.getAllDescendants(tempNode, elements, false, true);\n\n    for (var i = 0; i < innerParents.length; i++) {\n      var obj = this.diagram.nameTable[innerParents[i].id];\n      obj.offsetX = obj.wrapper.offsetX;\n      obj.offsetY = obj.wrapper.offsetY;\n      obj.width = obj.wrapper.width;\n      obj.height = obj.wrapper.height;\n    }\n\n    this.diagram.protectPropertyChange(protectChange);\n  };\n  /**\n   * scale method \\\n   *\n   * @returns { boolean }     scale method .\\\n   * @param {NodeModel | ConnectorModel} obj - provide the parent value.\n   * @param {number} sw - provide the parent value.\n   * @param {number} sh - provide the parent value.\n   * @param {number} pivot - provide the parent value.\n   * @param {number} refObject - provide the parent value.\n   * @param {boolean} isOutsideBoundary - provide the parent value.\n   *\n   * @private\n   */\n  // eslint-disable-next-line max-len\n\n\n  CommandHandler.prototype.scale = function (obj, sw, sh, pivot, refObject, isOutsideBoundary) {\n    var node = this.diagram.nameTable[obj.id];\n    var tempNode = node;\n    var elements = [];\n    var element = node.wrapper;\n\n    if (!refObject) {\n      refObject = obj;\n    }\n\n    var refWrapper = refObject.wrapper;\n    var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;\n    var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;\n    var refPoint = getPoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);\n\n    if (element.actualSize.width !== undefined && element.actualSize.height !== undefined && canPageEditable(this.diagram)) {\n      if (tempNode.children && !tempNode.container) {\n        var nodes = this.getAllDescendants(tempNode, elements);\n\n        for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n          var temp = nodes_1[_i];\n          this.scaleObject(sw, sh, refPoint, temp, element, refObject);\n        }\n\n        obj.wrapper.measure(new Size());\n        obj.wrapper.arrange(obj.wrapper.desiredSize);\n        this.diagram.updateGroupOffset(node);\n        this.updateInnerParentProperties(tempNode);\n      } else {\n        this.scaleObject(sw, sh, refPoint, node, element, refObject);\n      }\n\n      var bounds = getBounds(obj.wrapper);\n      var checkBoundaryConstraints = this.checkBoundaryConstraints(undefined, undefined, bounds);\n\n      if (!checkBoundaryConstraints && isOutsideBoundary) {\n        this.scale(obj, 1 / sw, 1 / sh, pivot, undefined, true);\n        return false;\n      }\n\n      this.diagram.updateDiagramObject(obj);\n    }\n\n    return true;\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getAllDescendants = function (node, nodes, includeParent, innerParent) {\n    var temp = node;\n    var parentNodes = [];\n\n    for (var i = 0; i < temp.children.length; i++) {\n      node = this.diagram.nameTable[temp.children[i]];\n\n      if (node) {\n        if (!node.children) {\n          nodes.push(node);\n        } else {\n          if (includeParent) {\n            nodes.push(node);\n          }\n\n          if (innerParent) {\n            parentNodes.push(node);\n          }\n\n          nodes = this.getAllDescendants(node, nodes);\n        }\n      }\n    }\n\n    return innerParent ? parentNodes : nodes;\n  };\n  /**\n   * getChildren method \\\n   *\n   * @returns { (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[] }     getChildren method .\\\n   * @param {NodeModel} node - provide the sw value.\n   * @param {(NodeModel | ConnectorModel)[]} nodes - provide the sw value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.getChildren = function (node, nodes) {\n    var temp = node;\n\n    if (node.children) {\n      for (var i = 0; i < temp.children.length; i++) {\n        node = this.diagram.nameTable[temp.children[i]];\n        nodes.push(node);\n      }\n    }\n\n    return nodes;\n  };\n  /**\n   * scaleObject method \\\n   *\n   * @returns { NodeModel }     scaleObject method .\\\n   * @param {string} id - provide the sw value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.cloneChild = function (id) {\n    var node = this.diagram.nameTable[id];\n    return node;\n  };\n  /**\n   * scaleObject method \\\n   *\n   * @returns { void }     scaleObject method .\\\n   * @param {End} sw - provide the sw value.\n   * @param {End} sh - provide the sh value.\n   * @param {PointModel} pivot - provide the pivot value.\n   * @param {IElement} obj - provide the pivot value.\n   * @param {DiagramElement} element - provide the element value.\n   * @param {IElement} refObject - provide the refObject value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.scaleObject = function (sw, sh, pivot, obj, element, refObject) {\n    sw = sw < 0 ? 1 : sw;\n    sh = sh < 0 ? 1 : sh;\n    var oldValues = {};\n\n    if (sw !== 1 || sh !== 1) {\n      var width = void 0;\n      var height = void 0;\n\n      if (obj instanceof Node) {\n        var node = obj;\n        var isResize = void 0;\n        var bound = void 0;\n        oldValues = {\n          width: obj.wrapper.actualSize.width,\n          height: obj.wrapper.actualSize.height,\n          offsetX: obj.wrapper.offsetX,\n          offsetY: obj.wrapper.offsetY,\n          margin: {\n            top: node.margin.top,\n            left: node.margin.left\n          }\n        };\n\n        if (node.shape.type === 'Bpmn' && node.shape.activity.subProcess.processes && node.shape.activity.subProcess.processes.length > 0) {\n          bound = this.diagram.bpmnModule.getChildrenBound(node, node.id, this.diagram);\n          isResize = node.wrapper.bounds.containsRect(bound);\n        }\n\n        width = node.wrapper.actualSize.width * sw;\n        height = node.wrapper.actualSize.height * sh;\n\n        if (node.maxWidth !== undefined && node.maxWidth !== 0) {\n          width = Math.min(node.maxWidth, width);\n        }\n\n        if (node.minWidth !== undefined && node.minWidth !== 0) {\n          width = Math.max(node.minWidth, width);\n        }\n\n        if (node.maxHeight !== undefined && node.maxHeight !== 0) {\n          height = Math.min(node.maxHeight, height);\n        }\n\n        if (node.minHeight !== undefined && node.minHeight !== 0) {\n          height = Math.max(node.minHeight, height);\n        }\n\n        if (isResize) {\n          width = Math.max(width, bound.right - node.wrapper.bounds.x);\n          height = Math.max(height, bound.bottom - node.wrapper.bounds.y);\n        }\n\n        sw = width / node.actualSize.width;\n        sh = height / node.actualSize.height;\n      }\n\n      var matrix = identityMatrix(); // let refWrapper: DiagramElement;\n\n      if (!refObject) {\n        refObject = obj;\n      }\n\n      var refWrapper = refObject.wrapper;\n      rotateMatrix(matrix, -refWrapper.rotateAngle, pivot.x, pivot.y);\n      scaleMatrix(matrix, sw, sh, pivot.x, pivot.y);\n      rotateMatrix(matrix, refWrapper.rotateAngle, pivot.x, pivot.y);\n\n      if (obj instanceof Node) {\n        var node = obj; //let left: number; let top: number;\n\n        var newPosition = transformPointByMatrix(matrix, {\n          x: node.wrapper.offsetX,\n          y: node.wrapper.offsetY\n        });\n        var oldleft = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n        var oldtop = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n\n        if (width > 0) {\n          if (node.processId) {\n            var parent_2 = this.diagram.nameTable[node.processId];\n\n            if (!parent_2.maxWidth || node.margin.left + width < parent_2.maxWidth) {\n              node.width = width;\n              node.offsetX = newPosition.x;\n            }\n          } else {\n            node.width = width;\n            node.offsetX = newPosition.x;\n          }\n        }\n\n        if (height > 0) {\n          if (node.processId) {\n            var parent_3 = this.diagram.nameTable[node.processId];\n\n            if (!parent_3.maxHeight || node.margin.top + height < parent_3.maxHeight) {\n              node.height = height;\n              node.offsetY = newPosition.y;\n            }\n          } else {\n            node.height = height;\n            node.offsetY = newPosition.y;\n          }\n        }\n\n        var left = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n        var top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n        var parent_4 = this.diagram.nameTable[node.processId];\n\n        if (parent_4 && (node.margin.top + (top_1 - oldtop) <= 0 || node.margin.left + (left - oldleft) <= 0)) {\n          this.diagram.nodePropertyChange(obj, {}, {\n            margin: {\n              top: node.margin.top,\n              left: node.margin.left\n            }\n          });\n        } else {\n          if (checkParentAsContainer(this.diagram, obj, true)) {\n            checkChildNodeInContainer(this.diagram, obj);\n          } else {\n            this.diagram.nodePropertyChange(obj, oldValues, {\n              width: node.width,\n              height: node.height,\n              offsetX: node.offsetX,\n              offsetY: node.offsetY,\n              margin: {\n                top: node.margin.top + (top_1 - oldtop),\n                left: node.margin.left + (left - oldleft)\n              }\n            });\n          }\n        }\n      } else {\n        var connector = obj;\n        var oldValues_1 = {\n          sourcePoint: connector.sourcePoint,\n          targetPoint: connector.targetPoint\n        };\n\n        if (!connector.sourceWrapper || !connector.targetWrapper) {\n          this.scaleConnector(connector, matrix, oldValues_1);\n        }\n      }\n\n      var parentNode = this.diagram.nameTable[obj.processId];\n\n      if (parentNode) {\n        var parent_5 = parentNode.wrapper.bounds;\n        var child = obj.wrapper.bounds;\n        var bound = this.diagram.bpmnModule.getChildrenBound(parentNode, obj.id, this.diagram);\n        this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n      }\n    }\n  };\n\n  CommandHandler.prototype.scaleConnector = function (connector, matrix, oldValues) {\n    connector.sourcePoint = transformPointByMatrix(matrix, connector.sourcePoint);\n    connector.targetPoint = transformPointByMatrix(matrix, connector.targetPoint);\n\n    if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n      this.updatePathElementOffset(connector);\n    }\n\n    var newProp = {\n      sourcePoint: connector.sourcePoint,\n      targetPoint: connector.targetPoint\n    };\n    this.diagram.connectorPropertyChange(connector, oldValues, newProp);\n  };\n  /**\n   * portDrag method \\\n   *\n   * @returns { void }     portDrag method .\\\n   * @param { NodeModel | ConnectorModel} obj - provide the obj value.\n   * @param {DiagramElement} portElement - provide the portElement value.\n   * @param {number} tx - provide the tx value.\n   * @param {number} ty - provide the tx value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.portDrag = function (obj, portElement, tx, ty) {\n    var oldValues;\n    var changedvalues;\n    var port = this.findTarget(portElement, obj);\n    var bounds = getBounds(obj.wrapper);\n\n    if (port && canDrag(port, this.diagram)) {\n      oldValues = this.getPortChanges(obj, port);\n      port.offset.x += tx / bounds.width;\n      port.offset.y += ty / bounds.height;\n      changedvalues = this.getPortChanges(obj, port);\n      this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n      this.diagram.updateDiagramObject(obj);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.labelDrag = function (obj, textElement, tx, ty) {\n    //let changedvalues: Object;\n    //let label: ShapeAnnotationModel | PathAnnotationModel;\n    // eslint-disable-next-line max-len\n    var label = this.findTarget(textElement, obj);\n    var bounds = cornersPointsBeforeRotation(obj.wrapper);\n    var oldValues = this.getAnnotationChanges(obj, label);\n\n    if (label instanceof ShapeAnnotation) {\n      label.offset.x += tx / bounds.width;\n      label.offset.y += ty / bounds.height;\n    } else {\n      this.updatePathAnnotationOffset(obj, label, tx, ty);\n\n      if (label instanceof PathAnnotation) {\n        label.alignment = 'Center';\n      }\n    }\n\n    var changedvalues = this.getAnnotationChanges(obj, label);\n\n    if (obj instanceof Node) {\n      this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n    } else {\n      this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);\n    }\n\n    this.diagram.updateDiagramObject(obj);\n\n    if (!isSelected(this.diagram, label, false, textElement)) {\n      this.labelSelect(obj, textElement);\n    }\n  };\n\n  CommandHandler.prototype.updatePathAnnotationOffset = function (object, label, tx, ty, newPosition, size) {\n    var textWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n    var offsetX = textWrapper.offsetX;\n    var offsetY = textWrapper.offsetY;\n    var offset;\n    var intermediatePoints = object.intermediatePoints;\n    var prev;\n    var pointLength = 0;\n    var totalLength = 0;\n    var intersectingOffset;\n    var currentPosition = newPosition ? newPosition : {\n      x: offsetX + tx,\n      y: offsetY + ty\n    };\n    var intersetingPts = this.getInterceptWithSegment(currentPosition, intermediatePoints);\n    var newOffset = intermediatePoints[intermediatePoints.length - 1];\n    totalLength = Point.getLengthFromListOfPoints(intermediatePoints);\n\n    if (intersetingPts.length > 0) {\n      if (label.dragLimit.top || label.dragLimit.bottom || label.dragLimit.left || label.dragLimit.right) {\n        var minDistance = {\n          minDistance: null\n        };\n        newOffset = this.getRelativeOffset(currentPosition, intermediatePoints, minDistance);\n        var distance = {\n          minDistance: null\n        };\n        intersectingOffset = this.getRelativeOffset(currentPosition, intersetingPts, distance);\n\n        if (minDistance != null && distance.minDistance < minDistance.minDistance) {\n          newOffset = intersectingOffset;\n        } else {\n          var connectorOffset = getOffsetOfConnector(object.intermediatePoints, label);\n          newOffset = connectorOffset.point;\n        }\n      } else {\n        intersectingOffset = intersetingPts[intersetingPts.length - 1];\n        newOffset = intersectingOffset;\n      }\n\n      if (newOffset) {\n        var p = void 0;\n        var bounds = void 0;\n\n        for (p = 0; p < intermediatePoints.length; p++) {\n          if (prev != null) {\n            bounds = Rect.toBounds([prev, intermediatePoints[p]]);\n\n            if (bounds.containsPoint(newOffset)) {\n              pointLength += Point.findLength(prev, newOffset);\n              break;\n            } else {\n              pointLength += Point.findLength(prev, intermediatePoints[p]);\n            }\n          }\n\n          prev = intermediatePoints[p];\n        }\n\n        offset = {\n          x: pointLength / totalLength,\n          y: 0\n        };\n      }\n\n      this.updateLabelMargin(object, label, offset, currentPosition, size, tx, ty);\n    } else {\n      this.updateLabelMargin(object, label, null, currentPosition, size, tx, ty);\n    }\n  };\n\n  CommandHandler.prototype.getRelativeOffset = function (currentPosition, points, minDistance) {\n    var newOffset;\n    var distance;\n    var pt;\n    var i;\n\n    for (i = 0; i < points.length; i++) {\n      pt = points[i];\n      distance = Math.round(Math.sqrt(Math.pow(currentPosition.x - pt.x, 2) + Math.pow(currentPosition.y - pt.y, 2)));\n\n      if (minDistance.minDistance === null || Math.min(Math.abs(minDistance.minDistance), Math.abs(distance)) === Math.abs(distance)) {\n        newOffset = pt;\n        minDistance.minDistance = distance;\n      }\n    }\n\n    return newOffset;\n  };\n\n  CommandHandler.prototype.dragLimitValue = function (label, point, tempPt, contentDimension) {\n    var x = false;\n    var y = false;\n\n    if (tempPt.x >= point.x - label.dragLimit.left - contentDimension.width / 2 && tempPt.x <= point.x + label.dragLimit.right + contentDimension.width / 2) {\n      x = true;\n    }\n\n    if (tempPt.y >= point.y - label.dragLimit.top - contentDimension.height / 2 && tempPt.y <= point.y + label.dragLimit.bottom + contentDimension.height / 2) {\n      y = true;\n    }\n\n    return {\n      x: x,\n      y: y\n    };\n  };\n  /* eslint-disable */\n\n\n  CommandHandler.prototype.updateLabelMargin = function (node, label, offset, tempPt, size, tx, ty) {\n    offset = offset ? offset : {\n      x: label.offset,\n      y: 0\n    };\n\n    if (label && offset && offset.x > 0 && offset.x < 1) {\n      //let point: PointModel;\n      var length_1 = Point.getLengthFromListOfPoints(node.intermediatePoints);\n      var point = this.getPointAtLength(length_1 * offset.x, node.intermediatePoints, 0);\n      var curZoomfactor = this.diagram.scrollSettings.currentZoom;\n      var dragLimit = label.dragLimit;\n\n      if (dragLimit.top || dragLimit.bottom || dragLimit.left || dragLimit.right) {\n        var labelBounds = this.diagram.getWrapper(node.wrapper, label.id);\n        var contentDimension = new Rect(0, 0, 0, 0);\n        var annotationWrtapper = this.diagram.getWrapper(node.wrapper, label.id);\n        contentDimension.x = annotationWrtapper.offsetX / curZoomfactor + tx;\n        contentDimension.y = annotationWrtapper.offsetY / curZoomfactor + ty;\n        contentDimension.width = annotationWrtapper.bounds.width / curZoomfactor;\n        contentDimension.height = annotationWrtapper.bounds.height / curZoomfactor;\n        var draggableBounds = new Rect(point.x - (dragLimit.left || 0) - contentDimension.width / 2, point.y - (dragLimit.top || 0) - contentDimension.height / 2, (dragLimit.left || 0) + (dragLimit.right || 0) + contentDimension.width, (dragLimit.top || 0) + (dragLimit.bottom || 0) + contentDimension.height);\n\n        if (draggableBounds.containsPoint(tempPt)) {\n          tempPt = tempPt;\n        } else {\n          var lineIntersects = void 0;\n          var line1 = [point, tempPt];\n          lineIntersects = this.boundsInterSects(line1, draggableBounds, false);\n\n          for (var _i = 0, lineIntersects_1 = lineIntersects; _i < lineIntersects_1.length; _i++) {\n            var i = lineIntersects_1[_i];\n            var ptt = i;\n            tempPt = ptt;\n          }\n        }\n\n        var cursorLimit = this.dragLimitValue(label, point, tempPt, contentDimension);\n        label.margin = {\n          left: cursorLimit.x ? tempPt.x - point.x : label.margin.left,\n          top: cursorLimit.y ? tempPt.y - point.y : label.margin.top,\n          right: 0,\n          bottom: 0\n        };\n      } else {\n        label.margin = {\n          left: tempPt.x - point.x,\n          top: tempPt.y - point.y,\n          right: 0,\n          bottom: 0\n        };\n      }\n\n      label.offset = offset.x;\n\n      if (size) {\n        label.width = size.width;\n        label.height = size.height;\n      }\n    }\n  };\n\n  CommandHandler.prototype.boundsInterSects = function (polyLine, bounds, self) {\n    var intersects;\n\n    if (bounds) {\n      var polyLine2 = [{\n        x: bounds.x,\n        y: bounds.y\n      }, {\n        x: bounds.x + bounds.width,\n        y: bounds.y\n      }, {\n        x: bounds.x + bounds.width,\n        y: bounds.y + bounds.height\n      }, {\n        x: bounds.x,\n        y: bounds.y + bounds.height\n      }, {\n        x: bounds.x,\n        y: bounds.y\n      }];\n      intersects = this.intersect(polyLine, polyLine2, self);\n    }\n\n    return intersects;\n  };\n\n  CommandHandler.prototype.intersect = function (polyLine1, polyLine2, self) {\n    var intersect = [];\n\n    for (var i = 0; i < polyLine1.length - 1; i++) {\n      for (var j = 0; j < polyLine2.length - 1; j++) {\n        var p = intersect2(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);\n\n        if (p.x !== 0 && p.y !== 0) {\n          intersect.push(p);\n        }\n      }\n    }\n\n    return intersect;\n  };\n\n  CommandHandler.prototype.getPointAtLength = function (length, points, angle) {\n    angle = 0;\n    var run = 0;\n    var pre;\n    var found = {\n      x: 0,\n      y: 0\n    };\n    var pt;\n\n    for (var i = 0; i < points.length; i++) {\n      pt = points[i];\n\n      if (!pre) {\n        pre = pt;\n        continue;\n      } else {\n        var l = Point.findLength(pre, pt);\n        var r = void 0;\n        var deg = void 0;\n        var x = void 0;\n        var y = void 0;\n\n        if (run + l >= length) {\n          r = length - run;\n          deg = Point.findAngle(pre, pt);\n          x = r * Math.cos(deg * Math.PI / 180);\n          y = r * Math.sin(deg * Math.PI / 180);\n          found = {\n            x: pre.x + x,\n            y: pre.y + y\n          };\n          angle = deg;\n          break;\n        } else {\n          run += l;\n        }\n      }\n\n      pre = pt;\n    }\n\n    return found;\n  };\n\n  CommandHandler.prototype.getInterceptWithSegment = function (currentPosition, conPoints) {\n    var intercepts = [];\n    var imgLine = [];\n    var segemnt = [];\n    var tarAngle;\n    var srcAngle; //let maxLength: number;\n\n    var maxLength = Point.findLength({\n      x: 0,\n      y: 0\n    }, {\n      x: this.diagram.scroller.viewPortWidth,\n      y: this.diagram.scroller.viewPortHeight\n    });\n\n    for (var i = 1; i < conPoints.length; i++) {\n      segemnt = [conPoints[i - 1], conPoints[i]];\n      imgLine = [];\n      srcAngle = Math.round(Point.findAngle(segemnt[0], segemnt[1]) % 360);\n      tarAngle = Math.round(Point.findAngle(segemnt[1], segemnt[0]) % 360);\n      var angleAdd = srcAngle > 0 && srcAngle <= 90 || srcAngle > 180 && srcAngle <= 270 ? 90 : -90;\n      imgLine.push(Point.transform(currentPosition, srcAngle + angleAdd, maxLength));\n      imgLine.push(Point.transform(currentPosition, tarAngle + angleAdd, maxLength));\n      var lineUtil1 = {\n        x1: segemnt[0].x,\n        y1: segemnt[0].y,\n        x2: segemnt[1].x,\n        y2: segemnt[1].y\n      };\n      var lineUtil2 = {\n        x1: imgLine[0].x,\n        y1: imgLine[0].y,\n        x2: imgLine[1].x,\n        y2: imgLine[1].y\n      };\n      var line3 = intersect3(lineUtil1, lineUtil2);\n\n      if (line3.enabled) {\n        intercepts.push(line3.intersectPt);\n      }\n    }\n\n    return intercepts;\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getAnnotationChanges = function (object, label) {\n    var index = findObjectIndex(object, label.id, true);\n    var annotations = {};\n    annotations[index] = {\n      width: label.width,\n      height: label.height,\n      offset: object instanceof Node ? {\n        x: label.offset.x,\n        y: label.offset.y\n      } : label.offset,\n      rotateAngle: label.rotateAngle,\n      margin: {\n        left: label.margin.left,\n        right: label.margin.right,\n        top: label.margin.top,\n        bottom: label.margin.bottom\n      },\n      horizontalAlignment: label.horizontalAlignment,\n      verticalAlignment: label.verticalAlignment,\n      alignment: object instanceof Connector ? label.alignment : undefined\n    };\n    return {\n      annotations: annotations\n    };\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getPortChanges = function (object, port) {\n    var index = findObjectIndex(object, port.id, false);\n    var ports = {};\n    ports[index] = {\n      offset: port.offset\n    };\n    return {\n      ports: ports\n    };\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.labelRotate = function (object, label, currentPosition, selector) {\n    var oldValues;\n    var changedvalues;\n    oldValues = this.getAnnotationChanges(object, label);\n    var matrix = identityMatrix();\n    var rotateAngle = label.rotateAngle;\n    var labelWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n    var angle = findAngle({\n      x: labelWrapper.offsetX,\n      y: labelWrapper.offsetY\n    }, currentPosition) + 90;\n    var snapAngle = this.snapAngle(angle);\n    angle = snapAngle !== 0 ? snapAngle : angle;\n\n    if (label instanceof PathAnnotation && label.segmentAngle) {\n      var getPointloop = getAnnotationPosition(object.intermediatePoints, label, object.wrapper.bounds);\n      angle -= getPointloop.angle;\n    }\n\n    angle = (angle + 360) % 360;\n    label.rotateAngle += angle - (label.rotateAngle + labelWrapper.parentTransform);\n    label.margin.bottom += labelWrapper.verticalAlignment === 'Top' ? -label.height / 2 : labelWrapper.verticalAlignment === 'Bottom' ? label.height / 2 : 0;\n    label.margin.right += labelWrapper.horizontalAlignment === 'Left' ? -label.width / 2 : labelWrapper.horizontalAlignment === 'Right' ? label.width / 2 : 0;\n\n    if (label instanceof PathAnnotation) {\n      label.alignment = 'Center';\n    } else {\n      label.horizontalAlignment = label.verticalAlignment = 'Center';\n    }\n\n    selector.wrapper.rotateAngle = selector.rotateAngle = label.rotateAngle;\n    changedvalues = this.getAnnotationChanges(object, label);\n\n    if (object instanceof Node) {\n      this.diagram.nodePropertyChange(object, oldValues, changedvalues);\n    } else {\n      this.diagram.connectorPropertyChange(object, oldValues, changedvalues);\n    }\n\n    this.diagram.updateDiagramObject(object);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.labelResize = function (node, label, deltaWidth, deltaHeight, pivot, selector) {\n    var oldValues;\n    var changedvalues;\n    var rotateAngle;\n    oldValues = this.getAnnotationChanges(node, label);\n    var textElement = selector.wrapper.children[0];\n\n    if (deltaWidth && deltaWidth !== 1 || deltaHeight && deltaHeight !== 1) {\n      var newMat = identityMatrix();\n      var matrix = identityMatrix();\n      rotateMatrix(newMat, -node.rotateAngle, node.offsetX, node.offsetY);\n      rotateAngle = (textElement.rotateAngle + (node instanceof Node ? node.rotateAngle : 0) + 360) % 360;\n      rotateMatrix(matrix, -rotateAngle, pivot.x, pivot.y);\n      scaleMatrix(matrix, deltaWidth, deltaHeight, pivot.x, pivot.y);\n      rotateMatrix(matrix, rotateAngle, pivot.x, pivot.y);\n      var newPosition = transformPointByMatrix(matrix, {\n        x: textElement.offsetX,\n        y: textElement.offsetY\n      });\n      var height = textElement.actualSize.height * deltaHeight;\n      var width = textElement.actualSize.width * deltaWidth;\n      var shape = this.findTarget(textElement, node);\n\n      if (shape instanceof PathAnnotation) {\n        this.updatePathAnnotationOffset(node, label, 0, 0, newPosition, new Size(width, height));\n      } else {\n        var bounds = cornersPointsBeforeRotation(node.wrapper);\n        newPosition = transformPointByMatrix(newMat, newPosition);\n        newPosition.x = newPosition.x - textElement.margin.left + textElement.margin.right;\n        newPosition.y = newPosition.y - textElement.margin.top + textElement.margin.bottom;\n        newPosition.y += shape.verticalAlignment === 'Top' ? -height / 2 : shape.verticalAlignment === 'Bottom' ? height / 2 : 0;\n        newPosition.x += shape.horizontalAlignment === 'Left' ? -width / 2 : shape.horizontalAlignment === 'Right' ? width / 2 : 0;\n        var offsetx = bounds.width / (newPosition.x - bounds.x);\n        var offsety = bounds.height / (newPosition.y - bounds.y);\n\n        if (width > 1) {\n          shape.width = width;\n          shape.offset.x = 1 / offsetx;\n        }\n\n        if (height > 1) {\n          shape.height = height;\n          shape.offset.y = 1 / offsety;\n        }\n      }\n    }\n\n    if (label instanceof PathAnnotation) {\n      label.alignment = 'Center';\n    }\n\n    changedvalues = this.getAnnotationChanges(node, label);\n\n    if (node instanceof Node) {\n      this.diagram.nodePropertyChange(node, oldValues, changedvalues);\n    } else {\n      this.diagram.connectorPropertyChange(node, oldValues, changedvalues);\n    }\n\n    this.diagram.updateDiagramObject(node);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.getSubProcess = function (source) {\n    var selector = {\n      nodes: [],\n      connectors: []\n    };\n    var process;\n\n    if (source instanceof Node) {\n      process = source.processId;\n    } else if (source && source.nodes && source.nodes.length && source.nodes[0].processId) {\n      process = source.nodes[0].processId;\n    }\n\n    if (process) {\n      selector.nodes.push(clone(this.diagram.nameTable[process]));\n      return selector;\n    }\n\n    return selector;\n  };\n  /**   @private  */\n\n\n  CommandHandler.prototype.checkBoundaryConstraints = function (tx, ty, nodeBounds) {\n    var pageSettings = this.diagram.pageSettings;\n    var boundaryConstraints = this.diagram.pageSettings.boundaryConstraints;\n    var scroller = this.diagram.scroller;\n\n    if (boundaryConstraints === 'Page' || boundaryConstraints === 'Diagram') {\n      var selectorBounds = !nodeBounds ? this.diagram.selectedItems.wrapper.bounds : undefined;\n      var width = boundaryConstraints === 'Page' ? pageSettings.width : scroller.viewPortWidth;\n      var height = boundaryConstraints === 'Page' ? pageSettings.height : scroller.viewPortHeight;\n      var bounds = nodeBounds;\n      var right = (nodeBounds ? bounds.right : selectorBounds.right) + (tx || 0);\n      var left = (nodeBounds ? bounds.left : selectorBounds.left) + (tx || 0);\n      var top_2 = (nodeBounds ? bounds.top : selectorBounds.top) + (ty || 0);\n      var bottom = (nodeBounds ? bounds.bottom : selectorBounds.bottom) + (ty || 0);\n\n      if (right <= width && left >= 0 && bottom <= height && top_2 >= 0) {\n        return true;\n      }\n\n      return false;\n    }\n\n    return true;\n  }; //interfaces\n\n  /** @private */\n\n\n  CommandHandler.prototype.dragSelectedObjects = function (tx, ty) {\n    var obj = this.diagram.selectedItems;\n\n    if (this.state && !this.state.backup) {\n      this.state.backup = {};\n      this.state.backup.offsetX = obj.offsetX;\n      this.state.backup.offsetY = obj.offsetY;\n    }\n\n    obj = renderContainerHelper(this.diagram, obj) || obj;\n\n    if (this.checkBoundaryConstraints(tx, ty)) {\n      this.diagram.diagramActions = this.diagram.diagramActions | (DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n      var actualObject = this.diagram.selectedObject.actualObject;\n\n      if (actualObject && actualObject instanceof Node && actualObject.isLane && canLaneInterchange(actualObject, this.diagram) || !actualObject || !actualObject.isLane) {\n        this.diagram.drag(obj, tx, ty);\n      }\n\n      this.diagram.diagramActions = this.diagram.diagramActions & ~(DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n      this.diagram.refreshCanvasLayers();\n      return true;\n    }\n\n    return false;\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.scaleSelectedItems = function (sx, sy, pivot) {\n    var obj = this.diagram.selectedItems;\n\n    if (this.state && !this.state.backup) {\n      this.state.backup = {};\n      this.state.backup.offsetX = obj.offsetX;\n      this.state.backup.offsetY = obj.offsetY;\n      this.state.backup.width = obj.width;\n      this.state.backup.height = obj.height;\n      this.state.backup.pivot = pivot;\n    }\n\n    obj = renderContainerHelper(this.diagram, obj) || obj;\n    return this.diagram.scale(obj, sx, sy, pivot);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.rotateSelectedItems = function (angle) {\n    var obj = this.diagram.selectedItems;\n\n    if (this.state && !this.state.backup) {\n      this.state.backup = {};\n      this.state.backup.angle = obj.rotateAngle;\n    }\n\n    obj = renderContainerHelper(this.diagram, obj) || obj;\n    return this.diagram.rotate(obj, angle);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.hasSelection = function () {\n    return hasSelection(this.diagram);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.isSelected = function (element) {\n    return isSelected(this.diagram, element);\n  };\n  /**\n   * initExpand is used for layout expand and collapse interaction\n   */\n\n\n  CommandHandler.prototype.initExpand = function (args) {\n    var propName = 'isProtectedOnChange';\n    var protectedChange = this.diagram[propName];\n    this.diagram.protectPropertyChange(true);\n    var node = args.target || args.source;\n    var oldValues = {\n      isExpanded: node.isExpanded\n    };\n    node.isExpanded = !node.isExpanded;\n    this.diagram.preventNodesUpdate = true;\n    this.diagram.diagramActions |= DiagramAction.PreventIconsUpdate;\n    this.diagram.nodePropertyChange(node, oldValues, {\n      isExpanded: node.isExpanded\n    });\n    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PreventIconsUpdate;\n    this.diagram.preventNodesUpdate = false;\n\n    for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n      var temp = _a[_i];\n      var view = this.diagram.views[temp];\n\n      if (!(view instanceof Diagram)) {\n        this.diagram.refreshCanvasDiagramLayer(view);\n      }\n    }\n\n    this.diagram.protectPropertyChange(protectedChange);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.expandNode = function (node, diagram) {\n    var animation; //let objects: ILayout;\n\n    var preventNodesUpdate = this.diagram.preventNodesUpdate;\n    var expand = node.isExpanded;\n    this.diagram.preventNodesUpdate = true;\n    this.diagram.preventConnectorsUpdate = true;\n    this.expandCollapse(node, expand, this.diagram);\n    node.isExpanded = expand;\n    var fixedNode = this.diagram.layout.fixedNode;\n    this.diagram.layout.fixedNode = node.id;\n\n    if (this.diagram.diagramActions != DiagramAction.Render && this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && this.diagram.organizationalChartModule) {\n      this.diagram.organizationalChartModule.isAnimation = true;\n    }\n\n    this.diagram.blazorActions |= BlazorAction.expandNode;\n    var objects = this.diagram.doLayout();\n    this.diagram.blazorActions &= ~BlazorAction.expandNode;\n    this.diagram.preventNodesUpdate = preventNodesUpdate;\n    this.diagram.preventConnectorsUpdate = false;\n\n    if (this.diagram.layoutAnimateModule && this.diagram.organizationalChartModule) {\n      this.diagram.allowServerDataBinding = false;\n      this.layoutAnimateModule.expand(this.diagram.layout.enableAnimation, objects, node, this.diagram);\n      this.diagram.allowServerDataBinding = true;\n    } else {\n      var arg = {\n        element: cloneBlazorObject(clone(node)),\n        state: node.isExpanded ? true : false\n      };\n      this.triggerEvent(DiagramEvent.expandStateChange, arg);\n\n      if (this.diagram.lineRoutingModule && this.diagram.constraints & DiagramConstraints.LineRouting) {\n        this.diagram.resetSegments();\n      }\n    }\n\n    this.diagram.layout.fixedNode = fixedNode === '' ? '' : this.diagram.layout.fixedNode;\n    return objects;\n  };\n\n  CommandHandler.prototype.getparentexpand = function (target, diagram, visibility, connector) {\n    var boolean;\n\n    for (var i = 0; i < target.inEdges.length; i++) {\n      var newConnector = diagram.nameTable[target.inEdges[i]];\n      var previousNode = diagram.nameTable[newConnector.sourceID];\n\n      if (previousNode.isExpanded && !visibility && previousNode.id !== connector.sourceID && newConnector.visible) {\n        return false;\n      } else {\n        boolean = true;\n      }\n    }\n\n    return boolean;\n  };\n  /**\n   * Setinterval and Clear interval for layout animation\n   */\n\n  /** @private */\n\n\n  CommandHandler.prototype.expandCollapse = function (source, visibility, diagram) {\n    for (var i = 0; i < source.outEdges.length; i++) {\n      var connector = diagram.nameTable[source.outEdges[i]];\n      var target = diagram.nameTable[connector.targetID];\n      var value = this.getparentexpand(target, diagram, visibility, connector);\n      connector.visible = visibility;\n      var oldValues = {\n        visible: target.visible,\n        style: {\n          opacity: target.wrapper.style.opacity\n        }\n      };\n      var newValues = {\n        visible: target.visible,\n        style: {\n          opacity: target.wrapper.style.opacity\n        }\n      };\n\n      if (value) {\n        if (target.isExpanded) {\n          this.expandCollapse(target, visibility, diagram);\n        }\n\n        target.visible = visibility;\n        target.style.opacity = this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && visibility ? 0.1 : target.style.opacity;\n        diagram.nodePropertyChange(target, oldValues, newValues);\n      }\n\n      diagram.connectorPropertyChange(connector, oldValues, newValues);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateNodeDimension = function (obj, rect) {\n    if (obj instanceof Node) {\n      obj.offsetX = rect.x + rect.width / 2;\n      obj.offsetY = rect.y + rect.height / 2;\n      obj.width = rect.width;\n      obj.height = rect.height;\n      obj.wrapper.children[0].canMeasurePath = true;\n      this.diagram.nodePropertyChange(obj, {}, {\n        width: rect.width,\n        height: rect.height,\n        offsetX: obj.offsetX,\n        offsetY: obj.offsetY\n      });\n\n      if (this.diagram.mode !== 'SVG') {\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateConnectorPoints = function (obj, rect) {\n    if (obj instanceof Connector) {\n      this.diagram.connectorPropertyChange(obj, {}, {\n        targetPoint: obj.targetPoint\n      });\n      this.diagram.updateDiagramObject(obj);\n    }\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.updateSelectedNodeProperties = function (object) {\n    if (this.diagram.lineRoutingModule && this.diagram.constraints & DiagramConstraints.LineRouting) {\n      var previousNodeObject = [];\n      var previousConnectorObject = [];\n      var updateNodeObject = [];\n      var updateConnectorObject = [];\n      var changeNodes = [];\n      var changeConnectors = [];\n      this.diagram.protectPropertyChange(true);\n      var objects = [];\n      var connectors = [];\n      var actualObject = this.diagram.selectedObject.actualObject;\n      var helperObject = this.diagram.selectedObject.helperObject;\n\n      if (helperObject && actualObject) {\n        var offsetX = helperObject.offsetX - actualObject.offsetX;\n        var offsetY = helperObject.offsetY - actualObject.offsetY;\n        var width = helperObject.width - actualObject.width;\n        var height = helperObject.height - actualObject.height;\n        var rotateAngle = helperObject.rotateAngle - actualObject.rotateAngle;\n\n        if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 0) {\n          this.diagram.selectedItems.wrapper.rotateAngle = this.diagram.selectedItems.rotateAngle = helperObject.rotateAngle;\n        }\n\n        if (actualObject instanceof Node && actualObject.shape.type !== 'SwimLane' && !actualObject.isLane && !actualObject.isPhase && !actualObject.isHeader) {\n          if (actualObject.offsetX !== actualObject.wrapper.offsetX || actualObject.offsetY !== actualObject.wrapper.offsetY || actualObject.width !== actualObject.wrapper.width || actualObject.height !== actualObject.wrapper.height || actualObject.rotateAngle !== actualObject.wrapper.rotateAngle) {\n            if (isBlazor()) {\n              previousNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n            }\n\n            actualObject.offsetX += offsetX;\n            actualObject.offsetY += offsetY;\n            actualObject.width += width;\n            actualObject.height += height;\n            actualObject.rotateAngle += rotateAngle;\n            this.diagram.nodePropertyChange(actualObject, {}, {\n              offsetX: actualObject.offsetX,\n              offsetY: actualObject.offsetY,\n              width: actualObject.width,\n              height: actualObject.height,\n              rotateAngle: actualObject.rotateAngle\n            });\n\n            if (isBlazor()) {\n              updateNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n            }\n          }\n\n          objects = this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds);\n        } else if (actualObject instanceof Selector) {\n          for (var i = 0; i < actualObject.nodes.length; i++) {\n            var node = actualObject.nodes[i];\n\n            if (node instanceof Node && node.shape.type !== 'SwimLane' && !node.isLane && !node.isPhase && !node.isHeader) {\n              node.offsetX += offsetX;\n              node.offsetY += offsetY;\n              node.width += width;\n              node.height += height;\n              node.rotateAngle += rotateAngle;\n              this.diagram.nodePropertyChange(node, {}, {\n                offsetX: node.offsetX,\n                offsetY: node.offsetY,\n                width: node.width,\n                height: node.height,\n                rotateAngle: node.rotateAngle\n              });\n              objects = objects.concat(this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds));\n            }\n          }\n        }\n      } else {\n        if (object instanceof Connector) {\n          objects.push(object);\n        } else if (object instanceof Selector && object.connectors.length) {\n          objects = objects.concat(object.connectors);\n        }\n      }\n\n      for (var i = 0; i < objects.length; i++) {\n        if (objects[i] instanceof Connector && connectors.indexOf(objects[i].id) === -1) {\n          connectors.push(objects[i].id);\n        }\n      }\n\n      this.diagram.lineRoutingModule.renderVirtualRegion(this.diagram, true);\n\n      for (var i = 0; i < connectors.length; i++) {\n        var connector = this.diagram.nameTable[connectors[i]];\n\n        if (connector instanceof Connector && connector.type === 'Orthogonal') {\n          if (isBlazor()) {\n            previousConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n          }\n\n          this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, true);\n\n          if (isBlazor()) {\n            updateConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n          }\n        }\n      }\n\n      this.updateSelector();\n\n      if (isBlazor()) {\n        this.getObjectChanges(previousNodeObject, updateNodeObject, changeNodes);\n        this.getObjectChanges(previousConnectorObject, updateConnectorObject, changeConnectors);\n        var blazorInterop = 'sfBlazor';\n        var blazor = 'Blazor';\n        var diagramObject = {\n          nodes: changeNodes,\n          connectors: changeConnectors\n        };\n\n        if (window && window[blazor] && changeConnectors.length + changeNodes.length) {\n          var obj = {\n            'methodName': 'UpdateBlazorProperties',\n            'diagramobj': diagramObject\n          };\n          window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n        }\n      }\n\n      this.diagram.protectPropertyChange(false);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.drawSelectionRectangle = function (x, y, width, height) {\n    this.diagram.drawSelectionRectangle(x, y, width, height);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.startGroupAction = function () {\n    this.diagram.startGroupAction();\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.endGroupAction = function () {\n    this.diagram.endGroupAction();\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.removeChildFromBPmn = function (child, newTarget, oldTarget) {\n    var obj = this.diagram.nameTable[child.id] || child.nodes[0];\n\n    if (oldTarget) {\n      if (obj && obj.processId && obj.processId === oldTarget.wrapper.id) {\n        var node = clone(obj);\n        node.processId = obj.processId;\n        this.diagram.startGroupAction();\n        var edges = [];\n        edges = edges.concat(obj.outEdges, obj.inEdges);\n\n        for (var i = edges.length - 1; i >= 0; i--) {\n          var connector = this.diagram.nameTable[edges[i]];\n\n          if (connector) {\n            this.diagram.remove(connector);\n          }\n        } //let nodeCollection: string[];\n\n\n        var nodeCollection = this.diagram.nameTable[obj.processId].shape.activity.subProcess.processes || [];\n        nodeCollection.splice(nodeCollection.indexOf(obj.id), 1);\n        this.diagram.bpmnModule.removeChildFromBPMN(this.diagram.nameTable[obj.processId].wrapper, obj.id);\n        this.diagram.nameTable[obj.id].processId = '';\n        obj.offsetX = obj.wrapper.offsetX;\n        obj.offsetY = obj.wrapper.offsetY;\n        var undoElement = clone(obj);\n        var entry = {\n          type: 'PositionChanged',\n          redoObject: {\n            nodes: [undoElement]\n          },\n          undoObject: {\n            nodes: [node]\n          },\n          category: 'Internal'\n        };\n        this.addHistoryEntry(entry);\n        this.diagram.endGroupAction();\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.isDroppable = function (source, targetNodes) {\n    var node = this.diagram.nameTable[source.id] || source.nodes[0];\n\n    if (node) {\n      if (!isBlazor() && node.shape.shape === 'TextAnnotation' || isBlazor() && node.shape.bpmnShape === 'TextAnnotation') {\n        return true;\n      }\n\n      if (node && node.shape.type === 'Bpmn') {\n        if (node.processId === targetNodes.id || node.id === targetNodes.processId || targetNodes.shape.type === 'Bpmn' && targetNodes.shape.activity.subProcess.collapsed) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n\n    return false;\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.renderHighlighter = function (args, connectHighlighter, source) {\n    var bounds = new Rect();\n\n    if (args.target instanceof Node || connectHighlighter && args.source instanceof Node) {\n      var tgt = connectHighlighter ? args.source : args.target;\n      var tgtWrap = connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n      var target = this.findTarget(tgtWrap, tgt, source, true);\n      var element = void 0;\n\n      if (target instanceof BpmnSubEvent) {\n        var portId = target.id;\n        var node = args.target;\n        var parent_6 = node.wrapper.children[0].children[0].children[2];\n\n        for (var _i = 0, _a = parent_6.children; _i < _a.length; _i++) {\n          var child = _a[_i];\n\n          if (child.id === node.id + '_' + portId) {\n            element = child.children[0];\n            break;\n          }\n        }\n      } else {\n        element = target instanceof Node ? target.wrapper : connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n      }\n\n      this.diagram.renderHighlighter(element);\n    }\n  }; //additional events\n\n  /** @private */\n\n\n  CommandHandler.prototype.mouseOver = function (source, target, position) {\n    //mouse over\n    //returns whether the source can move over the target or not\n    return true;\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.snapPoint = function (startPoint, endPoint, tx, ty) {\n    var obj = this.diagram.selectedItems;\n    var point;\n    var towardsLeft = endPoint.x < startPoint.x;\n    var towardsTop = endPoint.y < startPoint.y;\n    point = {\n      x: tx,\n      y: ty\n    };\n    var snappedPoint = point;\n\n    if (this.snappingModule) {\n      snappedPoint = this.diagram.snappingModule.snapPoint(this.diagram, obj, towardsLeft, towardsTop, point, startPoint, endPoint);\n    }\n\n    return snappedPoint;\n  };\n  /**\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeSnap = function () {\n    if (this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject && this.snappingModule) {\n      this.snappingModule.removeGuidelines(this.diagram);\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.dropAnnotation = function (source, target) {\n    var node = source instanceof Node ? source : source.nodes[0];\n\n    if (this.diagram.bpmnModule && target.shape.type === 'Bpmn' && (!isBlazor() && node.shape.shape === 'TextAnnotation' || isBlazor() && node.shape.bpmnShape === 'TextAnnotation')) {\n      var hasTarget = 'hasTarget';\n      node[hasTarget] = target.id;\n      node.shape.annotation.nodeId = target.id;\n\n      if (!this.diagram.currentSymbol) {\n        this.diagram.addTextAnnotation(node.shape.annotation, target);\n        node.shape.annotation.nodeId = '';\n        this.diagram.remove(node);\n      }\n\n      this.diagram.refreshDiagramLayer();\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.drop = function (source, target, position) {\n    //drop\n    if (this.diagram.bpmnModule) {\n      var sourcenode = source instanceof Node ? source : source.nodes[0];\n\n      if (sourcenode && sourcenode.shape.type === 'Bpmn' && target.shape.type === 'Bpmn') {\n        this.diagram.bpmnModule.dropBPMNchild(target, source instanceof Node ? source : source.nodes[0], this.diagram);\n        this.diagram.refreshDiagramLayer();\n      }\n    }\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.addHistoryEntry = function (entry) {\n    this.diagram.addHistoryEntry(entry);\n  };\n  /** @private */\n\n\n  CommandHandler.prototype.align = function (objects, option, type) {\n    if (objects.length > 0) {\n      var i = 0;\n      objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n      var bounds = type === 'Object' ? getBounds(objects[0].wrapper) : this.diagram.selectedItems.wrapper.bounds;\n      var undoObj = {\n        nodes: [],\n        connectors: []\n      };\n      var redoObj = {\n        nodes: [],\n        connectors: []\n      };\n\n      for (i = type === 'Object' ? i + 1 : i; i < objects.length; i++) {\n        var tx = 0;\n        var ty = 0;\n        objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n        var objectBounds = getBounds(objects[i].wrapper);\n\n        if (option === 'Left') {\n          tx = bounds.left + objectBounds.width / 2 - objectBounds.center.x;\n        } else if (option === 'Right') {\n          tx = bounds.right - objectBounds.width / 2 - objectBounds.center.x;\n        } else if (option === 'Top') {\n          ty = bounds.top + objectBounds.height / 2 - objectBounds.center.y;\n        } else if (option === 'Bottom') {\n          ty = bounds.bottom - objectBounds.height / 2 - objectBounds.center.y;\n        } else if (option === 'Center') {\n          tx = bounds.center.x - objectBounds.center.x;\n        } else if (option === 'Middle') {\n          ty = bounds.center.y - objectBounds.center.y;\n        }\n\n        undoObj = this.storeObject(undoObj, objects[i]);\n        this.drag(objects[i], tx, ty);\n        this.diagram.updateSelector();\n        redoObj = this.storeObject(redoObj, objects[i]);\n      }\n\n      undoObj = clone(undoObj);\n      redoObj = clone(redoObj);\n      var entry = {\n        type: 'Align',\n        category: 'Internal',\n        undoObject: cloneObject(undoObj),\n        redoObject: cloneObject(redoObj)\n      };\n      this.addHistoryEntry(entry);\n    }\n  };\n  /**\n   * distribute method \\\n   *\n   * @returns { void }     distribute method .\\\n   * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n   * @param {SizingOptions} option - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.distribute = function (objects, option) {\n    if (objects.length > 0) {\n      var i = 0; //const j: number = 0;\n      //const rect: Rect = new Rect();\n      //const b: Rect[] = [];\n      //let temp: NodeModel | ConnectorModel;\n\n      var right = 0;\n      var left = 0;\n      var top_3 = 0;\n      var bottom = 0;\n      var center = 0;\n      var middle = 0;\n      var btt = 0; //const sum: number = 0;\n\n      var undoSelectorObj = {\n        nodes: [],\n        connectors: []\n      };\n      var redoSelectorObj = {\n        nodes: [],\n        connectors: []\n      };\n\n      for (i = 0; i < objects.length; i++) {\n        objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n      }\n\n      objects = sort(objects, option);\n\n      for (i = 1; i < objects.length; i++) {\n        right = right + objects[i].wrapper.bounds.topRight.x - objects[i - 1].wrapper.bounds.topRight.x;\n        left = left + objects[i].wrapper.bounds.topLeft.x - objects[i - 1].wrapper.bounds.topLeft.x;\n        top_3 = top_3 + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.topRight.y;\n        bottom = bottom + objects[i].wrapper.bounds.bottomRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n        center = center + objects[i].wrapper.bounds.center.x - objects[i - 1].wrapper.bounds.center.x;\n        middle = middle + objects[i].wrapper.bounds.center.y - objects[i - 1].wrapper.bounds.center.y;\n        btt = btt + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n      }\n\n      for (i = 1; i < objects.length - 1; i++) {\n        var tx = 0;\n        var ty = 0;\n        var prev = getBounds(objects[i - 1].wrapper);\n        var current = getBounds(objects[i].wrapper);\n\n        if (option === 'RightToLeft' || option === 'Center') {\n          tx = prev.center.x - current.center.x + center / (objects.length - 1);\n        } else if (option === 'Right') {\n          tx = prev.topRight.x - current.topRight.x + right / (objects.length - 1);\n        } else if (option === 'Left') {\n          tx = prev.topLeft.x - current.topLeft.x + left / (objects.length - 1);\n        } else if (option === 'Middle') {\n          ty = prev.center.y - current.center.y + middle / (objects.length - 1);\n        } else if (option === 'Top') {\n          ty = prev.topRight.y - current.topRight.y + top_3 / (objects.length - 1);\n        } else if (option === 'Bottom') {\n          ty = prev.bottomRight.y - current.bottomRight.y + bottom / (objects.length - 1);\n        } else if (option === 'BottomToTop') {\n          ty = prev.bottomRight.y - current.topRight.y + btt / (objects.length - 1);\n        }\n\n        undoSelectorObj = this.storeObject(undoSelectorObj, objects[i]);\n        this.drag(objects[i], tx, ty);\n        this.diagram.updateSelector();\n        redoSelectorObj = this.storeObject(redoSelectorObj, objects[i]);\n      }\n\n      undoSelectorObj = clone(undoSelectorObj);\n      redoSelectorObj = clone(redoSelectorObj);\n      var entry = {\n        type: 'Distribute',\n        category: 'Internal',\n        undoObject: cloneObject(undoSelectorObj),\n        redoObject: cloneObject(redoSelectorObj)\n      };\n      this.addHistoryEntry(entry);\n    }\n  };\n  /* eslint-enable */\n\n  /**\n   * sameSize method \\\n   *\n   * @returns { void }     sameSize method .\\\n   * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n   * @param {SizingOptions} option - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.sameSize = function (objects, option) {\n    if (objects.length > 0) {\n      var i = 0; //let pivot: PointModel;\n\n      var pivot = {\n        x: 0.5,\n        y: 0.5\n      };\n      objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n      var bounds = getBounds(objects[0].wrapper);\n      var undoObject = {\n        nodes: [],\n        connectors: []\n      };\n      var redoObject = {\n        nodes: [],\n        connectors: []\n      };\n\n      for (i = 1; i < objects.length; i++) {\n        objects[i] = this.diagram.nameTable[objects[i].id] || objects[0];\n        var rect = getBounds(objects[i].wrapper);\n        var sw = 1;\n        var sh = 1;\n\n        if (option === 'Width') {\n          sw = bounds.width / rect.width;\n        } else if (option === 'Height') {\n          sh = bounds.height / rect.height;\n        } else if (option === 'Size') {\n          sw = bounds.width / rect.width;\n          sh = bounds.height / rect.height;\n        }\n\n        undoObject = this.storeObject(undoObject, objects[i]);\n        this.scale(objects[i], sw, sh, pivot);\n        redoObject = this.storeObject(redoObject, objects[i]);\n      }\n\n      this.diagram.updateSelector();\n      undoObject = clone(undoObject);\n      redoObject = clone(redoObject);\n      var entry = {\n        type: 'Sizing',\n        category: 'Internal',\n        undoObject: cloneObject(undoObject),\n        redoObject: cloneObject(redoObject)\n      };\n      this.addHistoryEntry(entry);\n    }\n  };\n\n  CommandHandler.prototype.storeObject = function (selectorObject, obj) {\n    if (obj instanceof Node) {\n      selectorObject.nodes.push(clone(obj));\n    } else {\n      selectorObject.connectors.push(clone(obj));\n    }\n\n    return selectorObject;\n  };\n  /**\n   * updatePanState method \\\n   *\n   * @returns { any }     updatePanState method .\\\n   * @param {number} eventCheck - provide the eventCheck value.\n   *\n   * @private\n   */\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n  CommandHandler.prototype.updatePanState = function (eventCheck) {\n    if (eventCheck) {\n      this.diagram.realActions = this.diagram.realActions | RealAction.PanInProgress;\n    } else {\n      this.diagram.dataBind();\n      var diagramScrollSettings = this.diagram.scrollSettings;\n      this.diagram.realActions = this.diagram.realActions & ~RealAction.PanInProgress;\n      var Values = {\n        VerticalOffset: diagramScrollSettings.verticalOffset,\n        HorizontalOffset: diagramScrollSettings.horizontalOffset,\n        ViewportHeight: diagramScrollSettings.viewPortHeight,\n        ViewportWidth: diagramScrollSettings.viewPortWidth,\n        CurrentZoom: diagramScrollSettings.currentZoom\n      };\n      var arg = {\n        oldValue: Values,\n        newValue: Values,\n        source: this.diagram,\n        panState: 'Completed'\n      };\n      this.triggerEvent(DiagramEvent.scrollChange, arg);\n    }\n  };\n  /**\n   * dataBinding method \\\n   *\n   * @returns { void }     dataBinding method .\\\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dataBinding = function () {\n    this.diagram.dataBind();\n  };\n\n  CommandHandler.prototype.setBlazorDiagramProps = function (arg) {\n    this.diagram.setBlazorDiagramProps(arg);\n  };\n  /**\n   * scroll method \\\n   *\n   * @returns { void }     scroll method .\\\n   * @param {number} scrollX - provide the source value.\n   * @param {number} scrollY - provide the target value.\n   * @param {PointModel} focusPoint - provide the layoutOrientation value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.scroll = function (scrollX, scrollY, focusPoint) {\n    var panx = canPanX(this.diagram);\n    var pany = canPanY(this.diagram);\n\n    if (isBlazor()) {\n      this.diagram.setCursor('grabbing');\n      this.diagram.scroller.zoom(1, (scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n    } else {\n      this.diagram.pan((scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n    }\n  };\n  /**\n   * drawHighlighter method \\\n   *\n   * @returns { NodeModel | ConnectorModel }     drawHighlighter method .\\\n   * @param {IElement} element - provide the element value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.drawHighlighter = function (element) {\n    this.diagram.renderHighlighter(element.wrapper);\n  };\n  /**\n   * removeHighlighter method \\\n   *\n   * @returns { void }     removeHighlighter method .\\\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.removeHighlighter = function () {\n    this.diagram.clearHighlighter();\n  };\n  /**\n   * renderContainerHelper method \\\n   *\n   * @returns { NodeModel | ConnectorModel }     renderContainerHelper method .\\\n   * @param {NodeModel | SelectorModel | ConnectorModel} node - provide the parent value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.renderContainerHelper = function (node) {\n    return renderContainerHelper(this.diagram, node);\n  };\n  /**\n   * isParentAsContainer method \\\n   *\n   * @returns { boolean }     isParentAsContainer method .\\\n   * @param {NodeModel} node - provide the parent value.\n   * @param {boolean} isChild - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.isParentAsContainer = function (node, isChild) {\n    return checkParentAsContainer(this.diagram, node, isChild);\n  };\n  /**\n   * dropChildToContainer method \\\n   *\n   * @returns { void }     dropChildToContainer method .\\\n   * @param {NodeModel} parent - provide the parent value.\n   * @param {NodeModel} node - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.dropChildToContainer = function (parent, node) {\n    if (!(this.diagram.diagramActions & DiagramAction.PreventLaneContainerUpdate)) {\n      addChildToContainer(this.diagram, parent, node);\n    }\n  };\n  /**\n  *\n  * @private\n  */\n\n\n  CommandHandler.prototype.updateLaneChildrenZindex = function (node, target) {\n    var lowerIndexobject = this.findLeastIndexObject(node, target);\n    var swimlane = this.diagram.nameTable[target.parentId];\n\n    if (swimlane.zIndex > lowerIndexobject.zIndex) {\n      var layerIndex = this.diagram.layers.indexOf(this.diagram.getActiveLayer());\n      var layerZIndexTable = this.diagram.layers[layerIndex].zIndexTable;\n      var startIndex = lowerIndexobject.zIndex;\n      var endIndex = swimlane.zIndex;\n\n      for (var i = endIndex; i >= startIndex; i--) {\n        if (startIndex !== i) {\n          if (!layerZIndexTable[i - 1]) {\n            layerZIndexTable[i - 1] = layerZIndexTable[i];\n            this.diagram.nameTable[layerZIndexTable[i - 1]].zIndex = i;\n            delete layerZIndexTable[i];\n          } else {\n            //bringing the objects forward\n            layerZIndexTable[i] = layerZIndexTable[i - 1];\n            this.diagram.nameTable[layerZIndexTable[i]].zIndex = i;\n          }\n        } else {\n          layerZIndexTable[i] = swimlane.id;\n          this.diagram.nameTable[swimlane.id].zIndex = i;\n        }\n      }\n\n      if (this.diagram.mode === 'SVG') {\n        this.moveSvgNode(target.parentId, lowerIndexobject.id);\n        this.updateNativeNodeIndex(target.parentId, lowerIndexobject.id);\n      } else {\n        this.diagram.refreshCanvasLayers();\n      }\n    }\n  };\n\n  CommandHandler.prototype.findLeastIndexConnector = function (edges, target, index) {\n    for (var i = 0; i < edges.length; i++) {\n      var connector = this.diagram.nameTable[edges[i]];\n\n      if (index.zIndex > connector.zIndex) {\n        index = connector;\n      }\n    }\n\n    return index;\n  };\n\n  CommandHandler.prototype.findLeastIndexObject = function (node, target) {\n    var lowerIndexobject = node;\n\n    if (node instanceof Node) {\n      lowerIndexobject = this.findLeastIndexConnector(node.inEdges, target, lowerIndexobject);\n      lowerIndexobject = this.findLeastIndexConnector(node.outEdges, target, lowerIndexobject);\n    }\n\n    return lowerIndexobject;\n  };\n  /**\n   * checkSelection method \\\n   *\n   * @returns { void }     checkSelection method .\\\n   * @param {SelectorModel} selector - provide the source value.\n   * @param {string} corner - provide the target value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.checkSelection = function (selector, corner) {\n    var node; // let wrapper: GridPanel; let child: Container; let index: number; let shape: SwimLaneModel;\n\n    if (selector.nodes.length === 1 && selector.connectors.length === 0) {\n      if (checkParentAsContainer(this.diagram, selector.nodes[0], true)) {\n        node = selector.nodes[0].shape === 'SwimLane' ? selector.nodes[0] : this.diagram.nameTable[selector.nodes[0].parentId];\n        var child = selector.nodes[0];\n\n        if (node.shape.type === 'SwimLane') {\n          var orientation_1 = node.shape.orientation === 'Horizontal' ? true : false;\n\n          if (child.isPhase && (orientation_1 && corner === 'ResizeSouth' || !orientation_1 && corner === 'ResizeEast') || child.isLane && (orientation_1 && corner === 'ResizeEast' || !orientation_1 && corner === 'ResizeSouth')) {\n            swimLaneSelection(this.diagram, node, corner);\n          }\n        } else if (node.container.type === 'Grid') {\n          if (node.container.orientation === 'Horizontal' && child.rowIndex === 1 || node.container.orientation === 'Vertical' && child.rowIndex > 0 && child.columnIndex > 0) {\n            if (corner === 'ResizeSouth') {\n              for (var i = 0; i < this.diagram.nodes.length; i++) {\n                var obj = this.diagram.nodes[i];\n\n                if (obj.rowIndex === node.rows.length - 1 && obj.columnIndex === 0) {\n                  this.select(obj);\n                  break;\n                }\n              }\n            }\n          } else {\n            if (corner === 'ResizeEast') {\n              for (var i = 0; i < this.diagram.nodes.length; i++) {\n                var obj = this.diagram.nodes[i];\n\n                if (obj.rowIndex === 1 && obj.columnIndex === node.columns.length - 1) {\n                  this.select(obj);\n                  break;\n                }\n              }\n            }\n          }\n        }\n      } else {\n        swimLaneSelection(this.diagram, selector.nodes[0], corner);\n      }\n    }\n  };\n  /**\n   * zoom method \\\n   *\n   * @returns { void }     zoom method .\\\n   * @param {number} scale - provide the source value.\n   * @param {number} scrollX - provide the target value.\n   * @param {number} scrollY - provide the layoutOrientation value.\n   * @param {PointModel} focusPoint - provide the layoutOrientation value.\n   *\n   * @private\n   */\n\n\n  CommandHandler.prototype.zoom = function (scale, scrollX, scrollY, focusPoint) {\n    this.diagram.scroller.zoom(scale, scrollX * this.diagram.scroller.currentZoom, scrollY * this.diagram.scroller.currentZoom, focusPoint);\n  };\n\n  return CommandHandler;\n}();\n\nexport { CommandHandler };","map":{"version":3,"sources":["/Users/sergeismogliuk/Documents/Project/Project_node/Diplom/react-diplom/react-diplom/node_modules/@syncfusion/ej2-diagrams/src/diagram/interaction/command-manager.js"],"names":["__awaiter","thisArg","_arguments","P","generator","Promise","resolve","reject","fulfilled","value","step","next","e","rejected","result","done","then","apply","__generator","body","_","label","sent","t","trys","ops","f","y","g","verb","Symbol","iterator","n","v","op","TypeError","call","pop","length","push","Connector","getBezierPoints","isEmptyVector","Node","BpmnSubEvent","BpmnAnnotation","PathElement","TextElement","OrthogonalSegment","Rect","Diagram","identityMatrix","rotateMatrix","transformPointByMatrix","scaleMatrix","cloneObject","clone","getBounds","getFunction","getIndex","completeRegion","sort","findObjectIndex","intersect3","getAnnotationPosition","updatePathElement","cloneBlazorObject","getUserHandlePosition","cloneSelectedObjects","updateDefaultValues","randomId","cornersPointsBeforeRotation","Selector","hasSelection","isSelected","hasSingleConnection","contains","DiagramEvent","BlazorAction","canSelect","canMove","canRotate","canDragSourceEnd","canDragTargetEnd","canSingleSelect","canDrag","canMultiSelect","canContinuousDraw","canPanX","canPanY","canPageEditable","SnapConstraints","DiagramTools","DiagramAction","RealAction","getDiagramElement","getAdornerLayerSvg","getHTMLLayer","getAdornerLayer","Point","Size","getObjectType","getPoint","intersect2","getOffsetOfConnector","canShowCorner","Layer","SelectorConstraints","DiagramConstraints","remove","isBlazor","isNullOrUndefined","getOppositeDirection","getPortDirection","findAngle","swapBounds","findPoint","orthoConnection2Segment","getIntersection","ShapeAnnotation","PathAnnotation","renderContainerHelper","checkChildNodeInContainer","checkParentAsContainer","addChildToContainer","renderStackHighlighter","getConnectors","updateConnectorsProperties","canLaneInterchange","findLane","swimLaneSelection","pasteSwimLane","gridSelection","DeepDiffMapper","CommandHandler","diagram","clipboardData","diagramObject","newSelectedObjects","oldSelectedObjects","connectorsTable","processTable","deepDiffer","isContainer","childTable","parentTable","blazor","blazorInterop","cloneGroupChildCollection","Object","defineProperty","prototype","get","snappingModule","enumerable","configurable","layoutAnimateModule","startTransaction","protectChange","state","element","selectedItems","backup","protectPropertyChange","id","style","pointerEvents","endTransaction","setFocus","document","getElementById","focus","showTooltip","node","position","content","toolName","isTooltipVisible","_this","targetId","targetEle","nodes","connectors","tooltipObject","animation","open","delay","duration","openDelay","closeDelay","setTooltipTemplate","template","HTMLElement","cloneNode","close","tooltip","openOn","offsetX","offsetY","updateTooltip","refresh","setTimeout","closeTooltip","canEnableDefaultTooltip","constraints","ToolTip","updateSelector","updateConnectorValue","args","cancel","enableCloneObject","ismouseEvents","insertBlazorObject","connector","newChanges","oldChanges","nameTable","nodeEndId","connectorEnd","portEndId","connectionEnd","newValue","connectorTargetValue","connectorSourceValue","oldValue","nodeId","portId","sourceID","sourcePortID","connectorPropertyChange","targetPortID","targetID","triggerEvent","event","temparg","_a","drop","positionChange","connectionChange","currentSymbol","source","currentDrawingObject","dragOverElement","currentPosition","dragOverArg","target","mousePosition","dragOver","disConnect","obj","endPoint","canCancel","checkBlazor","returnargs","selectorModel","insertValue","connectionEventChange","arg","updateDiagramObject","connectedNode","nodeObject","undefined","object","isNode","i","getObject","updatePropertiesToBlazor","labelDrag","getBlazorOldValues","updateBlazorSelector","insertSelectedObjects","findTarget","argsTarget","connection","shape","type","bpmnShape","activity","subProcess","transaction","success","visible","indexOf","failure","ports","port","annotation","annotations","canDisconnect","targetPortId","targetNodeId","selector","connect","targetObject","targetWrapper","nodeEnd","portEnd","changeAnnotationDrag","bpmnModule","textAnnotationConnectors","split","annotationId","startGroupAction","parentNode","clonedNode","getAnnotation","annotationNode","angle","intermediatePoints","text","distancePoints","annotationObj","checkAndRemoveAnnotations","refreshCanvasLayers","addTextAnnotation","endGroupAction","oldNodeId","oldPortId","sourceWrapper","actualObject","renderHighlighter","cut","index","pasteIndex","undoRedoModule","historyManager","clipObject","copyObjects","mode","refreshDiagramLayer","UpdateBlazorDiagramModelLayers","layer","isRemove","updatedModel","window","JSON","stringify","isLoading","updateBlazorProperties","addLayer","objects","isServerUpdate","zIndex","layers","isEnableServerDatabind","allowServerDataBinding","enableServerDataBinding","objectZIndex","zIndexTable","layerZIndexTable","activeLayer","add","getObjectLayer","objectName","objIndex","getLayer","layerName","removeLayer","layerId","layerObject","unSelect","splice","moveObjects","targetLayer","setActiveLayer","targerNodes","_i","objects_1","layer_1","cloneLayer","cloneObject_1","newlayer","lock","multiSelect","paste","copy","j","concat","isPhase","wrapper","copyProcesses","matrix","rotateAngle","children","tempNode","elements","getAllDescendants","clonedObject","newOffset","x","swimlane","connectorsList","isLane","parentId","lane","width","actualSize","selectedItems_1","item","sortByZIndex","processes","processes_1","group","propName","protectedChange","diagramActions","Group","select","entry","undoObject","redoObject","category","addHistoryEntry","unGroup","childCollection","k","removePorts","removeLabels","deleteChild","addChild","resetDependentConnectors","inEdges","outEdges","UndoRedo","removeNode","clearSelection","edges","isInEdges","newConnector","newProp","copiedItems","getNewObject","groupAction","objectTable","keyTable","copiedItems_1","copiedObject","clonedObj","newObj","cloneConnector","newNode","edges_1","edge","_b","edges_2","UpdateBlazorDiagramModelCollection","newobjs","translateObject","selectObjects","groupnodeID","process","temp","cloneGroup","checkAnnotation","keys","cloneSubProcesses","parent","currentAnnotation","child","_c","innerChild","processId","addProcess","_d","connector_1","node_1","connectorTable","newChildren","connectorObj","oldID","objectCollection","blazorActions","GroupClipboardInProcess","childObj","parentObj","container","measure","diff","sourcePoint","targetPoint","segments","isEmptyPoint","point1","point2","point","drawObject","oldProtectPropertyChangeValue","getProtectPropertyChangeValue","drawingObject","height","prop","nodeDefaults","connectorDefaults","initObject","addObjectToDiagram","removeFromAQuad","removeObjectsFromLayer","tool","DrawOnce","enable","addText","findElementUnderMouse","startTextEdit","updateArgsObject","arg1","argValue","connectorCollection","nodeCollection","updateSelectionChangeEventArgs","cause","argOldValue","argNewValue","getSelectedObject","isUserHandle","handle","userHandles","paddedBounds","scroller","transform","size","scale","multipleSelection","canDoMultipleSelection","canDoSingleSelection","i_1","blazorArgs","eventObj","selectedObjects","selectionChange","findParent","selectGroup","selectProcesses","selectBpmnSubProcesses","renderSelector","updateBlazorSelectorModel","updateBlazorDiagramEvents","map","diffValue","frameObject","removeEmptyValues","hasProcesses","preventUpdate","hasLayer","convert","isHeader","init","pivot","getObjectCollectionId","selectedObject","oldItemsCollection","oldItems","items","newItems","updateDiagramCollection","labelSelect","textWrapper","objArray","selectormodel","getChildElements","childNode","moveSvgNode","diagramDiv","backNode","insertBefore","sendLayerBackward","currentLayerObject","currentLayerObject_1","bringLayerForward","targetLayerObjects","targetLayerObjects_1","sendToBack","objectId","layerNum","checkObjectBehind","resetTargetNode","checkParentExist","updateNativeNodeIndex","getZIndexObjects","updateBlazorZIndex","diagramobject","connectorObject","elementObject","getBlazorObject","sfIndex","objBehind","z","bringToFront","objectName_1","zIndexTable_1","tabelLength","Number","a","b","reverse","oldzIndexTable_1","diagramLayer","removeChild","views","lastChildNode","lastChild","nextSibling","htmlLayer","diagramRenderer","renderElement","forEach","key","zIndexValue","objectNode","zIndexNode","checkGroupNode","selectedNodeName","nodeArray","sortID","orderCommands","isRedo","action","sendBackward","sendForward","startZIndex","endZIndex","layerIndex","undoObject_1","layer_2","moveObject","layer_3","sourceId","intersectArray","spatialSearch","findObjects","bounds","temp_1","currentLayer","intersects","overlapObject","currentObject","temp_2","redo","historyEntry","temp_3","temp_4","tempChild","tempParent","checkChild","parentElement","firstChild","initSelectorWrapper","doRubberBandSelection","region","clearSelectionRectangle","selArray","rubberArray","getNodesConnectors","rubberBandSelectionMode","adornerSvg","dragConnectorEnds","segment","tx","ty","checkBezierThumb","bezierPoint1","dragSourceEnd","bezierPoint2","dragTargetEnd","isObjectInteraction","newNodeObject","newConnectorObject","oldNodeObjects","oldConnectorObjects","lineRoutingModule","LineRouting","canEnableBlazorObject","addConstraints","interaction","removeConstraints","updateLayerObject","oldDiagram","diffLayers","getLayerObject","getDiagramOldValues","attribute","newDiagram","newObject","changeSegments","ClearObject","oldNodeObject","getDifferenceValues","oldConnectorObject","getObjectChanges","previousObject","changedNodes","change","clearObjectSelection","mouseDownElement","list","triggerAction","isTriggered","arrayNodes","blazarArgs","selectNodes","previousSelectedObject","clearSelectorLayer","clearSelectedItems","selectedNodes","selectedConnectors","removeStackHighlighter","highlighter","symbolDrag","findObjectsUnderMouse","findObjectUnderMouse","laneNode","parentObject","canvas","node_2","orientation","isVertical","rowIndex","columnIndex","insertBlazorConnector","drag","checkBoundaryConstraints","oldValues","isGroupDragging","updateInnerParentProperties","measureChildren","nodePropertyChange","grid","update","hasEnds","canDragPoints","dragControlPoint","conn","connectorSegmentChange","existingInnerBounds","isRotate","segmentChange","equals","direction","bottomCenter","topCenter","middleLeft","middleRight","firstSegment","secondSegment","cornerPoints","corners","margin","points","updateEndPoint","isDragSource","changeSegmentLength","sequence","updatePathElementOffset","translateBezierPoints","realActions","AnimationClick","pathElement","anglePoints","first","second","secPoint","nextDirection","changeSourceEndToNode","changeSourceEndToPort","getWrapper","segValues","segValues1","isTerminal","Math","abs","removeTerminalSegment","changeTerminal","sourcePoint2","nextSegment","seg","vector1","distance","vector2","boundaryConstraints","prev","segmentNumber","rotatePropertyChnage","pivotValue","rotateObjects","includeParent","objects_2","parent_1","bound","getChildrenBound","updateSubProcessess","getChildren","rotatePoints","snapConnectorEnd","snapSettings","SnapToLines","snapAngle","protect","innerParents","sw","sh","refObject","isOutsideBoundary","refWrapper","refPoint","nodes_1","scaleObject","arrange","desiredSize","updateGroupOffset","innerParent","parentNodes","cloneChild","isResize","top","left","containsRect","maxWidth","min","minWidth","max","maxHeight","minHeight","right","bottom","newPosition","oldleft","oldtop","parent_2","parent_3","top_1","parent_4","oldValues_1","scaleConnector","parent_5","portDrag","portElement","changedvalues","getPortChanges","offset","textElement","getAnnotationChanges","updatePathAnnotationOffset","alignment","pointLength","totalLength","intersectingOffset","intersetingPts","getInterceptWithSegment","getLengthFromListOfPoints","dragLimit","minDistance","getRelativeOffset","connectorOffset","p","toBounds","containsPoint","findLength","updateLabelMargin","pt","round","sqrt","pow","dragLimitValue","tempPt","contentDimension","length_1","getPointAtLength","curZoomfactor","scrollSettings","currentZoom","labelBounds","annotationWrtapper","draggableBounds","lineIntersects","line1","boundsInterSects","lineIntersects_1","ptt","cursorLimit","polyLine","self","polyLine2","intersect","polyLine1","run","pre","found","l","r","deg","cos","PI","sin","conPoints","intercepts","imgLine","segemnt","tarAngle","srcAngle","maxLength","viewPortWidth","viewPortHeight","angleAdd","lineUtil1","x1","y1","x2","y2","lineUtil2","line3","enabled","intersectPt","horizontalAlignment","verticalAlignment","labelRotate","labelWrapper","segmentAngle","getPointloop","parentTransform","labelResize","deltaWidth","deltaHeight","newMat","offsetx","offsety","getSubProcess","nodeBounds","pageSettings","selectorBounds","top_2","dragSelectedObjects","PreventZIndexOnDragging","DragUsingMouse","scaleSelectedItems","sx","sy","rotateSelectedItems","rotate","initExpand","isExpanded","preventNodesUpdate","PreventIconsUpdate","view","refreshCanvasDiagramLayer","expandNode","expand","preventConnectorsUpdate","expandCollapse","fixedNode","layout","Render","enableAnimation","organizationalChartModule","isAnimation","doLayout","expandStateChange","resetSegments","getparentexpand","visibility","boolean","previousNode","opacity","newValues","updateNodeDimension","rect","canMeasurePath","updateConnectorPoints","updateSelectedNodeProperties","previousNodeObject","previousConnectorObject","updateNodeObject","updateConnectorObject","changeNodes","changeConnectors","helperObject","outerBounds","renderVirtualRegion","refreshConnectorSegments","drawSelectionRectangle","removeChildFromBPmn","newTarget","oldTarget","removeChildFromBPMN","undoElement","isDroppable","targetNodes","collapsed","connectHighlighter","tgt","tgtWrap","parent_6","mouseOver","snapPoint","startPoint","towardsLeft","towardsTop","snappedPoint","removeSnap","SnapToObject","removeGuidelines","dropAnnotation","hasTarget","sourcenode","dropBPMNchild","align","option","undoObj","redoObj","objectBounds","center","storeObject","distribute","top_3","middle","btt","undoSelectorObj","redoSelectorObj","topRight","topLeft","bottomRight","current","sameSize","selectorObject","updatePanState","eventCheck","PanInProgress","dataBind","diagramScrollSettings","Values","VerticalOffset","verticalOffset","HorizontalOffset","horizontalOffset","ViewportHeight","ViewportWidth","CurrentZoom","panState","scrollChange","dataBinding","setBlazorDiagramProps","scroll","scrollX","scrollY","focusPoint","panx","pany","setCursor","zoom","pan","drawHighlighter","removeHighlighter","clearHighlighter","isParentAsContainer","isChild","dropChildToContainer","PreventLaneContainerUpdate","updateLaneChildrenZindex","lowerIndexobject","findLeastIndexObject","getActiveLayer","startIndex","endIndex","findLeastIndexConnector","checkSelection","corner","orientation_1","rows","columns"],"mappings":"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","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar __generator = (this && this.__generator) || function (thisArg, body) {\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\n    function verb(n) { return function (v) { return step([n, v]); }; }\n    function step(op) {\n        if (f) throw new TypeError(\"Generator is already executing.\");\n        while (_) try {\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n            if (y = 0, t) op = [op[0] & 2, t.value];\n            switch (op[0]) {\n                case 0: case 1: t = op; break;\n                case 4: _.label++; return { value: op[1], done: false };\n                case 5: _.label++; y = op[1]; op = [0]; continue;\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\n                default:\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                    if (t[2]) _.ops.pop();\n                    _.trys.pop(); continue;\n            }\n            op = body.call(thisArg, _);\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n    }\n};\nimport { Connector, getBezierPoints, isEmptyVector } from '../objects/connector';\nimport { Node, BpmnSubEvent, BpmnAnnotation } from '../objects/node';\nimport { PathElement } from '../core/elements/path-element';\nimport { TextElement } from '../core/elements/text-element';\nimport { OrthogonalSegment } from '../objects/connector';\nimport { Rect } from '../primitives/rect';\nimport { Diagram } from '../../diagram/diagram';\nimport { identityMatrix, rotateMatrix, transformPointByMatrix, scaleMatrix } from './../primitives/matrix';\nimport { cloneObject as clone, cloneObject, getBounds, getFunction, getIndex } from './../utility/base-util';\nimport { completeRegion, sort, findObjectIndex, intersect3, getAnnotationPosition } from './../utility/diagram-util';\nimport { updatePathElement, cloneBlazorObject, getUserHandlePosition, cloneSelectedObjects } from './../utility/diagram-util';\nimport { updateDefaultValues } from './../utility/diagram-util';\nimport { randomId, cornersPointsBeforeRotation } from './../utility/base-util';\nimport { Selector } from '../objects/node';\nimport { hasSelection, isSelected, hasSingleConnection, contains } from './actions';\nimport { DiagramEvent } from '../enum/enum';\nimport { BlazorAction } from '../enum/enum';\nimport { canSelect, canMove, canRotate, canDragSourceEnd, canDragTargetEnd, canSingleSelect, canDrag } from './../utility/constraints-util';\nimport { canMultiSelect, canContinuousDraw } from './../utility/constraints-util';\nimport { canPanX, canPanY, canPageEditable } from './../utility/constraints-util';\nimport { SnapConstraints, DiagramTools, DiagramAction, RealAction } from '../enum/enum';\nimport { getDiagramElement, getAdornerLayerSvg, getHTMLLayer, getAdornerLayer } from '../utility/dom-util';\nimport { Point } from '../primitives/point';\nimport { Size } from '../primitives/size';\nimport { getObjectType, getPoint, intersect2, getOffsetOfConnector, canShowCorner } from './../utility/diagram-util';\nimport { Layer } from '../diagram/layer';\nimport { SelectorConstraints, DiagramConstraints } from '../enum/enum';\nimport { remove, isBlazor, isNullOrUndefined } from '@syncfusion/ej2-base';\nimport { getOppositeDirection, getPortDirection, findAngle } from './../utility/connector';\nimport { swapBounds, findPoint, orthoConnection2Segment, getIntersection } from './../utility/connector';\nimport { ShapeAnnotation, PathAnnotation } from '../objects/annotation';\nimport { renderContainerHelper } from './container-interaction';\nimport { checkChildNodeInContainer, checkParentAsContainer, addChildToContainer } from './container-interaction';\nimport { renderStackHighlighter } from './container-interaction';\nimport { getConnectors, updateConnectorsProperties, canLaneInterchange, findLane } from './../utility/swim-lane-util';\nimport { swimLaneSelection, pasteSwimLane, gridSelection } from '../utility/swim-lane-util';\nimport { DeepDiffMapper } from '../utility/diff-map';\n/**\n * Defines the behavior of commands\n */\nvar CommandHandler = /** @class */ (function () {\n    function CommandHandler(diagram) {\n        /**   @private  */\n        this.clipboardData = {};\n        // private newNodeObject: Object[] = [];\n        // private newConnectorObject: Object[] = [];\n        /**   @private  */\n        this.diagramObject = {};\n        /**   @private  */\n        this.newSelectedObjects = {};\n        /**   @private  */\n        this.oldSelectedObjects = {};\n        /**   @private  */\n        this.connectorsTable = [];\n        /**   @private  */\n        this.processTable = {};\n        /**   @private  */\n        this.deepDiffer = new DeepDiffMapper();\n        /** @private */\n        this.isContainer = false;\n        this.childTable = {};\n        this.parentTable = {};\n        this.blazor = 'Blazor';\n        this.blazorInterop = 'sfBlazor';\n        this.cloneGroupChildCollection = [];\n        this.diagram = diagram;\n    }\n    Object.defineProperty(CommandHandler.prototype, \"snappingModule\", {\n        /**   @private  */\n        get: function () {\n            return this.diagram.snappingModule;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    Object.defineProperty(CommandHandler.prototype, \"layoutAnimateModule\", {\n        /**   @private  */\n        get: function () {\n            return this.diagram.layoutAnimateModule;\n        },\n        enumerable: true,\n        configurable: true\n    });\n    /**\n     * startTransaction method\\\n     *\n     * @returns {  void }    startTransaction method .\\\n     * @param {boolean} protectChange - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.startTransaction = function (protectChange) {\n        this.state = { element: this.diagram.selectedItems, backup: null };\n        if (protectChange) {\n            this.diagram.protectPropertyChange(true);\n        }\n        getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'none';\n    };\n    /**\n     * endTransaction method\\\n     *\n     * @returns {  void }    endTransaction method .\\\n     * @param {boolean} protectChange - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.endTransaction = function (protectChange) {\n        this.state = null;\n        if (protectChange) {\n            this.diagram.protectPropertyChange(false);\n        }\n        getAdornerLayer(this.diagram.element.id).style.pointerEvents = 'all';\n    };\n    /**\n     * setFocus method\\\n     *\n     * @returns {  void }    setFocus method .\\\n     * @private\n     */\n    CommandHandler.prototype.setFocus = function () {\n        document.getElementById(this.diagram.element.id).focus();\n    };\n    /**\n     * showTooltip method\\\n     *\n     * @returns {  void }    showTooltip method .\\\n     * @param {IElement} node - provide the options value.\n     * @param {PointModel} position - provide the position value.\n     * @param {string | HTMLElement} content - provide the content value.\n     * @param {string} toolName - provide the toolName value.\n     * @param {boolean} isTooltipVisible - provide the isTooltipVisible value.\n     * @private\n     */\n    CommandHandler.prototype.showTooltip = function (node, position, content, toolName, isTooltipVisible) {\n        var _this = this;\n        var targetId;\n        var targetEle;\n        if (node instanceof Selector) {\n            if ((node.nodes.length == 1) && node.connectors.length == 0) {\n                targetId = node.nodes[0].id;\n            }\n            else if ((node.nodes.length == 0) && node.connectors.length == 1) {\n                targetId = node.connectors[0].id;\n            }\n            else {\n                targetEle = document.getElementById(this.diagram.element.id + '_SelectorElement');\n            }\n        }\n        else if (node instanceof Node) {\n            targetId = node.id;\n        }\n        else {\n            targetId = node.id;\n        }\n        if (isNullOrUndefined(targetEle) && !isNullOrUndefined(targetId)) {\n            targetEle = document.getElementById(targetId + '_groupElement');\n        }\n        if (isTooltipVisible) {\n            this.diagram.tooltipObject.position = 'BottomCenter';\n            this.diagram.tooltipObject.animation = { open: { delay: 0, duration: 0 } };\n            this.diagram.tooltipObject.openDelay = 0;\n            this.diagram.tooltipObject.closeDelay = 0;\n        }\n        if (this.diagram.selectedItems.setTooltipTemplate) {\n            var template = void 0;\n            var setTooltipTemplate = getFunction(this.diagram.selectedItems.setTooltipTemplate);\n            if (setTooltipTemplate) {\n                template = setTooltipTemplate(node, this.diagram);\n            }\n            if (template instanceof HTMLElement) {\n                content = template.cloneNode(true);\n            }\n            else {\n                content = template ? template : content;\n            }\n        }\n        if (isBlazor() && isTooltipVisible) {\n            this.diagram.tooltipObject.close();\n        }\n        if (node.tooltip) {\n            this.diagram.tooltipObject.openOn = node.tooltip.openOn;\n        }\n        this.diagram.tooltipObject.content = content;\n        this.diagram.tooltipObject.offsetX = 0;\n        this.diagram.tooltipObject.offsetY = 0;\n        if (isBlazor()) {\n            this.diagram.tooltipObject.updateTooltip(this.diagram.element);\n        }\n        else {\n            this.diagram.tooltipObject.refresh(targetEle);\n        }\n        if (isTooltipVisible) {\n            setTimeout(function () {\n                _this.diagram.tooltipObject.open(targetEle);\n            }, 1);\n        }\n    };\n    /**\n     * closeTooltip method\\\n     *\n     * @returns {  void }    closeTooltip method .\\\n     * @private\n     */\n    CommandHandler.prototype.closeTooltip = function () {\n        this.diagram.tooltipObject.close();\n    };\n    /**\n     * canEnableDefaultTooltip method\\\n     *\n     * @returns {  boolean }    canEnableDefaultTooltip method .\\\n     * @private\n     */\n    CommandHandler.prototype.canEnableDefaultTooltip = function () {\n        if (this.diagram.selectedItems.constraints & SelectorConstraints.ToolTip) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    };\n    /**\n     * updateSelector method\\\n     *\n     * @returns {  void }    updateSelector method .\\\n     * @private\n     */\n    CommandHandler.prototype.updateSelector = function () {\n        this.diagram.updateSelector();\n    };\n    /**\n     * updateConnectorValue method\\\n     *\n     * @returns {  void }    updateConnectorValue method .\\\n     * @param {IBlazorConnectionChangeEventArgs} args - provide the options value.\n     * @private\n     */\n    CommandHandler.prototype.updateConnectorValue = function (args) {\n        if (args.cancel) {\n            this.enableCloneObject(true);\n            this.ismouseEvents(true);\n            this.insertBlazorObject(args.connector);\n            var newChanges = {};\n            var oldChanges = {};\n            var connector = this.diagram.nameTable[args.connector.id];\n            var nodeEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n            var portEndId = args.connectorEnd === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n            var connectionEnd = args.connectorEnd === 'ConnectorTargetEnd';\n            var newValue = connectionEnd ? args.newValue.connectorTargetValue : args.newValue.connectorSourceValue;\n            var oldValue = connectionEnd ? args.oldValue.connectorTargetValue : args.oldValue.connectorSourceValue;\n            oldChanges[nodeEndId] = newValue.nodeId;\n            oldChanges[portEndId] = newValue.portId;\n            newChanges[nodeEndId] = oldValue.nodeId;\n            newChanges[portEndId] = oldValue.portId;\n            if (args.cancel && args.connectorEnd !== 'ConnectorTargetEnd') {\n                connector.sourceID = oldValue.nodeId;\n                if (args.connector.sourcePortID) {\n                    connector.sourcePortID = oldValue.portId;\n                }\n                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n            }\n            if (args.cancel && args.connectorEnd === 'ConnectorTargetEnd') {\n                if (args.connector.targetPortID) {\n                    connector.targetPortID = oldValue.portId;\n                }\n                connector.targetID = oldValue.nodeId;\n                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n            }\n        }\n    };\n    /**\n     * triggerEvent method\\\n     *\n     * @returns {  Promise<void | object | IBlazorConnectionChangeEventArgs> }    triggerEvent method .\\\n     * @param {DiagramEvent} event - provide the options value.\n     * @param {Object} args - provide the args value.\n     * @private\n     */\n    CommandHandler.prototype.triggerEvent = function (event, args) {\n        return __awaiter(this, void 0, void 0, function () {\n            var temparg;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        if (event === DiagramEvent.drop || event === DiagramEvent.positionChange ||\n                            event === DiagramEvent.connectionChange) {\n                            if (this.diagram.currentSymbol) {\n                                return [2 /*return*/];\n                            }\n                            if (event === DiagramEvent.drop) {\n                                args.source = cloneBlazorObject(this.diagram);\n                            }\n                            if (this.diagram.currentDrawingObject && event !== DiagramEvent.positionChange) {\n                                return [2 /*return*/];\n                            }\n                        }\n                        return [4 /*yield*/, this.diagram.triggerEvent(event, args)];\n                    case 1:\n                        temparg = _a.sent();\n                        return [2 /*return*/, temparg];\n                }\n            });\n        });\n    };\n    /**\n     * dragOverElement method\\\n     *\n     * @returns { void }    dragOverElement method .\\\n     * @param {MouseEventArgs} args - provide the options value.\n     * @param {PointModel} currentPosition - provide the args value.\n     * @private\n     */\n    CommandHandler.prototype.dragOverElement = function (args, currentPosition) {\n        if (this.diagram.currentSymbol) {\n            var dragOverArg = {\n                element: cloneBlazorObject(args.source), target: cloneBlazorObject(args.target),\n                mousePosition: cloneBlazorObject(currentPosition), diagram: cloneBlazorObject(this.diagram)\n            };\n            this.triggerEvent(DiagramEvent.dragOver, dragOverArg);\n        }\n    };\n    /**\n     * disConnect method\\\n     *\n     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    disConnect method .\\\n     * @param {IElement} obj - provide the obj value.\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {boolean} canCancel - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.disConnect = function (obj, endPoint, canCancel) {\n        var checkBlazor = isBlazor();\n        var oldChanges = {};\n        var newChanges = {};\n        var returnargs;\n        var selectorModel;\n        var connector;\n        if (obj instanceof Selector) {\n            selectorModel = obj;\n            connector = selectorModel.connectors[0];\n        }\n        else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n            connector = this.diagram.currentDrawingObject;\n        }\n        if (obj && connector && (hasSingleConnection(this.diagram) || this.diagram.currentDrawingObject)) {\n            if (isBlazor()) {\n                this.diagram.insertValue(cloneObject(connector), false);\n            }\n            if (endPoint && (endPoint === 'ConnectorSourceEnd' || endPoint === 'ConnectorTargetEnd')) {\n                var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n                var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n                if (connector[nodeEndId]) { //connector.sourceID || connector.targetID\n                    oldChanges[nodeEndId] = connector[nodeEndId];\n                    connector[nodeEndId] = '';\n                    newChanges[nodeEndId] = connector[nodeEndId];\n                    if (connector.sourcePortID || connector.targetPortID) {\n                        oldChanges[portEndId] = connector[portEndId];\n                        connector[portEndId] = '';\n                        newChanges[portEndId] = connector[portEndId];\n                    }\n                    returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n                }\n            }\n            else if ((endPoint !== 'OrthoThumb' && endPoint !== 'SegmentEnd') && (connector.sourceID || connector.targetID)) {\n                oldChanges = {\n                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,\n                    targetID: connector.targetID, targetPortID: connector.targetPortID\n                };\n                connector.sourceID = '';\n                connector.sourcePortID = '';\n                connector.targetID = '';\n                connector.targetPortID = '';\n                newChanges = {\n                    sourceID: connector.sourceID, sourcePortID: connector.sourcePortID,\n                    targetID: connector.targetID, targetPortID: connector.targetPortID\n                };\n                var arg = {\n                    connector: cloneBlazorObject(connector), oldValue: oldChanges,\n                    newValue: newChanges, cancel: false, state: 'Changing', connectorEnd: endPoint\n                };\n                if (isBlazor()) {\n                    arg = {\n                        connector: cloneBlazorObject(connector),\n                        oldValue: { connector: cloneBlazorObject(oldChanges) },\n                        newValue: { connector: cloneBlazorObject(newChanges) },\n                        cancel: false, state: 'Changed', connectorEnd: endPoint\n                    };\n                    returnargs = arg;\n                }\n                if (!checkBlazor) {\n                    this.triggerEvent(DiagramEvent.connectionChange, arg);\n                }\n                if (arg.cancel) {\n                    connector.sourceID = oldChanges.sourceID;\n                    connector.sourcePortID = oldChanges.sourcePortID;\n                    connector.targetID = oldChanges.targetID;\n                    connector.targetPortID = oldChanges.targetPortID;\n                }\n                else {\n                    this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n                    this.diagram.updateDiagramObject(connector);\n                    arg = {\n                        connector: connector, oldValue: oldChanges,\n                        newValue: newChanges, cancel: false, state: 'Changed', connectorEnd: endPoint\n                    };\n                    if (isBlazor()) {\n                        arg = {\n                            connector: cloneBlazorObject(connector), oldValue: { connector: oldChanges },\n                            newValue: { connector: newChanges }, cancel: false, state: 'Changed', connectorEnd: endPoint\n                        };\n                        returnargs = arg;\n                    }\n                    if (!checkBlazor) {\n                        this.triggerEvent(DiagramEvent.connectionChange, arg);\n                    }\n                }\n            }\n        }\n        return returnargs;\n    };\n    CommandHandler.prototype.connectionEventChange = function (connector, oldChanges, newChanges, endPoint, canCancel) {\n        var checkBlazor = isBlazor();\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        var connectedNode;\n        if (this.enableCloneObject) {\n            connectedNode = this.diagram.nameTable[newChanges[nodeEndId]];\n            var nodeObject = cloneObject(connectedNode);\n            this.diagram.insertValue(nodeObject, true);\n        }\n        var returnargs;\n        var arg = {\n            cancel: false, state: 'Changing', connectorEnd: endPoint,\n            connector: cloneBlazorObject(connector), oldValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] },\n            newValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }\n        };\n        if (isBlazor()) {\n            arg = {\n                connector: cloneBlazorObject(connector),\n                cancel: false, state: 'Changing', connectorEnd: endPoint,\n                oldValue: undefined, newValue: undefined\n            };\n            if (endPoint === 'ConnectorSourceEnd') {\n                arg.oldValue = {\n                    connectorSourceValue: {\n                        portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId]\n                    }\n                };\n                arg.newValue = {\n                    connectorSourceValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }\n                };\n            }\n            else {\n                arg.oldValue = {\n                    connectorTargetValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] }\n                };\n                arg.newValue = {\n                    connectorTargetValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }\n                };\n            }\n            returnargs = arg;\n        }\n        if (!checkBlazor) {\n            this.triggerEvent(DiagramEvent.connectionChange, arg);\n        }\n        if (arg.cancel || (isBlazor() && canCancel)) {\n            connector[nodeEndId] = oldChanges[nodeEndId];\n            connector[portEndId] = oldChanges[portEndId];\n            newChanges = oldChanges;\n        }\n        else {\n            this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n            this.diagram.updateDiagramObject(connector);\n            arg = {\n                connector: cloneBlazorObject(connector), oldValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] },\n                newValue: {\n                    nodeId: newChanges[nodeEndId],\n                    portId: newChanges[portEndId]\n                },\n                cancel: false, state: 'Changing', connectorEnd: endPoint\n            };\n            if (isBlazor()) {\n                arg = {\n                    connector: cloneBlazorObject(connector),\n                    oldValue: undefined,\n                    newValue: undefined,\n                    cancel: false, state: 'Changing', connectorEnd: endPoint\n                };\n                if (endPoint === 'ConnectorSourceEnd') {\n                    arg.newValue = {\n                        connectorSourceValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                    arg.oldValue = {\n                        connectorSourceValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                    };\n                }\n                else {\n                    arg.oldValue = {\n                        connectorTargetValue: { nodeId: oldChanges[nodeEndId], portId: oldChanges[portEndId] }\n                    };\n                    arg.newValue = {\n                        connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                }\n                returnargs = arg;\n            }\n        }\n        if (this.enableCloneObject) {\n            if (connectedNode === undefined) {\n                connectedNode = this.diagram.nameTable[oldChanges[nodeEndId]];\n                var nodeObject = cloneObject(connectedNode);\n                this.diagram.insertValue(nodeObject, true);\n            }\n        }\n        return returnargs;\n    };\n    /**\n     * insertBlazorObject method\\\n     *\n     * @returns { void }    insertBlazorObject method .\\\n     * @param {IElement} object - provide the object value.\n     * @param {boolean} isNode - provide the isNode value.\n     * @private\n     */\n    CommandHandler.prototype.insertBlazorObject = function (object, isNode) {\n        var node;\n        var connector;\n        if (object instanceof Selector) {\n            this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n            for (var i = 0; i < object.nodes.length; i++) {\n                node = this.diagram.getObject(object.nodes[i].id);\n                this.diagram.insertValue(cloneObject(node), true);\n            }\n            for (var i = 0; i < object.connectors.length; i++) {\n                connector = this.diagram.getObject(object.connectors[i].id);\n                this.diagram.insertValue(cloneObject(connector), false);\n            }\n        }\n        else {\n            object = this.diagram.getObject(object.id);\n            this.diagram.insertValue(cloneObject(object), (object instanceof Node) ? true : false);\n        }\n    };\n    /**\n     * updatePropertiesToBlazor method\\\n     *\n     * @returns { void }    updatePropertiesToBlazor method .\\\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {PointModel} labelDrag - provide the labelDrag value.\n     * @private\n     */\n    CommandHandler.prototype.updatePropertiesToBlazor = function (args, labelDrag) {\n        this.enableCloneObject(false);\n        this.ismouseEvents(false);\n        this.getBlazorOldValues(args, labelDrag);\n        this.updateBlazorSelector();\n    };\n    /**\n     * insertSelectedObjects method\\\n     *\n     * @returns { void }    insertSelectedObjects method .\\\n     * @private\n     */\n    CommandHandler.prototype.insertSelectedObjects = function () {\n        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n    };\n    /**\n     * findTarget method\\\n     *\n     * @returns { NodeModel | PointPortModel | ShapeAnnotationModel | PathAnnotationModel }    findTarget method .\\\n     * @param {DiagramElement} element - provide the element value.\n     * @param {IElement} argsTarget - provide the argsTarget value.\n     * @param {boolean} source - provide the source value.\n     * @param {boolean} connection - provide the connection value.\n     * @private\n     */\n    CommandHandler.prototype.findTarget = function (element, argsTarget, source, connection) {\n        var target;\n        if (argsTarget instanceof Node) {\n            if (element && element.id === argsTarget.id + '_content') {\n                return argsTarget;\n            }\n            if (source && argsTarget.shape.type === 'Bpmn' && ((!isBlazor() && argsTarget.shape.shape === 'Activity') ||\n                (isBlazor() && argsTarget.shape.bpmnShape === 'Activity'))) {\n                if (argsTarget.shape.activity.subProcess.type === 'Transaction') {\n                    var transaction = argsTarget.shape.activity.subProcess.transaction;\n                    if (transaction.success.visible && element.id.indexOf(argsTarget.id + '_success') === 0) {\n                        return transaction.success;\n                    }\n                    if (transaction.cancel.visible && element.id.indexOf(argsTarget.id + '_cancel') === 0) {\n                        return transaction.cancel;\n                    }\n                    if (transaction.failure.visible && element.id.indexOf(argsTarget.id + '_failure') === 0) {\n                        return transaction.failure;\n                    }\n                }\n            }\n            if (element instanceof PathElement) {\n                for (var i = 0; i < argsTarget.ports.length; i++) {\n                    var port = argsTarget.ports[i];\n                    if (element.id === argsTarget.id + '_' + port.id) {\n                        return port;\n                    }\n                }\n            }\n        }\n        if (!connection) {\n            var annotation = void 0;\n            for (var i = 0; i < argsTarget.annotations.length; i++) {\n                annotation = argsTarget.annotations[i];\n                if (element.id === argsTarget.id + '_' + annotation.id) {\n                    return annotation;\n                }\n            }\n        }\n        return argsTarget;\n    };\n    /**\n     * canDisconnect method\\\n     *\n     * @returns { boolean }    canDisconnect method .\\\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {string} targetPortId - provide the targetPortId value.\n     * @param {string} targetNodeId - provide the targetNodeId value.\n     * @private\n     */\n    CommandHandler.prototype.canDisconnect = function (endPoint, args, targetPortId, targetNodeId) {\n        var selector;\n        var connect;\n        if (args.source instanceof Selector) {\n            selector = args.source;\n            connect = selector.connectors[0];\n        }\n        else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n            connect = this.diagram.currentDrawingObject;\n        }\n        var targetObject = this.findTarget(args.targetWrapper, args.target, endPoint === 'ConnectorSourceEnd', true);\n        var nodeEnd = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEnd = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        if (connect[nodeEnd] !== targetNodeId || connect[portEnd] !== targetPortId) {\n            return true;\n        }\n        return false;\n    };\n    /**\n     * changeAnnotationDrag method\\\n     *\n     * @returns { void }    changeAnnotationDrag method .\\\n     * @param {MouseEventArgs} args - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.changeAnnotationDrag = function (args) {\n        var selectorModel;\n        var connector;\n        if (args.source && args.source.connectors &&\n            args.source.connectors.length && this.diagram.bpmnModule &&\n            this.diagram.bpmnModule.textAnnotationConnectors.indexOf(args.source.connectors[0]) > -1) {\n            if (args.source instanceof Selector) {\n                selectorModel = args.source;\n                connector = selectorModel.connectors[0];\n            }\n            var id = connector.id.split('_');\n            var annotationId = id[id.length - 1];\n            var nodeId = id[id.length - 3] || id[0];\n            if (args.target && args.target.id !== nodeId &&\n                ((!isBlazor() && args.target.shape.shape !== 'TextAnnotation') ||\n                    (isBlazor() && args.target.shape.bpmnShape !== 'TextAnnotation'))) {\n                this.diagram.startGroupAction();\n                var parentNode = this.diagram.nameTable[id[0]];\n                var clonedNode = this.getAnnotation(parentNode, id[1]);\n                var annotationNode = {\n                    id: id[1] + randomId(),\n                    angle: Point.findAngle(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n                    text: clonedNode.text,\n                    length: Point.distancePoints(connector.intermediatePoints[0], connector.intermediatePoints[1]),\n                    shape: { shape: 'TextAnnotation', type: 'Bpmn' },\n                    nodeId: clonedNode.nodeId\n                };\n                var annotationObj = new BpmnAnnotation(args.target.shape, 'annotations', annotationNode, true);\n                this.diagram.bpmnModule.checkAndRemoveAnnotations(this.diagram.nameTable[connector.targetID], this.diagram);\n                this.diagram.refreshCanvasLayers();\n                annotationObj.id = id[1];\n                this.diagram.addTextAnnotation(annotationObj, args.target);\n                this.diagram.endGroupAction();\n            }\n            else if (connector) {\n                connector.sourceID = nodeId;\n                this.diagram.connectorPropertyChange(connector, {}, { sourceID: nodeId });\n                this.diagram.updateDiagramObject(connector);\n            }\n        }\n    };\n    /* tslint:disable */\n    /**\n     * connect method\\\n     *\n     * @returns { IConnectionChangeEventArgs | IBlazorConnectionChangeEventArgs }    connect method .\\\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {MouseEventArgs} args - provide the args value.\n     * @param {boolean} canCancel - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.connect = function (endPoint, args, canCancel) {\n        var checkBlazor;\n        var newChanges = {};\n        var oldChanges = {};\n        var oldNodeId;\n        var oldPortId;\n        var selectorModel;\n        var connector;\n        var returnargs;\n        if (args.source instanceof Selector) {\n            selectorModel = args.source;\n            connector = selectorModel.connectors[0];\n        }\n        else if (args.source instanceof Connector && this.diagram.currentDrawingObject) {\n            connector = this.diagram.currentDrawingObject;\n        }\n        var target = this.findTarget((args.targetWrapper || args.sourceWrapper), (args.target || args.actualObject), endPoint === 'ConnectorSourceEnd', true);\n        var nodeEndId = endPoint === 'ConnectorSourceEnd' ? 'sourceID' : 'targetID';\n        var portEndId = endPoint === 'ConnectorSourceEnd' ? 'sourcePortID' : 'targetPortID';\n        if (target instanceof Node) {\n            oldChanges[nodeEndId] = connector[nodeEndId];\n            connector[nodeEndId] = target.id;\n            newChanges[nodeEndId] = connector[nodeEndId];\n            oldChanges[portEndId] = connector[portEndId];\n            returnargs = this.connectionEventChange(connector, oldChanges, newChanges, endPoint, canCancel);\n        }\n        else {\n            oldNodeId = connector[nodeEndId];\n            oldPortId = connector[portEndId];\n            connector[portEndId] = target.id;\n            connector[nodeEndId] = (args.target && args.target.id || args.actualObject.id);\n            newChanges[nodeEndId] = connector[nodeEndId];\n            newChanges[portEndId] = connector[portEndId];\n            var arg = {\n                connector: cloneBlazorObject(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },\n                newValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] },\n                cancel: false, state: 'Changing', connectorEnd: endPoint\n            };\n            if (isBlazor()) {\n                arg = {\n                    connector: cloneBlazorObject(connector),\n                    oldValue: undefined,\n                    newValue: undefined,\n                    cancel: false, state: 'Changing', connectorEnd: endPoint\n                };\n                if (endPoint === 'ConnectorSourceEnd') {\n                    arg.oldValue = {\n                        connectorSourceValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                    };\n                    arg.newValue = {\n                        connectorSourceValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                }\n                else {\n                    arg.newValue = {\n                        connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                    };\n                    arg.oldValue = {\n                        connectorTargetValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                    };\n                }\n                returnargs = arg;\n            }\n            if (!checkBlazor) {\n                this.triggerEvent(DiagramEvent.connectionChange, arg);\n            }\n            if (arg.cancel || (isBlazor() && canCancel)) {\n                connector[nodeEndId] = oldNodeId;\n                connector[portEndId] = oldPortId;\n                newChanges[nodeEndId] = oldNodeId;\n                newChanges[portEndId] = oldPortId;\n            }\n            else {\n                this.diagram.connectorPropertyChange(connector, oldChanges, newChanges);\n                this.diagram.updateDiagramObject(connector);\n                arg = {\n                    connector: cloneBlazorObject(connector), oldValue: { nodeId: oldNodeId, portId: oldPortId },\n                    newValue: { nodeId: newChanges[nodeEndId], portId: newChanges[portEndId] }, cancel: false,\n                    state: 'Changing', connectorEnd: endPoint\n                };\n                if (isBlazor()) {\n                    arg = {\n                        newValue: undefined,\n                        connector: cloneBlazorObject(connector),\n                        oldValue: undefined,\n                        cancel: false, state: 'Changing', connectorEnd: endPoint\n                    };\n                    if (endPoint === 'ConnectorSourceEnd') {\n                        arg.oldValue = {\n                            connectorSourceValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                        };\n                        arg.newValue = {\n                            connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                        };\n                    }\n                    else {\n                        arg.oldValue = {\n                            connectorTargetValue: { portId: oldChanges[portEndId], nodeId: oldChanges[nodeEndId] }\n                        };\n                        arg.newValue = {\n                            connectorTargetValue: { portId: newChanges[portEndId], nodeId: newChanges[nodeEndId] }\n                        };\n                    }\n                }\n            }\n        }\n        this.renderHighlighter(args, undefined, endPoint === 'ConnectorSourceEnd');\n        return returnargs;\n    };\n    /* tslint:enable */\n    /** @private */\n    /**\n     * cut method\\\n     *\n     * @returns { void }    cut method .\\\n     * @private\n     */\n    CommandHandler.prototype.cut = function () {\n        var index;\n        this.clipboardData.pasteIndex = 0;\n        if (this.diagram.undoRedoModule) {\n            this.diagram.historyManager.startGroupAction();\n        }\n        this.clipboardData.clipObject = this.copyObjects();\n        if (this.diagram.undoRedoModule) {\n            this.diagram.historyManager.endGroupAction();\n        }\n        if (this.diagram.mode !== 'SVG') {\n            this.diagram.refreshDiagramLayer();\n        }\n    };\n    CommandHandler.prototype.UpdateBlazorDiagramModelLayers = function (layer, isRemove) {\n        var blazorInterop = 'sfBlazor';\n        var updatedModel = cloneBlazorObject(layer);\n        var blazor = 'Blazor';\n        if (window && window[blazor]) {\n            var obj = {\n                'methodName': 'UpdateBlazorDiagramModelLayers',\n                'diagramobj': JSON.stringify(updatedModel), 'isRemove': isRemove\n            };\n            if (!this.diagram.isLoading) {\n                window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n            }\n        }\n    };\n    /**\n     * addLayer method\\\n     *\n     * @returns { void }    addLayer method .\\\n     * @param {LayerModel} layer - provide the endPoint value.\n     * @param {Object[]} objects - provide the args value.\n     * @param {boolean} isServerUpdate - provide the canCancel value.\n     * @private\n     */\n    CommandHandler.prototype.addLayer = function (layer, objects, isServerUpdate) {\n        if (isServerUpdate === void 0) { isServerUpdate = true; }\n        layer.id = layer.id || randomId();\n        layer.zIndex = this.diagram.layers.length;\n        var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n        this.diagram.enableServerDataBinding(false);\n        layer = new Layer(this.diagram, 'layers', layer, true);\n        this.diagram.enableServerDataBinding(isEnableServerDatabind);\n        layer.objectZIndex = -1;\n        layer.zIndexTable = {};\n        this.diagram.layers.push(layer);\n        if (isServerUpdate) {\n            this.UpdateBlazorDiagramModelLayers(layer, false);\n        }\n        this.diagram.layerZIndexTable[layer.zIndex] = layer.id;\n        this.diagram.activeLayer = layer;\n        var layers = layer.objects;\n        if (objects) {\n            for (var i = 0; i < objects.length; i++) {\n                this.diagram.add(objects[i]);\n            }\n        }\n    };\n    /**\n     * getObjectLayer method\\\n     *\n     * @returns { LayerModel }    getObjectLayer method .\\\n     * @param {string} objectName - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.getObjectLayer = function (objectName) {\n        var layers = this.diagram.layers;\n        for (var i = 0; i < layers.length; i++) {\n            var objIndex = layers[i].objects.indexOf(objectName);\n            if (objIndex > -1) {\n                return layers[i];\n            }\n        }\n        return this.diagram.activeLayer;\n    };\n    /**\n     * getLayer method\\\n     *\n     * @returns { LayerModel }    getLayer method .\\\n     * @param {string} layerName - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.getLayer = function (layerName) {\n        var layers = this.diagram.layers;\n        for (var i = 0; i < layers.length; i++) {\n            if (layers[i].id === layerName) {\n                return layers[i];\n            }\n        }\n        return undefined;\n    };\n    /**\n     * removeLayer method\\\n     *\n     * @returns { void }    removeLayer method .\\\n     * @param {string} layerId - provide the endPoint value.\n     * @param {boolean} isServerUpdate - provide the endPoint value.\n     * @private\n     */\n    CommandHandler.prototype.removeLayer = function (layerId, isServerUpdate) {\n        if (isServerUpdate === void 0) { isServerUpdate = true; }\n        var layers = this.getLayer(layerId);\n        if (layers) {\n            var index = this.diagram.layers.indexOf(layers);\n            var layerObject = layers.objects;\n            for (var i = layerObject.length - 1; i >= 0; i--) {\n                this.diagram.unSelect(this.diagram.nameTable[layerObject[i]]);\n                this.diagram.remove(this.diagram.nameTable[layerObject[i]]);\n                if (layers.id !== 'default_layer') {\n                    if (this.diagram.activeLayer.id === layerId) {\n                        this.diagram.activeLayer = this.diagram.layers[this.diagram.layers.length - 1];\n                    }\n                }\n            }\n            if (isServerUpdate) {\n                this.UpdateBlazorDiagramModelLayers(this.diagram.layers[index], true);\n            }\n            delete this.diagram.layerZIndexTable[layers.zIndex];\n            this.diagram.layers.splice(index, 1);\n            if (this.diagram.mode !== 'SVG') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * moveObjects method\\\n     *\n     * @returns { void }    moveObjects method .\\\n     * @param {string[]]} objects - provide the objects value.\n     * @param {string} targetLayer - provide the targetLayer value.\n     * @private\n     */\n    CommandHandler.prototype.moveObjects = function (objects, targetLayer) {\n        var layer = this.getLayer(targetLayer) || this.diagram.activeLayer;\n        this.diagram.setActiveLayer(layer.id);\n        var targerNodes;\n        for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {\n            var i = objects_1[_i];\n            var layer_1 = this.getObjectLayer(i);\n            var index = layer_1.objects.indexOf(i);\n            if (index > -1) {\n                targerNodes = this.diagram.nameTable[i];\n                this.diagram.unSelect(targerNodes);\n                this.diagram.remove(this.diagram.nameTable[i]);\n                this.diagram.add(targerNodes);\n            }\n        }\n    };\n    /**\n     * cloneLayer method\\\n     *\n     * @returns { void }    cloneLayer method .\\\n     * @param {string[]} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.cloneLayer = function (layerName) {\n        var layers = this.diagram.layers;\n        var layer = this.getLayer(layerName);\n        if (layer) {\n            var cloneObject_1 = [];\n            var newlayer = {\n                id: layerName + '_' + randomId(), objects: [], visible: true, lock: false\n            };\n            this.addLayer(newlayer, null, true);\n            newlayer.zIndex = this.diagram.layers.length - 1;\n            var multiSelect = cloneObject_1.length !== 1;\n            for (var _i = 0, _a = layer.objects; _i < _a.length; _i++) {\n                var obj = _a[_i];\n                cloneObject_1.push(this.diagram.nameTable[obj]);\n            }\n            this.paste(cloneObject_1);\n        }\n    };\n    /**\n     * copy method\\\n     *\n     * @returns { void }    copy method .\\\n     * @private\n     */\n    CommandHandler.prototype.copy = function () {\n        this.clipboardData.pasteIndex = 1;\n        this.clipboardData.clipObject = this.copyObjects();\n        return this.clipboardData.clipObject;\n    };\n    /**\n     * copyObjects method\\\n     *\n     * @returns { Object[] }    copyObjects method .\\\n     * @private\n     */\n    CommandHandler.prototype.copyObjects = function () {\n        var selectedItems = [];\n        var obj = [];\n        this.clipboardData.childTable = {};\n        if (this.diagram.selectedItems.connectors.length > 0) {\n            selectedItems = this.diagram.selectedItems.connectors;\n            for (var j = 0; j < selectedItems.length; j++) {\n                var element = void 0;\n                if (this.diagram.bpmnModule &&\n                    this.diagram.bpmnModule.textAnnotationConnectors.indexOf(selectedItems[j]) > -1) {\n                    element = cloneObject((this.diagram.nameTable[selectedItems[j].targetID]));\n                }\n                else {\n                    element = cloneObject((selectedItems[j]));\n                }\n                obj.push(element);\n            }\n        }\n        if (this.diagram.selectedItems.nodes.length > 0) {\n            selectedItems = selectedItems.concat(this.diagram.selectedItems.nodes);\n            for (var j = 0; j < this.diagram.selectedItems.nodes.length; j++) {\n                if (!selectedItems[j].isPhase) {\n                    var node = clone(this.diagram.selectedItems.nodes[j]);\n                    if (node.wrapper && (node.offsetX !== node.wrapper.offsetX)) {\n                        node.offsetX = node.wrapper.offsetX;\n                    }\n                    if (node.wrapper && (node.offsetY !== node.wrapper.offsetY)) {\n                        node.offsetY = node.wrapper.offsetY;\n                    }\n                    var processTable = {};\n                    this.copyProcesses(node);\n                    obj.push(clone(node));\n                    var matrix = identityMatrix();\n                    rotateMatrix(matrix, -node.rotateAngle, node.offsetX, node.offsetY);\n                    if (node.children) {\n                        var childTable = this.clipboardData.childTable;\n                        var tempNode = void 0;\n                        var elements = [];\n                        var nodes = this.getAllDescendants(node, elements, true);\n                        for (var i = 0; i < nodes.length; i++) {\n                            tempNode = this.diagram.nameTable[nodes[i].id];\n                            var clonedObject = childTable[tempNode.id] = clone(tempNode);\n                            var newOffset = transformPointByMatrix(matrix, { x: clonedObject.wrapper.offsetX, y: clonedObject.wrapper.offsetY });\n                            if (tempNode instanceof Node) {\n                                clonedObject.offsetX = newOffset.x;\n                                clonedObject.offsetY = newOffset.y;\n                                clonedObject.rotateAngle -= node.rotateAngle;\n                            }\n                        }\n                        this.clipboardData.childTable = childTable;\n                    }\n                    if (node.shape.type === 'SwimLane') {\n                        var swimlane = this.diagram.getObject(this.diagram.selectedItems.nodes[j].id);\n                        var childTable = this.clipboardData.childTable;\n                        var connectorsList = getConnectors(this.diagram, swimlane.wrapper.children[0], 0, true);\n                        for (var i = 0; i < connectorsList.length; i++) {\n                            var connector = this.diagram.getObject(connectorsList[i]);\n                            childTable[connector.id] = clone(connector);\n                        }\n                    }\n                    if (node && node.isLane) {\n                        var childTable = this.clipboardData.childTable;\n                        var swimlane = this.diagram.getObject(node.parentId);\n                        var lane = findLane(node, this.diagram);\n                        childTable[node.id] = cloneObject(lane);\n                        childTable[node.id].width = swimlane.wrapper.actualSize.width;\n                    }\n                }\n            }\n        }\n        if (this.clipboardData.pasteIndex === 0) {\n            this.startGroupAction();\n            for (var _i = 0, selectedItems_1 = selectedItems; _i < selectedItems_1.length; _i++) {\n                var item = selectedItems_1[_i];\n                if (this.diagram.nameTable[item.id]) {\n                    if (this.diagram.bpmnModule &&\n                        this.diagram.bpmnModule.textAnnotationConnectors.indexOf(item) > -1) {\n                        this.diagram.remove(this.diagram.nameTable[item.targetID]);\n                    }\n                    else {\n                        this.diagram.remove(item);\n                    }\n                }\n            }\n            this.endGroupAction();\n        }\n        this.sortByZIndex(obj, 'zIndex');\n        return obj;\n    };\n    CommandHandler.prototype.copyProcesses = function (node) {\n        if (node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes &&\n            node.shape.activity.subProcess.processes.length > 0) {\n            var processes = node.shape.activity.subProcess.processes;\n            for (var _i = 0, processes_1 = processes; _i < processes_1.length; _i++) {\n                var i = processes_1[_i];\n                this.processTable[i] = (clone(this.diagram.nameTable[i]));\n                if (this.processTable[i].shape.activity.subProcess.processes &&\n                    this.processTable[i].shape.activity.subProcess.processes.length > 0) {\n                    this.copyProcesses(this.processTable[i]);\n                }\n            }\n            this.clipboardData.processTable = this.processTable;\n        }\n    };\n    /**\n     * group method\\\n     *\n     * @returns { void }    group method .\\\n     * @private\n     */\n    CommandHandler.prototype.group = function () {\n        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[propName];\n        this.diagram.protectPropertyChange(true);\n        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n        var selectedItems = [];\n        var obj = {};\n        //let group: Node | Connector;\n        obj.id = 'group' + randomId();\n        obj = new Node(this.diagram, 'nodes', obj, true);\n        obj.children = [];\n        selectedItems = this.diagram.selectedItems.nodes;\n        selectedItems = selectedItems.concat(this.diagram.selectedItems.connectors);\n        for (var i = 0; i < selectedItems.length; i++) {\n            if (!selectedItems[i].parentId) {\n                obj.children.push(selectedItems[i].id);\n            }\n        }\n        var group = this.diagram.add(obj);\n        if (group) {\n            this.select(group);\n        }\n        var entry = { type: 'Group', undoObject: obj, redoObject: obj, category: 'Internal' };\n        this.addHistoryEntry(entry);\n        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n        this.diagram.protectPropertyChange(protectedChange);\n        this.updateBlazorSelector();\n    };\n    /**\n     * unGroup method\\\n     *\n     * @returns {  void }    unGroup method .\\\n     * @param {NodeModel} obj - provide the angle value.\n     * @private\n     */\n    CommandHandler.prototype.unGroup = function (obj) {\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[propName];\n        this.diagram.protectPropertyChange(true);\n        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.Group;\n        var selectedItems = [];\n        if (obj) {\n            selectedItems.push(obj);\n        }\n        else {\n            selectedItems = this.diagram.selectedItems.nodes;\n        }\n        this.diagram.startGroupAction();\n        for (var i = 0; i < selectedItems.length; i++) {\n            var node = selectedItems[i];\n            var undoObject = cloneObject(node);\n            var childCollection = [];\n            for (var k = 0; k < node.children.length; k++) {\n                childCollection.push(node.children[k]);\n            }\n            if (node.children) {\n                if (node.ports && node.ports.length > 0) {\n                    this.diagram.removePorts(node, node.ports);\n                }\n                if (node.annotations && node.annotations.length > 0\n                    && (!isBlazor() || isBlazor() && node.annotations[0].content !== '')) {\n                    this.diagram.removeLabels(node, node.annotations);\n                }\n                var parentNode = this.diagram.nameTable[node.parentId];\n                for (var j = node.children.length - 1; j >= 0; j--) {\n                    (this.diagram.nameTable[node.children[j]]).parentId = '';\n                    this.diagram.deleteChild(this.diagram.nameTable[node.children[j]], node);\n                    if (node.parentId && node.children[j]) {\n                        this.diagram.addChild(parentNode, node.children[j]);\n                    }\n                }\n                this.resetDependentConnectors(node.inEdges, true);\n                this.resetDependentConnectors(node.outEdges, false);\n                var entry = {\n                    type: 'UnGroup', undoObject: undoObject,\n                    redoObject: undoObject, category: 'Internal'\n                };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(entry);\n                }\n                if (node.parentId) {\n                    this.diagram.deleteChild(node, parentNode);\n                }\n            }\n            this.diagram.removeNode(node, childCollection);\n            this.clearSelection();\n        }\n        this.diagram.endGroupAction();\n        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.Group;\n        this.diagram.protectPropertyChange(protectedChange);\n    };\n    CommandHandler.prototype.resetDependentConnectors = function (edges, isInEdges) {\n        for (var i = 0; i < edges.length; i++) {\n            var newConnector = this.diagram.nameTable[edges[i]];\n            var undoObject = cloneObject(newConnector);\n            var newProp = void 0;\n            if (isInEdges) {\n                newConnector.targetID = '';\n                newConnector.targetPortID = '';\n                newProp = { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID };\n            }\n            else {\n                newConnector.sourceID = '';\n                newConnector.sourcePortID = '';\n                newProp = { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID };\n            }\n            this.diagram.connectorPropertyChange(newConnector, {}, newProp);\n            var entry = {\n                type: 'ConnectionChanged', undoObject: { connectors: [undoObject], nodes: [] },\n                redoObject: { connectors: [cloneObject(newConnector)], nodes: [] }, category: 'Internal'\n            };\n            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n    };\n    /**\n     * paste method\\\n     *\n     * @returns { void }    paste method .\\\n     * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.paste = function (obj) {\n        if (obj || this.clipboardData.clipObject) {\n            this.diagram.protectPropertyChange(true);\n            var copiedItems = obj ? this.getNewObject(obj) :\n                this.clipboardData.clipObject;\n            if (copiedItems) {\n                var multiSelect = copiedItems.length !== 1;\n                var groupAction = false;\n                var objectTable = {};\n                var keyTable = {};\n                if (this.clipboardData.pasteIndex !== 0) {\n                    this.clearSelection();\n                }\n                if (this.diagram.undoRedoModule) {\n                    groupAction = true;\n                    this.diagram.historyManager.startGroupAction();\n                }\n                for (var _i = 0, copiedItems_1 = copiedItems; _i < copiedItems_1.length; _i++) {\n                    var copy = copiedItems_1[_i];\n                    objectTable[copy.id] = copy;\n                }\n                var copiedObject = [];\n                if (multiSelect) {\n                    // This bool is also consider to prevent selection change event is triggered after every object clone\n                    this.diagram.isServerUpdate = true;\n                }\n                for (var j = 0; j < copiedItems.length; j++) {\n                    var copy = copiedItems[j];\n                    if (getObjectType(copy) === Connector) {\n                        var clonedObj = clone(copy);\n                        var nodeId = clonedObj.sourceID;\n                        clonedObj.sourceID = '';\n                        if (objectTable[nodeId] && keyTable[nodeId]) {\n                            clonedObj.sourceID = keyTable[nodeId];\n                        }\n                        nodeId = clonedObj.targetID;\n                        clonedObj.targetID = '';\n                        if (objectTable[nodeId] && keyTable[nodeId]) {\n                            clonedObj.targetID = keyTable[nodeId];\n                        }\n                        var newObj = this.cloneConnector(clonedObj, multiSelect);\n                        copiedObject.push(newObj);\n                        keyTable[copy.id] = newObj.id;\n                    }\n                    else {\n                        var newNode = this.cloneNode(copy, multiSelect);\n                        if (isBlazor() && newNode && newNode.children && newNode.children.length > 0) {\n                            copiedObject = copiedObject.concat(this.cloneGroupChildCollection);\n                            this.cloneGroupChildCollection = [];\n                        }\n                        else {\n                            copiedObject.push(newNode);\n                        }\n                        //bpmn text annotations will not be pasted\n                        if (newNode) {\n                            keyTable[copy.id] = newNode.id;\n                            var edges = copy.inEdges;\n                            if (edges) {\n                                for (var _a = 0, edges_1 = edges; _a < edges_1.length; _a++) {\n                                    var edge = edges_1[_a];\n                                    if (objectTable[edge] && keyTable[edge]) {\n                                        var newConnector = this.diagram.nameTable[keyTable[edge]];\n                                        newConnector.targetID = keyTable[copy.id];\n                                        this.diagram.connectorPropertyChange(newConnector, { targetID: '', targetPortID: '' }, { targetID: newConnector.targetID, targetPortID: newConnector.targetPortID });\n                                    }\n                                }\n                            }\n                            edges = copy.outEdges;\n                            if (edges) {\n                                for (var _b = 0, edges_2 = edges; _b < edges_2.length; _b++) {\n                                    var edge = edges_2[_b];\n                                    if (objectTable[edge] && keyTable[edge]) {\n                                        var newConnector = this.diagram.nameTable[keyTable[edge]];\n                                        newConnector.sourceID = keyTable[copy.id];\n                                        this.diagram.connectorPropertyChange(newConnector, { sourceID: '', sourcePortID: '' }, { sourceID: newConnector.sourceID, sourcePortID: newConnector.sourcePortID });\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n                if (multiSelect) {\n                    this.diagram.isServerUpdate = false;\n                    this.diagram.UpdateBlazorDiagramModelCollection(copiedItems[0], copiedObject);\n                    this.getBlazorOldValues();\n                    this.diagram.select(copiedObject, true);\n                }\n                if (groupAction === true) {\n                    this.diagram.historyManager.endGroupAction();\n                    groupAction = false;\n                }\n                if (this.diagram.mode !== 'SVG') {\n                    this.diagram.refreshDiagramLayer();\n                }\n                this.clipboardData.pasteIndex++;\n                this.diagram.protectPropertyChange(false);\n            }\n        }\n    };\n    CommandHandler.prototype.getNewObject = function (obj) {\n        var newObj;\n        var newobjs = [];\n        this.clipboardData.pasteIndex = 1;\n        for (var i = 0; i < obj.length; i++) {\n            newObj = cloneObject(obj[i]);\n            newobjs.push(newObj);\n        }\n        return newobjs;\n    };\n    CommandHandler.prototype.cloneConnector = function (connector, multiSelect) {\n        //let newConnector: Node | Connector;\n        var cloneObject = clone(connector);\n        this.translateObject(cloneObject);\n        cloneObject.zIndex = -1;\n        var newConnector = this.diagram.add(cloneObject);\n        if (!this.diagram.isServerUpdate) {\n            this.selectObjects([newConnector], multiSelect);\n        }\n        return newConnector;\n    };\n    CommandHandler.prototype.cloneNode = function (node, multiSelect, children, groupnodeID) {\n        var newNode;\n        var connectorsTable = {};\n        var cloneObject = clone(node);\n        var process;\n        var temp = this.diagram.nameTable[node.parentId];\n        if (node.shape && node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes\n            && node.shape.activity.subProcess.processes.length) {\n            process = cloneObject.shape.activity.subProcess.processes;\n            cloneObject.zIndex = -1;\n            cloneObject.shape.activity.subProcess.processes = undefined;\n        }\n        if (node.shape && node.shape.type === 'SwimLane') {\n            pasteSwimLane(node, this.diagram, this.clipboardData);\n        }\n        else if (temp && temp.shape.type === 'SwimLane') {\n            pasteSwimLane(clone(temp), this.diagram, this.clipboardData, node, true);\n        }\n        else if (node.children && node.children.length && (!children || !children.length)) {\n            newNode = this.cloneGroup(node, multiSelect);\n        }\n        else if (node.shape && ((!isBlazor() && node.shape.shape === 'TextAnnotation') ||\n            (isBlazor() && node.shape.bpmnShape === 'TextAnnotation')) && node.id.indexOf('_textannotation_') !== -1 &&\n            this.diagram.nameTable[node.id]) {\n            var checkAnnotation = node.id.split('_textannotation_');\n            //const parentNode: Node;\n            var annotation = this.diagram.nameTable[node.id];\n            for (var j = 0; j < annotation.inEdges.length; j++) {\n                var connector = this.diagram.nameTable[annotation.inEdges[j]];\n                if (connector) {\n                    var parentNode = this.diagram.nameTable[connector.sourceID];\n                    var clonedNode = this.getAnnotation(parentNode, checkAnnotation[1]);\n                    var annotationNode = {\n                        id: checkAnnotation[1] + randomId(),\n                        angle: clonedNode.angle,\n                        text: clonedNode.text,\n                        length: clonedNode.length,\n                        shape: { shape: 'TextAnnotation', type: 'Bpmn' },\n                        nodeId: clonedNode.nodeId\n                    };\n                    this.diagram.addTextAnnotation(annotationNode, parentNode);\n                }\n            }\n        }\n        else {\n            this.translateObject(cloneObject, groupnodeID);\n            cloneObject.zIndex = -1;\n            if (children) {\n                cloneObject.children = children;\n            }\n            newNode = this.diagram.add(cloneObject);\n        }\n        for (var _i = 0, _a = Object.keys(connectorsTable); _i < _a.length; _i++) {\n            var i = _a[_i];\n            this.diagram.add(connectorsTable[i]);\n        }\n        if (process && process.length) {\n            newNode.shape.activity.subProcess.processes = process;\n            this.cloneSubProcesses(newNode);\n        }\n        if (newNode && !this.diagram.isServerUpdate) {\n            this.selectObjects([newNode], multiSelect);\n        }\n        return newNode;\n    };\n    CommandHandler.prototype.getAnnotation = function (parent, annotationId) {\n        var currentAnnotation = parent.shape.annotations;\n        if (currentAnnotation && currentAnnotation.length) {\n            for (var g = 0; g <= currentAnnotation.length; g++) {\n                if (currentAnnotation[g].id === annotationId) {\n                    return currentAnnotation[g];\n                }\n            }\n        }\n        return undefined;\n    };\n    CommandHandler.prototype.cloneSubProcesses = function (node) {\n        var connector = [];\n        var temp = {};\n        if (node.shape.type === 'Bpmn' && node.shape.activity &&\n            node.shape.activity.subProcess.processes\n            && node.shape.activity.subProcess.processes.length) {\n            var process = node.shape.activity.subProcess.processes;\n            for (var g = 0; g < process.length; g++) {\n                var child = this.diagram.nameTable[process[g]] || this.clipboardData.processTable[process[g]];\n                for (var _i = 0, _a = child.outEdges; _i < _a.length; _i++) {\n                    var j = _a[_i];\n                    if (connector.indexOf(j) < 0) {\n                        connector.push(j);\n                    }\n                }\n                for (var _b = 0, _c = child.inEdges; _b < _c.length; _b++) {\n                    var j = _c[_b];\n                    if (connector.indexOf(j) < 0) {\n                        connector.push(j);\n                    }\n                }\n                var innerChild = cloneObject(this.clipboardData.processTable[process[g]]);\n                innerChild.processId = node.id;\n                var newNode = this.cloneNode(innerChild, false);\n                temp[process[g]] = newNode.id;\n                process[g] = newNode.id;\n                this.diagram.addProcess(newNode, node.id);\n                for (var _d = 0, connector_1 = connector; _d < connector_1.length; _d++) {\n                    var i = connector_1[_d];\n                    var node_1 = this.diagram.nameTable[i] || this.diagram.connectorTable[i];\n                    var clonedNode = cloneObject(node_1);\n                    if (temp[clonedNode.sourceID] && temp[clonedNode.targetID]) {\n                        clonedNode.zIndex = -1;\n                        clonedNode.id += randomId();\n                        clonedNode.sourceID = temp[clonedNode.sourceID];\n                        clonedNode.targetID = temp[clonedNode.targetID];\n                        connector.splice(connector.indexOf(i), 1);\n                        this.diagram.add(clonedNode);\n                    }\n                }\n            }\n        }\n    };\n    CommandHandler.prototype.cloneGroup = function (obj, multiSelect) {\n        var value;\n        var newChildren = [];\n        var children = [];\n        var connectorObj = [];\n        var newObj;\n        var oldID = [];\n        children = children.concat(obj.children);\n        var id = randomId();\n        var objectCollection = [];\n        this.diagram.blazorActions |= BlazorAction.GroupClipboardInProcess;\n        if (this.clipboardData.childTable || obj.children.length > 0) {\n            for (var i = 0; i < children.length; i++) {\n                var childObj = void 0;\n                if (this.clipboardData.childTable) {\n                    childObj = this.clipboardData.childTable[children[i]];\n                }\n                else {\n                    childObj = this.diagram.nameTable[children[i]];\n                }\n                childObj.parentId = '';\n                if (childObj) {\n                    if (getObjectType(childObj) === Connector) {\n                        connectorObj.push(childObj);\n                    }\n                    else {\n                        newObj = this.cloneNode(childObj, multiSelect, undefined, id);\n                        oldID.push(childObj.id);\n                        newChildren.push(newObj.id);\n                        objectCollection.push(newObj);\n                    }\n                }\n            }\n        }\n        for (var k = 0; k < connectorObj.length; k++) {\n            if (connectorObj[k].sourceID || connectorObj[k].targetID) {\n                for (var j = 0; j < oldID.length; j++) {\n                    if (connectorObj[k].sourceID === (oldID[j])) {\n                        connectorObj[k].sourceID += id;\n                    }\n                    if (connectorObj[k].targetID === (oldID[j])) {\n                        connectorObj[k].targetID += id;\n                    }\n                }\n            }\n            newObj = this.cloneConnector(connectorObj[k], multiSelect);\n            newChildren.push(newObj.id);\n            objectCollection.push(newObj);\n        }\n        var parentObj = this.cloneNode(obj, multiSelect, newChildren);\n        objectCollection.push(parentObj);\n        if (parentObj && parentObj.container && parentObj.shape && parentObj.shape.type === 'UmlClassifier') {\n            this.diagram.updateDiagramObject(parentObj);\n            parentObj.wrapper.measure(new Size());\n        }\n        this.diagram.blazorActions &= ~BlazorAction.GroupClipboardInProcess;\n        if (!this.diagram.isServerUpdate) {\n            this.diagram.UpdateBlazorDiagramModelCollection(undefined, objectCollection, undefined, true);\n        }\n        else {\n            this.cloneGroupChildCollection = objectCollection;\n        }\n        return parentObj;\n    };\n    /**\n     * translateObject method\\\n     *\n     * @returns { Object[] }    translateObject method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @param {string} groupnodeID - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.translateObject = function (obj, groupnodeID) {\n        obj.id += groupnodeID || randomId();\n        var diff = this.clipboardData.pasteIndex * 10;\n        if (getObjectType(obj) === Connector) {\n            obj.sourcePoint = {\n                x: obj.sourcePoint.x + diff, y: obj.sourcePoint.y + diff\n            };\n            obj.targetPoint = {\n                x: obj.targetPoint.x + diff, y: obj.targetPoint.y + diff\n            };\n            if (obj.type === 'Bezier') {\n                var segments = obj.segments;\n                for (var i = 0; i < segments.length; i++) {\n                    if (!Point.isEmptyPoint(segments[i].point1)) {\n                        segments[i].point1 = {\n                            x: segments[i].point1.x + diff, y: segments[i].point1.y + diff\n                        };\n                    }\n                    if (!Point.isEmptyPoint(segments[i].point2)) {\n                        segments[i].point2 = {\n                            x: segments[i].point2.x + diff, y: segments[i].point2.y + diff\n                        };\n                    }\n                }\n            }\n            if (obj.type === 'Straight' || obj.type === 'Bezier') {\n                if (obj.segments && obj.segments.length > 0) {\n                    var segments = obj.segments;\n                    for (var i = 0; i < segments.length - 1; i++) {\n                        segments[i].point.x += diff;\n                        segments[i].point.y += diff;\n                    }\n                }\n            }\n        }\n        else {\n            obj.offsetX += diff;\n            obj.offsetY += diff;\n        }\n    };\n    /**\n     * drawObject method\\\n     *\n     * @returns { Node | Connector }    drawObject method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.drawObject = function (obj) {\n        var oldProtectPropertyChangeValue;\n        if (isBlazor()) {\n            oldProtectPropertyChangeValue = this.diagram.getProtectPropertyChangeValue();\n            this.diagram.protectPropertyChange(true);\n        }\n        var newObj;\n        //let cloneObject: Node | Connector;\n        if (obj && obj.shape) {\n            if (obj.shape.type === 'Text') {\n                obj.width = this.diagram.drawingObject.width ? this.diagram.drawingObject.width : 50;\n                obj.height = this.diagram.drawingObject.height ? this.diagram.drawingObject.height : 20;\n            }\n        }\n        var cloneObject = clone(this.diagram.drawingObject);\n        for (var _i = 0, _a = Object.keys(obj); _i < _a.length; _i++) {\n            var prop = _a[_i];\n            cloneObject[prop] = obj[prop];\n        }\n        if (getObjectType(this.diagram.drawingObject) === Node) {\n            newObj = new Node(this.diagram, 'nodes', cloneObject, true);\n            newObj.id = (this.diagram.drawingObject.id || 'node') + randomId();\n        }\n        else {\n            newObj = new Connector(this.diagram, 'connectors', cloneObject, true);\n            newObj.id = (this.diagram.drawingObject.id || 'connector') + randomId();\n        }\n        if (isBlazor()) {\n            updateDefaultValues(newObj, cloneObject, (getObjectType(this.diagram.drawingObject) === Node) ? this.diagram.nodeDefaults : this.diagram.connectorDefaults);\n        }\n        this.diagram.initObject(newObj);\n        this.diagram.updateDiagramObject(newObj);\n        this.diagram.currentDrawingObject = newObj;\n        if (isBlazor()) {\n            this.diagram.protectPropertyChange(oldProtectPropertyChangeValue);\n        }\n        return newObj;\n    };\n    /**\n     * addObjectToDiagram method\\\n     *\n     * @returns { void }    addObjectToDiagram method .\\\n     * @param {Node | Connector} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.addObjectToDiagram = function (obj) {\n        //let newObj: Node | Connector;\n        this.diagram.removeFromAQuad(obj);\n        this.diagram.removeObjectsFromLayer(this.diagram.nameTable[obj.id]);\n        delete this.diagram.nameTable[obj.id];\n        var newObj = this.diagram.add(obj);\n        if (this.diagram.mode !== 'SVG') {\n            this.diagram.refreshDiagramLayer();\n        }\n        this.selectObjects([newObj]);\n        if (obj && (!(canContinuousDraw(this.diagram)))) {\n            this.diagram.tool &= ~DiagramTools.DrawOnce;\n            this.diagram.currentDrawingObject = undefined;\n        }\n    };\n    /**\n     * addObjectToDiagram method\\\n     *\n     * @returns { void }    addObjectToDiagram method .\\\n     * @param {boolean} enable - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.enableServerDataBinding = function (enable) {\n        this.diagram.enableServerDataBinding(enable);\n    };\n    /**\n     * addText method\\\n     *\n     * @returns { void }    addText method .\\\n     * @param {boolean} obj - provide the objects value.\n     * @param {PointModel} currentPosition - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.addText = function (obj, currentPosition) {\n        var annotation = this.diagram.findElementUnderMouse(obj, currentPosition);\n        this.diagram.startTextEdit(obj, annotation instanceof TextElement ? (annotation.id).split('_')[1] : undefined);\n    };\n    CommandHandler.prototype.updateArgsObject = function (obj, arg1, argValue) {\n        if (obj) {\n            var connector = void 0;\n            for (var i = 0; i < obj.length; i++) {\n                connector = (getObjectType(obj[i]) === Connector);\n                if (connector) {\n                    // In Blazor web assembly, deserialize the object. Itb takes time. - Suganthi\n                    //argValue.connectors.push(cloneBlazorObject(obj[i]));\n                    argValue.connectorCollection.push(obj[i].id);\n                }\n                else {\n                    //argValue.nodes.push(cloneBlazorObject(obj[i]));\n                    argValue.nodeCollection.push(obj[i].id);\n                }\n                //connector ? argValue.connectors.push(cloneBlazorObject(obj[i])) : argValue.nodes.push(cloneBlazorObject(obj[i]));\n            }\n        }\n    };\n    CommandHandler.prototype.updateSelectionChangeEventArgs = function (arg, obj, oldValue) {\n        if (isBlazor()) {\n            arg = {\n                cause: this.diagram.diagramActions, newValue: {}, oldValue: {},\n                state: arg.state, type: arg.type, cancel: false\n            };\n            var argOldValue = arg.oldValue;\n            var argNewValue = arg.newValue;\n            argOldValue.connectors = [];\n            argOldValue.nodes = [];\n            argNewValue.connectors = [];\n            argNewValue.nodes = [];\n            argOldValue.nodeCollection = [];\n            argOldValue.connectorCollection = [];\n            argNewValue.nodeCollection = [];\n            argNewValue.connectorCollection = [];\n            this.updateArgsObject(this.getSelectedObject(), arg, argNewValue);\n            this.updateArgsObject(oldValue, arg, argOldValue);\n            return arg;\n        }\n        return arg;\n    };\n    /**\n     * isUserHandle method\\\n     *\n     * @returns { boolean }    isUserHandle method .\\\n     * @param {PointModel} position - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.isUserHandle = function (position) {\n        var handle = this.diagram.selectedItems;\n        if (handle.wrapper && canShowCorner(handle.constraints, 'UserHandle')) {\n            for (var _i = 0, _a = handle.userHandles; _i < _a.length; _i++) {\n                var obj = _a[_i];\n                if (obj.visible) {\n                    var paddedBounds = getUserHandlePosition(handle, obj, this.diagram.scroller.transform);\n                    if (contains(position, paddedBounds, obj.size / (2 * this.diagram.scroller.transform.scale))) {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    };\n    /**\n     * selectObjects method\\\n     *\n     * @returns { Promise<void> }    selectObjects method .\\\n     * @param {(NodeModel | ConnectorModel)[]} obj - provide the objects value.\n     * @param {boolean} multipleSelection - provide the objects value.\n     * @param {(NodeModel | ConnectorModel)[]} oldValue - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.selectObjects = function (obj, multipleSelection, oldValue) {\n        return __awaiter(this, void 0, void 0, function () {\n            var arg, select, canDoMultipleSelection, canDoSingleSelection, i, newObj, i_1, parentNode, blazorArgs, eventObj, selectedObjects, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        arg = {\n                            oldValue: oldValue ? oldValue : this.getSelectedObject(),\n                            newValue: obj, cause: this.diagram.diagramActions,\n                            state: 'Changing', type: 'Addition', cancel: false\n                        };\n                        this.diagram.enableServerDataBinding(false);\n                        select = true;\n                        if (!isBlazor()) {\n                            this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        }\n                        else {\n                            this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n                        }\n                        canDoMultipleSelection = canMultiSelect(this.diagram);\n                        canDoSingleSelection = canSingleSelect(this.diagram);\n                        if (canDoSingleSelection || canDoMultipleSelection) {\n                            if (!canDoMultipleSelection && ((obj.length > 1) || (multipleSelection && obj.length === 1))) {\n                                if (obj.length === 1) {\n                                    this.clearSelection();\n                                }\n                                else {\n                                    return [2 /*return*/];\n                                }\n                            }\n                            if (!canDoSingleSelection && obj.length === 1 && (!multipleSelection || !hasSelection(this.diagram))) {\n                                this.clearSelection();\n                                return [2 /*return*/];\n                            }\n                        }\n                        if (!!arg.cancel) return [3 /*break*/, 5];\n                        for (i = 0; i < obj.length; i++) {\n                            newObj = obj[i];\n                            if (newObj) {\n                                select = true;\n                                if (!hasSelection(this.diagram)) {\n                                    this.select(newObj, i > 0 || multipleSelection, true);\n                                }\n                                else {\n                                    if ((i > 0 || multipleSelection) && newObj.children && !newObj.parentId) {\n                                        for (i_1 = 0; i_1 < this.diagram.selectedItems.nodes.length; i_1++) {\n                                            parentNode = this.diagram.nameTable[this.diagram.selectedItems.nodes[i_1].parentId];\n                                            if (parentNode) {\n                                                parentNode = this.findParent(parentNode);\n                                                if (parentNode) {\n                                                    if (newObj.id === parentNode.id) {\n                                                        this.selectGroup(newObj);\n                                                    }\n                                                }\n                                            }\n                                        }\n                                    }\n                                    this.selectProcesses(newObj);\n                                    select = this.selectBpmnSubProcesses(newObj);\n                                    if (select) {\n                                        this.select(newObj, i > 0 || multipleSelection, true);\n                                    }\n                                }\n                            }\n                        }\n                        arg = {\n                            oldValue: oldValue ? oldValue : [],\n                            newValue: this.getSelectedObject(),\n                            cause: this.diagram.diagramActions, state: 'Changed', type: 'Addition', cancel: false\n                        };\n                        this.diagram.renderSelector(multipleSelection || (obj && obj.length > 1));\n                        this.updateBlazorSelectorModel(oldValue);\n                        if (isBlazor() && this.diagram.selectionChange) {\n                            arg = this.updateSelectionChangeEventArgs(arg, obj, oldValue ? oldValue : []);\n                            this.updateBlazorSelector();\n                        }\n                        if (!!isBlazor()) return [3 /*break*/, 1];\n                        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        return [3 /*break*/, 4];\n                    case 1:\n                        blazorArgs = void 0;\n                        if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3 /*break*/, 3];\n                        eventObj = { 'EventName': 'selectionChange', args: JSON.stringify(arg) };\n                        return [4 /*yield*/, window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n                    case 2:\n                        blazorArgs = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        // let blazorArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        if (blazorArgs && blazorArgs.cancel) {\n                            selectedObjects = [];\n                            if (blazorArgs.oldValue.nodes.length > 0) {\n                                selectedObjects = blazorArgs.oldValue.nodes;\n                            }\n                            if (blazorArgs.oldValue.connectors.length > 0) {\n                                selectedObjects = selectedObjects.concat(blazorArgs.oldValue.connectors);\n                            }\n                            if (selectedObjects) {\n                                if (selectedObjects.length > 0) {\n                                    for (i = 0; i < selectedObjects.length; i++) {\n                                        this.select(this.diagram.nameTable[selectedObjects[i].id], (i !== 0 && selectedObjects.length > 1) ? true : false);\n                                    }\n                                }\n                                else {\n                                    this.clearSelection();\n                                }\n                            }\n                        }\n                        _a.label = 4;\n                    case 4:\n                        this.diagram.enableServerDataBinding(true);\n                        this.updateBlazorSelector();\n                        _a.label = 5;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * updateBlazorSelector method\\\n     *\n     * @returns { void }    updateBlazorSelector method .\\\n     * @private\n     */\n    CommandHandler.prototype.updateBlazorSelector = function () {\n        if (isBlazor() && this.oldSelectedObjects) {\n            this.newSelectedObjects = cloneSelectedObjects(this.diagram);\n            var result = this.deepDiffer.map(cloneObject(this.newSelectedObjects), this.oldSelectedObjects);\n            var diffValue = this.deepDiffer.frameObject({}, result);\n            var diff = this.deepDiffer.removeEmptyValues(diffValue);\n            diff.nodes = [];\n            for (var i = 0; i < this.diagram.selectedItems.nodes.length; i++) {\n                diff.nodes.push(this.diagram.selectedItems.nodes[i].id);\n            }\n            diff.connectors = [];\n            for (var i = 0; i < this.diagram.selectedItems.connectors.length; i++) {\n                diff.connectors.push(this.diagram.selectedItems.connectors[i].id);\n            }\n            var blazorInterop = 'sfBlazor';\n            var blazor = 'Blazor';\n            if (window && window[blazor]) {\n                var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': { selectedItems: diff } };\n                window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n            }\n            this.oldSelectedObjects = undefined;\n            this.newSelectedObjects = undefined;\n        }\n    };\n    /**\n     * findParent method\\\n     *\n     * @returns { Node }    findParent method .\\\n     * @param {Node} node - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.findParent = function (node) {\n        if (node.parentId) {\n            node = this.diagram.nameTable[node.parentId];\n            this.findParent(node);\n        }\n        return node;\n    };\n    CommandHandler.prototype.selectProcesses = function (newObj) {\n        if (this.hasProcesses(newObj)) {\n            var processes = (newObj).shape.activity.subProcess.processes;\n            for (var i = 0; i < processes.length; i++) {\n                var innerChild = this.diagram.nameTable[processes[i]];\n                if (this.hasProcesses(innerChild)) {\n                    this.selectObjects([innerChild], true);\n                }\n                this.unSelect(innerChild);\n            }\n        }\n    };\n    CommandHandler.prototype.selectGroup = function (newObj) {\n        for (var j = 0; j < newObj.children.length; j++) {\n            var innerChild = this.diagram.nameTable[newObj.children[j]];\n            if (innerChild.children) {\n                this.selectGroup(innerChild);\n            }\n            this.unSelect(this.diagram.nameTable[newObj.children[j]]);\n        }\n    };\n    CommandHandler.prototype.selectBpmnSubProcesses = function (node) {\n        var select = true;\n        var parent;\n        if (node.processId) {\n            if (isSelected(this.diagram, this.diagram.nameTable[node.processId])) {\n                select = false;\n            }\n            else {\n                select = this.selectBpmnSubProcesses(this.diagram.nameTable[node.processId]);\n            }\n        }\n        else if (node instanceof Connector) {\n            if (node.sourceID && this.diagram.nameTable[node.sourceID] &&\n                this.diagram.nameTable[node.sourceID].processId) {\n                parent = this.diagram.nameTable[node.sourceID].processId;\n            }\n            if (node.targetID && this.diagram.nameTable[node.targetID] &&\n                this.diagram.nameTable[node.targetID].processId) {\n                parent = this.diagram.nameTable[node.targetID].processId;\n            }\n            if (parent) {\n                if (isSelected(this.diagram, this.diagram.nameTable[parent])) {\n                    return false;\n                }\n                else {\n                    select = this.selectBpmnSubProcesses(this.diagram.nameTable[parent]);\n                }\n            }\n        }\n        else if (node.parentId && this.diagram.nameTable[node.parentId] &&\n            this.diagram.nameTable[node.parentId].shape.type === 'UmlClassifier') {\n            if (isSelected(this.diagram, this.diagram.nameTable[node.parentId])) {\n                select = false;\n            }\n        }\n        return select;\n    };\n    CommandHandler.prototype.hasProcesses = function (node) {\n        if (node) {\n            if ((node.shape.type === 'Bpmn') && node.shape.activity &&\n                node.shape.activity.subProcess.processes &&\n                node.shape.activity.subProcess.processes.length > 0) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * select method\\\n     *\n     * @returns { void }    select method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @param {boolean} multipleSelection - provide the objects value.\n     * @param {boolean} preventUpdate - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.select = function (obj, multipleSelection, preventUpdate) {\n        var hasLayer = this.getObjectLayer(obj.id);\n        if ((canSelect(obj) && !(obj instanceof Selector) && !isSelected(this.diagram, obj))\n            && (hasLayer && !hasLayer.lock && hasLayer.visible) && obj.wrapper.visible) {\n            multipleSelection = hasSelection(this.diagram) ? multipleSelection : false;\n            if (!multipleSelection) {\n                this.clearSelection();\n            }\n            this.diagram.enableServerDataBinding(false);\n            var selectorModel = this.diagram.selectedItems;\n            var convert = obj;\n            if (convert instanceof Node) {\n                if (obj.isHeader) {\n                    var node = this.diagram.nameTable[obj.parentId];\n                    selectorModel.nodes.push(node);\n                }\n                else {\n                    selectorModel.nodes.push(obj);\n                }\n            }\n            else {\n                selectorModel.connectors.push(obj);\n            }\n            if (!multipleSelection) {\n                selectorModel.init(this.diagram);\n                if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n                    var wrapper = gridSelection(this.diagram, selectorModel);\n                    if (wrapper) {\n                        selectorModel.wrapper.children[0] = wrapper;\n                    }\n                    selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n                    selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n                    selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n                }\n            }\n            else {\n                selectorModel.wrapper.rotateAngle = selectorModel.rotateAngle = 0;\n                selectorModel.wrapper.children.push(obj.wrapper);\n            }\n            if (!preventUpdate) {\n                this.diagram.renderSelector(multipleSelection);\n            }\n            this.diagram.enableServerDataBinding(true);\n        }\n    };\n    CommandHandler.prototype.getObjectCollectionId = function (isNode, clearSelection) {\n        var id = [];\n        var i = 0;\n        var selectedObject = isNode ? this.diagram.selectedItems.nodes\n            : this.diagram.selectedItems.connectors;\n        while (!clearSelection && i < selectedObject.length) {\n            id[i] = selectedObject[i].id;\n            i++;\n        }\n        return id;\n    };\n    CommandHandler.prototype.updateBlazorSelectorModel = function (oldItemsCollection, clearSelection) {\n        var blazorInterop = 'sfBlazor';\n        if (window && window[blazorInterop]) {\n            var i = 0;\n            var nodes = [];\n            var connectors = [];\n            var oldItems = [];\n            while (oldItemsCollection && i < oldItemsCollection.length) {\n                oldItems[i] = oldItemsCollection[i].id;\n                i++;\n            }\n            i = 0;\n            nodes = this.getObjectCollectionId(true, clearSelection);\n            connectors = this.getObjectCollectionId(false, clearSelection);\n            var items = { nodes: nodes, connectors: connectors };\n            var newItems = cloneBlazorObject(items);\n            if (window[blazorInterop].updateDiagramCollection) {\n                window[blazorInterop].updateDiagramCollection.call(this.diagram, 'selectedItems', newItems, oldItems, false, true);\n            }\n        }\n    };\n    /**\n     * labelSelect method\\\n     *\n     * @returns { void }    labelSelect method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @param {DiagramElement} textWrapper - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.labelSelect = function (obj, textWrapper) {\n        this.oldSelectedObjects = cloneSelectedObjects(this.diagram);\n        var selectorModel = (this.diagram.selectedItems);\n        var isEnableServerDatabind = this.diagram.allowServerDataBinding;\n        this.diagram.allowServerDataBinding = false;\n        selectorModel.nodes = selectorModel.connectors = [];\n        this.diagram.allowServerDataBinding = isEnableServerDatabind;\n        if (obj instanceof Node) {\n            selectorModel.nodes[0] = obj;\n        }\n        else {\n            selectorModel.connectors[0] = obj;\n        }\n        selectorModel.annotation = (this.findTarget(textWrapper, obj));\n        selectorModel.init(this.diagram);\n        this.diagram.renderSelector(false);\n        this.updateBlazorSelector();\n    };\n    /**\n     * unSelect method\\\n     *\n     * @returns { void }    unSelect method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.unSelect = function (obj) {\n        var objArray = [];\n        objArray.push(obj);\n        var arg = {\n            oldValue: objArray, newValue: [], cause: this.diagram.diagramActions,\n            state: 'Changing', type: 'Removal', cancel: false\n        };\n        if (!this.diagram.currentSymbol) {\n            if (!isBlazor()) {\n                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n            }\n        }\n        if (isSelected(this.diagram, obj)) {\n            var selectormodel = this.diagram.selectedItems;\n            var index = void 0;\n            if (obj instanceof Node) {\n                index = selectormodel.nodes.indexOf(obj, 0);\n                selectormodel.nodes.splice(index, 1);\n            }\n            else {\n                index = selectormodel.connectors.indexOf(obj, 0);\n                selectormodel.connectors.splice(index, 1);\n            }\n            arg = {\n                oldValue: objArray, newValue: [], cause: this.diagram.diagramActions,\n                state: 'Changed', type: 'Removal', cancel: false\n            };\n            this.updateBlazorSelectorModel(objArray);\n            arg = {\n                oldValue: cloneBlazorObject(objArray), newValue: [], cause: this.diagram.diagramActions,\n                state: 'Changed', type: 'Removal', cancel: arg.cancel\n            };\n            if (!arg.cancel) {\n                index = selectormodel.wrapper.children.indexOf(obj.wrapper, 0);\n                selectormodel.wrapper.children.splice(index, 1);\n                this.diagram.updateSelector();\n                if (!this.diagram.currentSymbol) {\n                    if (isBlazor()) {\n                        arg = this.updateSelectionChangeEventArgs(arg, [], objArray);\n                        this.updateBlazorSelector();\n                        if (window && window[this.blazor] && this.diagram.selectionChange) {\n                            var eventObj = { 'EventName': 'selectionChange', args: JSON.stringify(arg) };\n                            window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram);\n                        }\n                    }\n                    else {\n                        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                    }\n                }\n            }\n        }\n    };\n    /**\n     * getChildElements method\\\n     *\n     * @returns { string[] }    getChildElements method .\\\n     * @param {DiagramElement[]} child - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.getChildElements = function (child) {\n        var children = [];\n        for (var i = 0; i < child.length; i++) {\n            var childNode = child[i];\n            if (childNode.children && childNode.children.length > 0) {\n                children.concat(this.getChildElements(childNode.children));\n            }\n            else {\n                children.push(childNode.id);\n                if (childNode instanceof TextElement) {\n                    children.push(childNode.id + '_text');\n                }\n            }\n        }\n        return children;\n    };\n    /**\n     * moveSvgNode method\\\n     *\n     * @returns { void }    moveSvgNode method .\\\n     * @param {string} nodeId - provide the objects value.\n     * @param {string} targetID - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.moveSvgNode = function (nodeId, targetID) {\n        var diagramDiv = getDiagramElement(targetID + '_groupElement', this.diagram.element.id);\n        var backNode = getDiagramElement(nodeId + '_groupElement', this.diagram.element.id);\n        diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n    };\n    /**\n     * sendLayerBackward method\\\n     *\n     * @returns { void }    sendLayerBackward method .\\\n     * @param {string} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.sendLayerBackward = function (layerName) {\n        var layer = this.getLayer(layerName);\n        if (layer && layer.zIndex !== 0) {\n            var index = layer.zIndex;\n            if (this.diagram.mode === 'SVG') {\n                var currentLayerObject = layer.objects;\n                var targetObject = this.getLayer(this.diagram.layerZIndexTable[index - 1]).objects[0];\n                if (targetObject) {\n                    for (var _i = 0, currentLayerObject_1 = currentLayerObject; _i < currentLayerObject_1.length; _i++) {\n                        var obj = currentLayerObject_1[_i];\n                        this.moveSvgNode(obj, targetObject);\n                    }\n                }\n            }\n            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index - 1]);\n            targetLayer.zIndex = targetLayer.zIndex + 1;\n            layer.zIndex = layer.zIndex - 1;\n            var temp = this.diagram.layerZIndexTable[index];\n            this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index - 1];\n            this.diagram.layerZIndexTable[index - 1] = temp;\n            if (this.diagram.mode === 'Canvas') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * bringLayerForward method\\\n     *\n     * @returns { void }    bringLayerForward method .\\\n     * @param {string} layerName - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.bringLayerForward = function (layerName) {\n        var layer = this.getLayer(layerName);\n        if (layer && layer.zIndex < this.diagram.layers.length - 1) {\n            var index = layer.zIndex;\n            var targetLayer = this.getLayer(this.diagram.layerZIndexTable[index + 1]);\n            if (this.diagram.mode === 'SVG') {\n                var currentLayerObject = layer.objects[0];\n                var targetLayerObjects = targetLayer.objects;\n                for (var _i = 0, targetLayerObjects_1 = targetLayerObjects; _i < targetLayerObjects_1.length; _i++) {\n                    var obj = targetLayerObjects_1[_i];\n                    if (obj) {\n                        this.moveSvgNode(obj, currentLayerObject);\n                    }\n                }\n            }\n            targetLayer.zIndex = targetLayer.zIndex - 1;\n            layer.zIndex = layer.zIndex + 1;\n            var temp = this.diagram.layerZIndexTable[index];\n            this.diagram.layerZIndexTable[index] = this.diagram.layerZIndexTable[index + 1];\n            this.diagram.layerZIndexTable[index + 1] = temp;\n            if (this.diagram.mode === 'Canvas') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * sendToBack method\\\n     *\n     * @returns { void }    sendToBack method .\\\n     * @param {NodeModel | ConnectorModel} object - provide the objects value.\n     * @private\n     */\n    CommandHandler.prototype.sendToBack = function (object) {\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || object) {\n            var objectId = (object && object.id);\n            objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var index = this.diagram.nameTable[objectId].zIndex;\n            var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n            var zIndexTable = this.diagram.layers[layerNum].zIndexTable;\n            var undoObject = cloneObject(this.diagram.selectedItems);\n            //Checks whether the selected node is the only node in the node array.\n            //Checks whether it is not a group and the nodes behind it are not it’s children.\n            if (this.diagram.nodes.length !== 1 && (this.diagram.nameTable[objectId].children === undefined ||\n                this.checkObjectBehind(objectId, zIndexTable, index))) {\n                for (var i = index; i > 0; i--) {\n                    if (zIndexTable[i]) {\n                        //When there are empty records in the zindex table\n                        if (!zIndexTable[i - 1]) {\n                            zIndexTable[i - 1] = zIndexTable[i];\n                            this.diagram.nameTable[zIndexTable[i - 1]].zIndex = i;\n                            delete zIndexTable[i];\n                        }\n                        else {\n                            //bringing the objects forward\n                            zIndexTable[i] = zIndexTable[i - 1];\n                            this.diagram.nameTable[zIndexTable[i]].zIndex = i;\n                        }\n                    }\n                }\n                zIndexTable[0] = this.diagram.nameTable[objectId].id;\n                this.diagram.nameTable[objectId].zIndex = 0;\n                if (this.diagram.mode === 'SVG') {\n                    var i = 1;\n                    var target = zIndexTable[i];\n                    // EJ2-49326 - (CR issue fix) An exception raised when send the swimlane back to the normal node.\n                    while (!target && i < index) {\n                        target = zIndexTable[++i];\n                    }\n                    // EJ2-46656 - CR issue fix\n                    target = this.resetTargetNode(objectId, target, i, zIndexTable);\n                    target = this.diagram.nameTable[target].parentId ? this.checkParentExist(target) : target;\n                    this.moveSvgNode(objectId, target);\n                    this.updateNativeNodeIndex(objectId);\n                }\n                else {\n                    this.diagram.refreshCanvasLayers();\n                }\n                var redoObject = cloneObject(this.diagram.selectedItems);\n                var entry = { type: 'SendToBack', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(entry);\n                }\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n        if (isBlazor()) {\n            this.getZIndexObjects();\n        }\n    };\n    CommandHandler.prototype.resetTargetNode = function (objectId, target, i, zIndexTable) {\n        if (this.diagram.nameTable[objectId].shape.type === 'SwimLane'\n            && this.diagram.nameTable[target].parentId != undefined && this.diagram.nameTable[target].parentId != \"\" && this.diagram.nameTable[this.diagram.nameTable[target].parentId].isLane) {\n            i = i + 1;\n            target = zIndexTable[i];\n            return target = this.resetTargetNode(objectId, target, i, zIndexTable);\n        }\n        else {\n            return target;\n        }\n    };\n    CommandHandler.prototype.getZIndexObjects = function () {\n        var element = [];\n        var i;\n        var j;\n        for (i = 0; i < this.diagram.nodes.length; i++) {\n            element.push(this.diagram.nodes[i]);\n        }\n        for (j = 0; j < this.diagram.connectors.length; j++) {\n            element.push(this.diagram.connectors[j]);\n        }\n        this.updateBlazorZIndex(element);\n    };\n    CommandHandler.prototype.updateBlazorZIndex = function (element) {\n        var blazorInterop = 'sfBlazor';\n        var blazor = 'Blazor';\n        var diagramobject = {};\n        var nodeObject = [];\n        var connectorObject = [];\n        var k;\n        if (element && element.length > 0) {\n            for (k = 0; k < element.length; k++) {\n                var elementObject = element[k];\n                if (elementObject instanceof Node) {\n                    nodeObject.push(this.getBlazorObject(elementObject));\n                }\n                else if (elementObject instanceof Connector) {\n                    connectorObject.push(this.getBlazorObject(elementObject));\n                }\n            }\n        }\n        diagramobject = {\n            nodes: nodeObject,\n            connectors: connectorObject\n        };\n        if (window && window[blazor]) {\n            var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': diagramobject };\n            window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n        }\n    };\n    CommandHandler.prototype.getBlazorObject = function (objectName) {\n        var object = {\n            sfIndex: getIndex(this.diagram, objectName.id),\n            zIndex: objectName.zIndex\n        };\n        return object;\n    };\n    //Checks whether the target is a child node.\n    CommandHandler.prototype.checkParentExist = function (target) {\n        var objBehind = target;\n        while (this.diagram.nameTable[objBehind].parentId) {\n            objBehind = this.diagram.nameTable[objBehind].parentId;\n        }\n        return objBehind;\n    };\n    //Checks whether the selected node is not a parent of another node.\n    CommandHandler.prototype.checkObjectBehind = function (objectId, zIndexTable, index) {\n        for (var i = 0; i < index; i++) {\n            var z = zIndexTable[i];\n            if (objectId !== this.diagram.nameTable[z].parentId) {\n                return true;\n            }\n        }\n        return false;\n    };\n    /**\n     * bringToFront method\\\n     *\n     * @returns {  void  }    bringToFront method .\\\n     *  @param {NodeModel | ConnectorModel } obj - Provide the nodeArray element .\n     * @private\n     */\n    CommandHandler.prototype.bringToFront = function (obj) {\n        var _this = this;\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || obj) {\n            var objectName_1 = (obj && obj.id);\n            objectName_1 = objectName_1 || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectName_1));\n            var zIndexTable_1 = this.diagram.layers[layerNum].zIndexTable;\n            var undoObject = cloneObject(this.diagram.selectedItems);\n            //find the maximum zIndex of the tabel\n            var tabelLength = Number(Object.keys(zIndexTable_1).sort(function (a, b) { return Number(a) - Number(b); }).reverse()[0]);\n            var index = this.diagram.nameTable[objectName_1].zIndex;\n            var oldzIndexTable_1 = [];\n            for (var i = 0; i <= tabelLength; i++) {\n                oldzIndexTable_1.push(zIndexTable_1[i]);\n            }\n            for (var i = index; i < tabelLength; i++) {\n                //When there are empty records in the zindex table\n                if (zIndexTable_1[i]) {\n                    if (!zIndexTable_1[i + 1]) {\n                        zIndexTable_1[i + 1] = zIndexTable_1[i];\n                        this.diagram.nameTable[zIndexTable_1[i + 1]].zIndex = i;\n                        delete zIndexTable_1[i];\n                    }\n                    else {\n                        //bringing the objects backward\n                        zIndexTable_1[i] = zIndexTable_1[i + 1];\n                        this.diagram.nameTable[zIndexTable_1[i]].zIndex = i;\n                    }\n                }\n            }\n            zIndexTable_1[tabelLength] = this.diagram.nameTable[objectName_1].id;\n            this.diagram.nameTable[objectName_1].zIndex = tabelLength;\n            if (this.diagram.mode === 'SVG') {\n                var diagramLayer = this.diagram.diagramLayer;\n                //const child: string[] = this.getChildElements(this.diagram.nameTable[objectName].wrapper.children);\n                //const targerNodes: Object = [];\n                var element = getDiagramElement(objectName_1 + '_groupElement', this.diagram.element.id);\n                var nodes = this.diagram.selectedItems.nodes;\n                if (nodes.length > 0 && (nodes[0].shape.type === 'Native' || nodes[0].shape.type === 'HTML')) {\n                    element.parentNode.removeChild(element);\n                    for (var j = 0; j < this.diagram.views.length; j++) {\n                        element = getDiagramElement(objectName_1 + (nodes[0].shape.type === 'HTML' ? '_html_element' : '_content_groupElement'), this.diagram.views[j]);\n                        var lastChildNode = element.parentNode.lastChild;\n                        lastChildNode.parentNode.insertBefore(element, lastChildNode.nextSibling);\n                    }\n                    var htmlLayer = getHTMLLayer(this.diagram.element.id);\n                    this.diagram.diagramRenderer.renderElement(this.diagram.nameTable[objectName_1].wrapper, diagramLayer, htmlLayer);\n                }\n                else {\n                    Object.keys(zIndexTable_1).forEach(function (key) {\n                        var zIndexValue = zIndexTable_1[key];\n                        if ((zIndexValue !== objectName_1) && (_this.diagram.nameTable[zIndexValue].parentId) !== objectName_1) {\n                            //EJ2-42101 - SendToBack and BringToFront not working for connector with group node\n                            //Added @Dheepshiva to restrict the objects with lower zIndex\n                            if (zIndexValue !== undefined &&\n                                (oldzIndexTable_1.indexOf(objectName_1) < oldzIndexTable_1.indexOf(zIndexValue))) {\n                                var objectNode = _this.diagram.nameTable[objectName_1];\n                                var zIndexNode = _this.diagram.nameTable[zIndexValue];\n                                if (objectNode.parentId === '' && zIndexNode.parentId === '' && zIndexNode.parentId === undefined\n                                    && objectNode.parentId !== zIndexNode.id) {\n                                    _this.moveSvgNode(zIndexValue, objectName_1);\n                                    _this.updateNativeNodeIndex(objectName_1);\n                                }\n                                else {\n                                    if (_this.checkGroupNode(objectName_1, zIndexValue, _this.diagram.nameTable)) {\n                                        _this.moveSvgNode(zIndexValue, objectName_1);\n                                        _this.updateNativeNodeIndex(objectName_1);\n                                    }\n                                }\n                            }\n                        }\n                    });\n                }\n            }\n            else {\n                this.diagram.refreshCanvasLayers();\n            }\n            var redoObject = cloneObject(this.diagram.selectedItems);\n            var entry = { type: 'BringToFront', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n            if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                this.addHistoryEntry(entry);\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n        if (isBlazor()) {\n            this.getZIndexObjects();\n        }\n    };\n    CommandHandler.prototype.checkGroupNode = function (selectedNodeName, layerObject, nameTable) {\n        return nameTable[layerObject].parentId === nameTable[selectedNodeName].parentId;\n    };\n    /**\n     * sortByZIndex method\\\n     *\n     * @returns {  Object[] }    sortByZIndex method .\\\n     *  @param { Object[] } nodeArray - Provide the nodeArray element .\n     *  @param { string } sortID - Provide the sortID element .\n     * @private\n     */\n    CommandHandler.prototype.sortByZIndex = function (nodeArray, sortID) {\n        var id = sortID ? sortID : 'zIndex';\n        nodeArray = nodeArray.sort(function (a, b) {\n            return a[id] - b[id];\n        });\n        return nodeArray;\n    };\n    /**\n     * orderCommands method\\\n     *\n     * @returns {  void }    orderCommands method .\\\n     *  @param { boolean } isRedo - Provide the previousObject element .\n     *  @param { Selector } selector - Provide the previousObject element .\n     *  @param { EntryType } action - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.orderCommands = function (isRedo, selector, action) {\n        var selectedObject = selector.nodes;\n        selectedObject = selectedObject.concat(selector.connectors);\n        if (isRedo) {\n            if (action === 'SendBackward') {\n                this.sendBackward(selectedObject[0]);\n            }\n            else if (action === 'SendForward') {\n                this.sendForward(selectedObject[0]);\n            }\n            else if (action === 'BringToFront') {\n                this.bringToFront(selectedObject[0]);\n            }\n            else if (action === 'SendToBack') {\n                this.sendToBack(selectedObject[0]);\n            }\n        }\n        else {\n            var startZIndex = selectedObject[0].zIndex;\n            var endZIndex = this.diagram.nameTable[selectedObject[0].id].zIndex;\n            var undoObject = selectedObject[0];\n            var layer = this.getObjectLayer(undoObject.id);\n            var layerIndex = layer.zIndex;\n            var zIndexTable = layer.zIndexTable;\n            if (action === 'SendBackward' || action === 'SendForward') {\n                for (var i = 0; i < selectedObject.length; i++) {\n                    var undoObject_1 = selectedObject[i];\n                    var layer_2 = this.diagram.layers.indexOf(this.getObjectLayer(undoObject_1.id));\n                    var node = this.diagram.nameTable[selectedObject[i].id];\n                    node.zIndex = undoObject_1.zIndex;\n                    this.diagram.layers[layer_2].zIndexTable[undoObject_1.zIndex] = undoObject_1.id;\n                }\n            }\n            else if (action === 'BringToFront') {\n                var k = 1;\n                for (var j = endZIndex; j > startZIndex; j--) {\n                    if (zIndexTable[j]) {\n                        if (!zIndexTable[j - k]) {\n                            zIndexTable[j - k] = zIndexTable[j];\n                            this.diagram.nameTable[zIndexTable[j - k]].zIndex = j;\n                            delete zIndexTable[j];\n                        }\n                        else {\n                            zIndexTable[j] = zIndexTable[j - k];\n                            this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n                        }\n                    }\n                }\n            }\n            else if (action === 'SendToBack') {\n                for (var j = endZIndex; j < startZIndex; j++) {\n                    if (zIndexTable[j]) {\n                        if (!zIndexTable[j + 1]) {\n                            zIndexTable[j + 1] = zIndexTable[j];\n                            this.diagram.nameTable[zIndexTable[j + 1]].zIndex = j;\n                            delete zIndexTable[j];\n                        }\n                        else {\n                            zIndexTable[j] = zIndexTable[j + 1];\n                            this.diagram.nameTable[zIndexTable[j]].zIndex = j;\n                        }\n                    }\n                }\n            }\n            if (action === 'BringToFront' || action === 'SendToBack') {\n                var node = this.diagram.nameTable[selectedObject[0].id];\n                node.zIndex = undoObject.zIndex;\n                this.diagram.layers[layerIndex].zIndexTable[undoObject.zIndex] = undoObject.id;\n            }\n            if (this.diagram.mode === 'SVG') {\n                if (action === 'SendBackward') {\n                    this.moveObject(selectedObject[1].id, selectedObject[0].id);\n                }\n                else if (action === 'SendForward') {\n                    this.moveObject(selectedObject[0].id, selectedObject[1].id);\n                }\n                else if (action === 'BringToFront') {\n                    this.moveObject(selectedObject[0].id, zIndexTable[selectedObject[0].zIndex + 1]);\n                }\n                else if (action === 'SendToBack') {\n                    var layer_3 = this.getObjectLayer(selectedObject[0].id);\n                    for (var i = 0; i <= selectedObject[0].zIndex; i++) {\n                        if (layer_3.objects[i] !== selectedObject[0].id) {\n                            this.moveSvgNode(layer_3.objects[i], selectedObject[0].id);\n                            this.updateNativeNodeIndex(selectedObject[0].id);\n                        }\n                    }\n                }\n            }\n            else {\n                this.diagram.refreshCanvasLayers();\n            }\n        }\n    };\n    CommandHandler.prototype.moveObject = function (sourceId, targetId) {\n        if (targetId) {\n            this.moveSvgNode(sourceId, targetId);\n            this.updateNativeNodeIndex(sourceId, targetId);\n        }\n    };\n    /**\n     * sendForward method\\\n     *\n     * @returns {  void }    sendForward method .\\\n     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.sendForward = function (obj) {\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || obj) {\n            var nodeId = (obj && obj.id);\n            nodeId = nodeId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var layerIndex = this.diagram.layers.indexOf(this.getObjectLayer(nodeId));\n            var zIndexTable = this.diagram.layers[layerIndex].zIndexTable;\n            //const tabelLength: number = Object.keys(zIndexTable).length;\n            var index = this.diagram.nameTable[nodeId];\n            var intersectArray = [];\n            var temp = this.diagram.spatialSearch.findObjects(index.wrapper.bounds);\n            if (temp.length > 2) {\n                temp = this.sortByZIndex(temp);\n            }\n            for (var _i = 0, temp_1 = temp; _i < temp_1.length; _i++) {\n                var i = temp_1[_i];\n                if (index.id !== i.id) {\n                    var currentLayer = this.getObjectLayer(i.id).zIndex;\n                    if (layerIndex === currentLayer && (Number(this.diagram.nameTable[nodeId].zIndex) < Number(i.zIndex)) &&\n                        index.wrapper.bounds.intersects(i.wrapper.bounds)) {\n                        intersectArray.push(i);\n                        break;\n                    }\n                }\n            }\n            if (intersectArray.length > 0) {\n                var overlapObject = intersectArray[0].zIndex;\n                var currentObject = index.zIndex;\n                var temp_2 = zIndexTable[overlapObject];\n                //swap the nodes\n                var undoObject = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                (this.diagram.nameTable[temp_2] instanceof Node) ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) :\n                    undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n                this.diagram.layers[0].zIndexTable[overlapObject] = index.id;\n                this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n                this.diagram.layers[0].zIndexTable[currentObject] = intersectArray[0].id;\n                this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n                if (this.diagram.mode === 'SVG') {\n                    this.moveSvgNode(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n                    this.updateNativeNodeIndex(zIndexTable[Number(intersectArray[0].zIndex)], nodeId);\n                }\n                else {\n                    this.diagram.refreshCanvasLayers();\n                }\n                var redo = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line\n                (this.diagram.nameTable[temp_2] instanceof Node) ? redo.nodes.push(cloneObject(this.diagram.nameTable[temp_2])) :\n                    redo.connectors.push(cloneObject(this.diagram.nameTable[temp_2]));\n                var historyEntry = {\n                    type: 'SendForward', category: 'Internal',\n                    undoObject: undoObject, redoObject: redo\n                };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(historyEntry);\n                }\n            }\n            if (isBlazor()) {\n                var elements = [];\n                elements.push(index);\n                elements.push(intersectArray[intersectArray.length - 1]);\n                this.updateBlazorZIndex(elements);\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    /**\n     * sendBackward method\\\n     *\n     * @returns {  void }    sendBackward method .\\\n     *  @param {  NodeModel | ConnectorModel } obj - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.sendBackward = function (obj) {\n        this.diagram.protectPropertyChange(true);\n        if (hasSelection(this.diagram) || obj) {\n            var objectId = (obj && obj.id);\n            objectId = objectId || (this.diagram.selectedItems.nodes.length ? this.diagram.selectedItems.nodes[0].id\n                : this.diagram.selectedItems.connectors[0].id);\n            var layerNum = this.diagram.layers.indexOf(this.getObjectLayer(objectId));\n            var zIndexTable = this.diagram.layers[layerNum].zIndexTable;\n            //const tabelLength: number = Object.keys(zIndexTable).length;\n            var node = this.diagram.nameTable[objectId];\n            var intersectArray = [];\n            var temp = this.diagram.spatialSearch.findObjects(node.wrapper.bounds);\n            if (temp.length > 2) {\n                temp = this.sortByZIndex(temp);\n            }\n            for (var _i = 0, temp_3 = temp; _i < temp_3.length; _i++) {\n                var i = temp_3[_i];\n                if (node.id !== i.id) {\n                    var currentLayer = this.getObjectLayer(i.id).zIndex;\n                    if (layerNum === currentLayer && (Number(this.diagram.nameTable[objectId].zIndex) > Number(i.zIndex)) &&\n                        node.wrapper.bounds.intersects(i.wrapper.bounds)) {\n                        intersectArray.push(i);\n                    }\n                }\n            }\n            if (intersectArray.length > 0) {\n                var overlapObject = intersectArray[intersectArray.length - 1].zIndex;\n                var currentObject = node.zIndex;\n                var temp_4 = zIndexTable[overlapObject];\n                var undoObject = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line\n                (this.diagram.nameTable[temp_4] instanceof Node) ? undoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) :\n                    undoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4]));\n                //swap the nodes\n                zIndexTable[overlapObject] = node.id;\n                this.diagram.nameTable[zIndexTable[overlapObject]].zIndex = overlapObject;\n                zIndexTable[currentObject] = intersectArray[intersectArray.length - 1].id;\n                this.diagram.nameTable[zIndexTable[currentObject]].zIndex = currentObject;\n                if (this.diagram.mode === 'SVG') {\n                    if (!(node.children && node.children.length > 0)) {\n                        var tempChild = zIndexTable[intersectArray[intersectArray.length - 1].zIndex];\n                        if (intersectArray[intersectArray.length - 1].children && intersectArray[intersectArray.length - 1].children.length !== 0) {\n                            var tempParent = intersectArray[intersectArray.length - 1];\n                            tempChild = tempParent.children[0];\n                        }\n                        var checkChild = this.diagram.getObject(tempChild);\n                        if (checkChild.children && checkChild.children.length !== 0) {\n                            tempChild = checkChild.children[0];\n                        }\n                        this.moveSvgNode(objectId, tempChild);\n                        this.updateNativeNodeIndex(objectId, tempChild);\n                        if (isBlazor()) {\n                            var elements = [];\n                            elements.push(node);\n                            elements.push(intersectArray[intersectArray.length - 1]);\n                            this.updateBlazorZIndex(elements);\n                        }\n                    }\n                }\n                else {\n                    this.diagram.refreshCanvasLayers();\n                }\n                var redoObject = cloneObject(this.diagram.selectedItems);\n                // eslint-disable-next-line @typescript-eslint/no-unused-expressions\n                (this.diagram.nameTable[temp_4] instanceof Node) ? redoObject.nodes.push(cloneObject(this.diagram.nameTable[temp_4])) :\n                    redoObject.connectors.push(cloneObject(this.diagram.nameTable[temp_4]));\n                var entry = { type: 'SendBackward', category: 'Internal', undoObject: undoObject, redoObject: redoObject };\n                if (!(this.diagram.diagramActions & DiagramAction.UndoRedo)) {\n                    this.addHistoryEntry(entry);\n                }\n                //swap the nodes\n            }\n        }\n        this.diagram.protectPropertyChange(false);\n    };\n    /**\n     * updateNativeNodeIndex method\\\n     *\n     * @returns {  void }    updateNativeNodeIndex method .\\\n     *  @param { string } nodeId - Provide the previousObject element .\n     *  @param { string } targetID - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.updateNativeNodeIndex = function (nodeId, targetID) {\n        var node = this.diagram.selectedItems.nodes[0] || this.diagram.getObject(targetID);\n        for (var i = 0; i < this.diagram.views.length; i++) {\n            if (node && (node.shape.type === 'HTML'\n                || node.shape.type === 'Native')) {\n                var id = node.shape.type === 'HTML' ? '_html_element' : '_content_groupElement';\n                var backNode = getDiagramElement(nodeId + id, this.diagram.views[i]);\n                var diagramDiv = targetID ? getDiagramElement(targetID + id, this.diagram.views[i])\n                    : backNode.parentElement.firstChild;\n                if (backNode.parentNode.id === diagramDiv.parentNode.id) {\n                    diagramDiv.parentNode.insertBefore(backNode, diagramDiv);\n                }\n            }\n        }\n    };\n    /**\n     * initSelectorWrapper method\\\n     *\n     * @returns {  void }    initSelectorWrapper method .\\\n     * @private\n     */\n    CommandHandler.prototype.initSelectorWrapper = function () {\n        var selectorModel = this.diagram.selectedItems;\n        selectorModel.init(this.diagram);\n        if (selectorModel.nodes.length === 1 && selectorModel.connectors.length === 0) {\n            selectorModel.rotateAngle = selectorModel.nodes[0].rotateAngle;\n            selectorModel.wrapper.rotateAngle = selectorModel.nodes[0].rotateAngle;\n            selectorModel.wrapper.pivot = selectorModel.nodes[0].pivot;\n        }\n    };\n    /**\n     * doRubberBandSelection method\\\n     *\n     * @returns {  void }    doRubberBandSelection method .\\\n     *  @param { Rect } region - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.doRubberBandSelection = function (region) {\n        this.clearSelectionRectangle();\n        var selArray = [];\n        var rubberArray = [];\n        selArray = this.diagram.getNodesConnectors(selArray);\n        if (this.diagram.selectedItems.rubberBandSelectionMode === 'CompleteIntersect') {\n            rubberArray = completeRegion(region, selArray);\n        }\n        else {\n            rubberArray = this.diagram.spatialSearch.findObjects(region);\n        }\n        if (rubberArray.length) {\n            this.selectObjects(rubberArray, true);\n        }\n    };\n    CommandHandler.prototype.clearSelectionRectangle = function () {\n        var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n        var element = adornerSvg.getElementById(this.diagram.element.id + '_diagramAdorner_selected_region');\n        if (element) {\n            remove(element);\n        }\n    };\n    /**\n     * dragConnectorEnds method\\\n     *\n     * @returns {  void }    dragConnectorEnds method .\\\n     *  @param { string } endPoint - Provide the previousObject element .\n     *  @param { IElement } obj - Provide the previousObject element .\n     *  @param { PointModel } point - Provide the point element .\n     *  @param { BezierSegmentModel } segment - Provide the segment element .\n     *  @param { IElement } target - Provide the target element .\n     *  @param { string } targetPortId - Provide the targetPortId element .\n     * @private\n     */\n    CommandHandler.prototype.dragConnectorEnds = function (endPoint, obj, point, segment, target, targetPortId) {\n        var selectorModel;\n        var connector; //let node: Node;\n        var tx; //let segmentPoint: PointModel;\n        var ty; //let index: number;\n        var checkBezierThumb = false;\n        if (obj instanceof Selector) {\n            selectorModel = obj;\n            connector = selectorModel.connectors[0];\n        }\n        else if (obj instanceof Connector && this.diagram.currentDrawingObject) {\n            this.clearSelection();\n            connector = this.diagram.currentDrawingObject;\n        }\n        if (endPoint === 'BezierSourceThumb' || endPoint === 'BezierTargetThumb') {\n            checkBezierThumb = true;\n        }\n        if (endPoint === 'ConnectorSourceEnd' || endPoint === 'BezierSourceThumb') {\n            tx = point.x - (checkBezierThumb ? segment.bezierPoint1.x : connector.sourcePoint.x);\n            ty = point.y - (checkBezierThumb ? segment.bezierPoint1.y : connector.sourcePoint.y);\n            return this.dragSourceEnd(connector, tx, ty, null, point, endPoint, undefined, target, targetPortId, undefined, segment);\n        }\n        else {\n            tx = point.x - (checkBezierThumb ? segment.bezierPoint2.x : connector.targetPoint.x);\n            ty = point.y - (checkBezierThumb ? segment.bezierPoint2.y : connector.targetPoint.y);\n            return this.dragTargetEnd(connector, tx, ty, null, point, endPoint, undefined, segment);\n        }\n    };\n    /**\n     * getSelectedObject method\\\n     *\n     * @returns {  void }    getSelectedObject method .\\\n     * @private\n     */\n    CommandHandler.prototype.getSelectedObject = function () {\n        var selectormodel = this.diagram.selectedItems;\n        return (selectormodel.nodes).concat(selectormodel.connectors);\n    };\n    /**\n     * updateBlazorProperties method\\\n     *\n     * @returns {  void }    updateBlazorProperties method .\\\n     *  @param { boolean } isObjectInteraction - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.updateBlazorProperties = function (isObjectInteraction) {\n        var blazorInterop = 'sfBlazor';\n        var blazor = 'Blazor';\n        if (!isObjectInteraction) {\n            if (window && window[blazor]) {\n                var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.diagramObject };\n                window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n            }\n        }\n        else {\n            if (window && window[blazor] && JSON.stringify(this.deepDiffer.diagramObject) !== '{}') {\n                var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': this.deepDiffer.diagramObject };\n                if (!this.diagram.isLoading) {\n                    window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n                }\n            }\n        }\n        //this.diagram.enableServerDataBinding(true);\n        this.deepDiffer.newNodeObject = [];\n        this.deepDiffer.newConnectorObject = [];\n        this.diagramObject = [];\n        this.diagram.oldNodeObjects = [];\n        this.diagram.oldConnectorObjects = [];\n    };\n    /**\n     * enableCloneObject method\\\n     *\n     * @returns {  void }    enableCloneObject method .\\\n     *  @param { boolean } value - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.enableCloneObject = function (value) {\n        if ((!this.diagram.lineRoutingModule || !(this.diagram.constraints & DiagramConstraints.LineRouting))) {\n            this.diagram.canEnableBlazorObject = value;\n        }\n    };\n    /**\n     * ismouseEvents method\\\n     *\n     * @returns {  void }    ismouseEvents method .\\\n     *  @param { boolean } value - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.ismouseEvents = function (value) {\n        if (value) {\n            this.diagram.blazorActions = this.diagram.addConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n        }\n        else {\n            this.diagram.blazorActions = this.diagram.removeConstraints(this.diagram.blazorActions, BlazorAction.interaction);\n        }\n    };\n    /**\n     * updateLayerObject method\\\n     *\n     * @returns {  void }    updateLayerObject method .\\\n     *  @param { object } oldDiagram - Provide the previousObject element .\n     *  @param { boolean } temp - Provide the temp element .\n     * @private\n     */\n    CommandHandler.prototype.updateLayerObject = function (oldDiagram, temp) {\n        if (isBlazor()) {\n            var diffLayers = {};\n            diffLayers = this.deepDiffer.getLayerObject(oldDiagram, temp, this.diagram);\n            this.diagramObject = diffLayers;\n            this.updateBlazorProperties();\n        }\n    };\n    /* tslint:enable:no-string-literal */\n    /**\n     * getDiagramOldValues method\\\n     *\n     * @returns {  void }    getDiagramOldValues method .\\\n     *  @param { object } oldDiagram - Provide the previousObject element .\n     *  @param { string[] } attribute - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.getDiagramOldValues = function (oldDiagram, attribute) {\n        var newDiagram = {};\n        for (var i = 0; i < attribute.length; i++) {\n            newDiagram[attribute[i]] = cloneObject(this.diagram[attribute[i]]);\n        }\n        var newObject = cloneObject(newDiagram);\n        var result = this.deepDiffer.map(newObject, oldDiagram);\n        var diffValue = this.deepDiffer.frameObject({}, result);\n        var diff = this.deepDiffer.removeEmptyValues(diffValue);\n        diff = this.deepDiffer.changeSegments(diff, newObject);\n        this.diagramObject = diff;\n        if (!(this.diagram.blazorActions & BlazorAction.ClearObject)) {\n            this.updateBlazorProperties();\n        }\n    };\n    /* tslint:disable */\n    /**\n     * getBlazorOldValues method\\\n     *\n     * @returns {  void }    getBlazorOldValues method .\\\n     *  @param { MouseEventArgs } args - Provide the previousObject element .\n     *  @param { boolean } labelDrag - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.getBlazorOldValues = function (args, labelDrag) {\n        if (isBlazor()) {\n            var oldNodeObject = this.diagram.oldNodeObjects;\n            for (var i = 0; i < oldNodeObject.length; i++) {\n                if (oldNodeObject[i].id) {\n                    if (this.diagram.oldNodeObjects[i] instanceof Node) {\n                        this.diagram.oldNodeObjects[i] = cloneBlazorObject(this.diagram.oldNodeObjects[i]);\n                    }\n                    this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldNodeObject[i].id], args, labelDrag, this.diagram);\n                }\n            }\n            var oldConnectorObject = this.diagram.oldConnectorObjects;\n            for (var i = 0; i < oldConnectorObject.length; i++) {\n                if (oldConnectorObject[i].id) {\n                    if (this.diagram.oldConnectorObjects[i] instanceof Connector) {\n                        this.diagram.oldConnectorObjects[i] = cloneBlazorObject(this.diagram.oldConnectorObjects[i]);\n                    }\n                    this.deepDiffer.getDifferenceValues(this.diagram.nameTable[oldConnectorObject[i].id], args, labelDrag, this.diagram);\n                }\n            }\n            if (oldNodeObject.length > 0 || oldConnectorObject.length > 0) {\n                this.updateBlazorProperties(true);\n            }\n        }\n    };\n    /**\n     * getObjectChanges method\\\n     *\n     * @returns {  void }    getObjectChanges method .\\\n     *  @param { Object[] } previousObject - Provide the previousObject element .\n     *  @param { Object[] } currentObject - Provide the previousObject element .\n     *  @param { Object[] } previousObject - Provide the previousObject element .\n     * @private\n     */\n    CommandHandler.prototype.getObjectChanges = function (previousObject, currentObject, changedNodes) {\n        for (var i = 0; i < previousObject.length; i++) {\n            var value = this.deepDiffer.map(currentObject[i], previousObject[i]);\n            var result = this.deepDiffer.frameObject({}, value);\n            var change = this.deepDiffer.removeEmptyValues(result);\n            if (change.children) {\n                change.children = cloneObject(currentObject[i]).children;\n            }\n            change = this.deepDiffer.changeSegments(change, currentObject[i]);\n            change.sfIndex = getIndex(this.diagram, currentObject[i].id);\n            changedNodes.push(change);\n        }\n    };\n    /**\n     * clearObjectSelection method\\\n     *\n     * @returns {  void }    clearObjectSelection method .\\\n     *  @param { (NodeModel | ConnectorModel) } mouseDownElement - Provide the triggerAction element .\n     * @private\n     */\n    // Bug fix - EJ2-44495 -Node does not gets selected on slight movement of mouse when drag constraints disabled for node\n    CommandHandler.prototype.clearObjectSelection = function (mouseDownElement) {\n        var selectedItems = this.diagram.selectedItems;\n        var list = [];\n        list = list.concat(selectedItems.nodes, selectedItems.connectors);\n        if (list.indexOf(mouseDownElement) === -1) {\n            this.clearSelection((list.length > 0) ? true : false);\n            this.selectObjects([mouseDownElement], true);\n        }\n    };\n    /**\n     * clearSelection method\\\n     *\n     * @returns {  void }    clearSelection method .\\\n     *  @param { boolean } triggerAction - Provide the triggerAction element .\n     *  @param { boolean } isTriggered - Provide the isTriggered element .\n     * @private\n     */\n    CommandHandler.prototype.clearSelection = function (triggerAction, isTriggered) {\n        return __awaiter(this, void 0, void 0, function () {\n            var enableServerDataBinding, selectormodel, arrayNodes, arg, blazarArgs, eventObj, selectNodes, i;\n            return __generator(this, function (_a) {\n                switch (_a.label) {\n                    case 0:\n                        enableServerDataBinding = this.diagram.allowServerDataBinding;\n                        this.diagram.enableServerDataBinding(false);\n                        if (!hasSelection(this.diagram)) return [3 /*break*/, 5];\n                        selectormodel = this.diagram.selectedItems;\n                        arrayNodes = this.getSelectedObject();\n                        if (this.diagram.currentSymbol) {\n                            this.diagram.previousSelectedObject = arrayNodes;\n                        }\n                        arg = {\n                            oldValue: arrayNodes, newValue: [], cause: this.diagram.diagramActions,\n                            state: 'Changing', type: 'Removal', cancel: false\n                        };\n                        this.updateBlazorSelectorModel(arrayNodes, true);\n                        if (triggerAction) {\n                            if (!isBlazor()) {\n                                this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                            }\n                            else {\n                                this.oldSelectedObjects = cloneObject(selectormodel);\n                            }\n                        }\n                        if (!!arg.cancel) return [3 /*break*/, 4];\n                        selectormodel.offsetX = 0;\n                        selectormodel.offsetY = 0;\n                        selectormodel.width = 0;\n                        selectormodel.height = 0;\n                        selectormodel.rotateAngle = 0;\n                        selectormodel.nodes = [];\n                        selectormodel.connectors = [];\n                        selectormodel.wrapper = null;\n                        selectormodel.annotation = undefined;\n                        this.diagram.clearSelectorLayer();\n                        if (!triggerAction) return [3 /*break*/, 4];\n                        arg = {\n                            oldValue: cloneBlazorObject(arrayNodes), newValue: [], cause: this.diagram.diagramActions,\n                            state: 'Changed', type: 'Removal', cancel: false\n                        };\n                        if (isBlazor()) {\n                            arg = this.updateSelectionChangeEventArgs(arg, [], arrayNodes);\n                            this.updateBlazorSelector();\n                        }\n                        if (!!isBlazor()) return [3 /*break*/, 1];\n                        this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        return [3 /*break*/, 4];\n                    case 1:\n                        blazarArgs = void 0;\n                        if (!(window && window[this.blazor] && this.diagram.selectionChange)) return [3 /*break*/, 3];\n                        eventObj = { 'EventName': 'selectionChange', args: JSON.stringify(arg) };\n                        return [4 /*yield*/, window[this.blazorInterop].updateBlazorDiagramEvents(eventObj, this.diagram)];\n                    case 2:\n                        blazarArgs = _a.sent();\n                        _a.label = 3;\n                    case 3:\n                        // let blazarArgs: void | object = await this.diagram.triggerEvent(DiagramEvent.selectionChange, arg);\n                        if (blazarArgs && blazarArgs.cancel && !isTriggered) {\n                            selectNodes = [];\n                            if (blazarArgs.oldValue.nodes.length > 0) {\n                                selectNodes = blazarArgs.oldValue.nodes;\n                            }\n                            if (blazarArgs.oldValue.connectors.length > 0) {\n                                selectNodes = selectNodes.concat(blazarArgs.oldValue.connectors);\n                            }\n                            if (selectNodes) {\n                                for (i = 0; i < selectNodes.length; i++) {\n                                    this.select(this.diagram.nameTable[selectNodes[i].id], (i !== 0 && selectNodes.length > 1) ? true : false);\n                                }\n                            }\n                        }\n                        _a.label = 4;\n                    case 4:\n                        this.updateBlazorSelector();\n                        this.diagram.enableServerDataBinding(enableServerDataBinding);\n                        _a.label = 5;\n                    case 5: return [2 /*return*/];\n                }\n            });\n        });\n    };\n    /**\n     * clearSelectedItems method\\\n     *\n     * @returns {  void }    clearSelectedItems method .\\\n     * @private\n     */\n    CommandHandler.prototype.clearSelectedItems = function () {\n        var selectedNodes = this.diagram.selectedItems.nodes ? this.diagram.selectedItems.nodes.length : 0;\n        var selectedConnectors = this.diagram.selectedItems.connectors ? this.diagram.selectedItems.connectors.length : 0;\n        this.clearSelection((selectedNodes + selectedConnectors) > 0 ? true : false);\n    };\n    /**\n     * removeStackHighlighter method\\\n     *\n     * @returns {  void }    removeStackHighlighter method .\\\n     * @private\n     */\n    CommandHandler.prototype.removeStackHighlighter = function () {\n        var adornerSvg = getAdornerLayerSvg(this.diagram.element.id);\n        var highlighter = adornerSvg.getElementById(adornerSvg.id + '_stack_highlighter');\n        if (highlighter) {\n            highlighter.parentNode.removeChild(highlighter);\n        }\n    };\n    /**\n     * @param {End} args - provide the args  value.\n     * @param {IElement} target - provide the target  value.\n     * @private\n     */\n    CommandHandler.prototype.renderStackHighlighter = function (args, target) {\n        var source = this.diagram.selectedItems.nodes[0];\n        var symbolDrag;\n        var node;\n        var selectorModel;\n        if (!target) {\n            var objects = this.diagram.findObjectsUnderMouse(args.position);\n            target = this.diagram.findObjectUnderMouse(objects, 'Drag', true);\n            if (target && !(target.isLane || target.isPhase || target.isHeader)) {\n                for (var i = 0; i < objects.length; i++) {\n                    var laneNode = this.diagram.nameTable[objects[i].id];\n                    if (!laneNode.isLane || laneNode.isPhase || laneNode.isHeader) {\n                        target = laneNode;\n                        this.diagram.parentObject = target;\n                    }\n                }\n            }\n        }\n        if (source && target && target.isLane && source.shape && !source.shape.isPhase) {\n            node = this.diagram.nameTable[target.parentId];\n            if (this.diagram.currentSymbol && node.shape.type === 'SwimLane') {\n                symbolDrag = true;\n            }\n            if ((source && !source.parentId && source.shape.type !== 'SwimLane') ||\n                (source && source.parentId && this.diagram.nameTable[source.parentId] && this.diagram.nameTable[source.parentId].isLane &&\n                    (source.parentId !== target.parentId && source.parentId !== target.id))) {\n                selectorModel = this.diagram.selectedItems;\n                var canvas = gridSelection(this.diagram, selectorModel, target.id, true);\n                if (canvas) {\n                    selectorModel.wrapper.children[0] = canvas;\n                }\n                this.diagram.renderSelector(false, true);\n                selectorModel.wrapper.children[0] = selectorModel.nodes[0].wrapper;\n            }\n        }\n        if (source && target && target.parentId && source.shape && source.shape.isPhase) {\n            var node_2 = this.diagram.nameTable[target.parentId];\n            if (node_2.shape.type === 'SwimLane') {\n                this.diagram.selectedItems.wrapper.children[0] = this.diagram.nameTable[target.parentId].wrapper;\n                this.diagram.renderSelector(false, true);\n            }\n        }\n        if ((symbolDrag && this.diagram.currentSymbol.shape.isLane) || (source && target &&\n            source.parentId && target.parentId && !source.isPhase && (source.parentId === target.parentId)\n            && (source.id !== target.id) && node &&\n            (node.container && (node.container.type === 'Stack' || node.container.type === 'Grid')))) {\n            var canvas = void 0;\n            var value = node.container.orientation === 'Vertical';\n            var isVertical = node.container === 'Stack' ? value : !value;\n            if (node.container.type === 'Grid' && target.isLane &&\n                ((!this.diagram.currentSymbol &&\n                    (node.shape.orientation === 'Horizontal' && target.rowIndex !== source.rowIndex) ||\n                    (node.shape.orientation === 'Vertical' && target.columnIndex !== source.columnIndex))\n                    || (this.diagram.currentSymbol &&\n                        this.diagram.currentSymbol.shape.orientation === node.container.orientation))) {\n                selectorModel = this.diagram.selectedItems;\n                if ((source.isLane && canLaneInterchange(source, this.diagram)) || !source.isLane) {\n                    canvas = gridSelection(this.diagram, selectorModel, target.id, symbolDrag);\n                }\n            }\n            var wrapper = node.container.type === 'Stack' ? target.wrapper : canvas;\n            if (wrapper) {\n                renderStackHighlighter(wrapper, isVertical, args.position, this.diagram, false, true);\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.insertBlazorConnector = function (obj) {\n        if (obj instanceof Selector) {\n            for (var i = 0; i < obj.connectors.length; i++) {\n                this.diagram.insertBlazorConnector(obj.connectors[i]);\n            }\n        }\n        else {\n            this.diagram.insertBlazorConnector(obj);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drag = function (obj, tx, ty) {\n        var tempNode;\n        var elements = [];\n        if (canMove(obj) && this.checkBoundaryConstraints(tx, ty, obj.wrapper.bounds) && canPageEditable(this.diagram)) {\n            if (obj instanceof Node) {\n                var oldValues = { offsetX: obj.offsetX, offsetY: obj.offsetY };\n                obj.offsetX += tx;\n                obj.offsetY += ty;\n                if (obj.children && !(obj.container)) {\n                    if (!(checkParentAsContainer(this.diagram, obj, true))) {\n                        this.diagram.diagramActions = this.diagram.diagramActions | DiagramAction.isGroupDragging;\n                    }\n                    var nodes = this.getAllDescendants(obj, elements);\n                    for (var i = 0; i < nodes.length; i++) {\n                        tempNode = (this.diagram.nameTable[nodes[i].id]);\n                        this.drag(tempNode, tx, ty);\n                    }\n                    this.updateInnerParentProperties(obj);\n                    this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.isGroupDragging;\n                }\n                if (checkParentAsContainer(this.diagram, obj, true)) {\n                    checkChildNodeInContainer(this.diagram, obj);\n                }\n                else {\n                    if (obj && obj.shape && obj.shape.type === 'UmlClassifier') {\n                        obj.wrapper.measureChildren = true;\n                    }\n                    this.diagram.nodePropertyChange(obj, oldValues, { offsetX: obj.offsetX, offsetY: obj.offsetY }, undefined, undefined, false);\n                    obj.wrapper.measureChildren = false;\n                }\n                if (obj.shape.type === 'SwimLane' && !this.diagram.currentSymbol) {\n                    var grid = obj.wrapper.children[0];\n                    var connectors = getConnectors(this.diagram, grid, 0, true);\n                    updateConnectorsProperties(connectors, this.diagram);\n                }\n            }\n            else {\n                var connector = obj;\n                var oldValues = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                var update = connector.type === 'Bezier' ? true : false;\n                var hasEnds = false;\n                if (!connector.sourceWrapper) {\n                    this.dragSourceEnd(connector, tx, ty, true, null, '', update);\n                }\n                else {\n                    hasEnds = true;\n                }\n                if (!connector.targetWrapper) {\n                    this.dragTargetEnd(connector, tx, ty, true, null, '', update);\n                }\n                else {\n                    hasEnds = true;\n                }\n                var canDragPoints = false;\n                if (obj instanceof Connector) {\n                    canDragPoints = true;\n                }\n                if (!hasEnds || canDragPoints) {\n                    this.dragControlPoint(connector, tx, ty, true);\n                    var conn = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                    this.diagram.connectorPropertyChange(connector, oldValues, conn);\n                }\n            }\n        }\n    };\n    /**   @private  */\n    CommandHandler.prototype.connectorSegmentChange = function (actualObject, existingInnerBounds, isRotate) {\n        var tx;\n        var ty;\n        var segmentChange = true;\n        if (existingInnerBounds.equals(existingInnerBounds, actualObject.wrapper.bounds) === false) {\n            if (actualObject.outEdges.length > 0) {\n                for (var k = 0; k < actualObject.outEdges.length; k++) {\n                    var connector = this.diagram.nameTable[actualObject.outEdges[k]];\n                    if (connector.targetID !== '') {\n                        segmentChange = this.isSelected(this.diagram.nameTable[connector.targetID]) ? false : true;\n                    }\n                    else {\n                        segmentChange = this.isSelected(this.diagram.nameTable[connector.id]) ? false : true;\n                    }\n                    if (connector.type === 'Orthogonal' && connector.segments && connector.segments.length > 1) {\n                        if (!isRotate) {\n                            if (segmentChange) {\n                                switch (connector.segments[0].direction) {\n                                    case 'Bottom':\n                                        tx = actualObject.wrapper.bounds.bottomCenter.x - existingInnerBounds.bottomCenter.x;\n                                        ty = actualObject.wrapper.bounds.bottomCenter.y - existingInnerBounds.bottomCenter.y;\n                                        break;\n                                    case 'Top':\n                                        tx = actualObject.wrapper.bounds.topCenter.x - existingInnerBounds.topCenter.x;\n                                        ty = actualObject.wrapper.bounds.topCenter.y - existingInnerBounds.topCenter.y;\n                                        break;\n                                    case 'Left':\n                                        tx = actualObject.wrapper.bounds.middleLeft.x - existingInnerBounds.middleLeft.x;\n                                        ty = actualObject.wrapper.bounds.middleLeft.y - existingInnerBounds.middleLeft.y;\n                                        break;\n                                    case 'Right':\n                                        tx = actualObject.wrapper.bounds.middleRight.x - existingInnerBounds.middleRight.x;\n                                        ty = actualObject.wrapper.bounds.middleRight.y - existingInnerBounds.middleRight.y;\n                                        break;\n                                }\n                                this.dragSourceEnd(connector, tx, ty, true, null, 'ConnectorSourceEnd', undefined, undefined, undefined, (actualObject.parentId &&\n                                    (this.diagram.diagramActions & DiagramAction.isGroupDragging)) ? false : true);\n                            }\n                        }\n                        else {\n                            var firstSegment = connector.segments[0];\n                            var secondSegment = connector.segments[1];\n                            var cornerPoints = swapBounds(actualObject.wrapper, actualObject.wrapper.corners, actualObject.wrapper.bounds);\n                            var sourcePoint = findPoint(cornerPoints, firstSegment.direction);\n                            sourcePoint = getIntersection(connector, connector.sourceWrapper, sourcePoint, { x: connector.sourceWrapper.offsetX, y: connector.sourceWrapper.offsetY }, false);\n                            var source = {\n                                corners: undefined, point: sourcePoint, margin: undefined, direction: firstSegment.direction\n                            };\n                            var target = {\n                                corners: undefined, point: secondSegment.points[1], margin: undefined, direction: undefined\n                            };\n                            var intermediatePoints = orthoConnection2Segment(source, target);\n                            firstSegment.length = Point.distancePoints(intermediatePoints[0], intermediatePoints[1]);\n                            if (secondSegment.direction && secondSegment.length) {\n                                secondSegment.length = Point.distancePoints(intermediatePoints[1], intermediatePoints[2]);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.updateEndPoint = function (connector, oldChanges) {\n        var conn = {\n            sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint,\n            sourceID: connector.sourceID ? connector.sourceID : undefined,\n            targetID: connector.targetID ? connector.targetID : undefined,\n            sourcePortID: connector.sourcePortID ? connector.sourcePortID : undefined,\n            targetPortID: connector.targetPortID ? connector.targetPortID : undefined,\n            segments: connector.segments ? connector.segments : undefined\n        };\n        var newValue = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n        if (connector.sourceID) {\n            newValue.sourceID = connector.sourceID;\n        }\n        if (connector.targetID) {\n            newValue.targetID = connector.targetID;\n        }\n        if (connector.sourcePortID) {\n            newValue.sourcePortID = connector.sourcePortID;\n        }\n        if (connector.targetPortID) {\n            newValue.targetPortID = connector.targetPortID;\n        }\n        if (connector.segments) {\n            newValue.segments = connector.segments;\n        }\n        this.diagram.connectorPropertyChange(connector, oldChanges ? oldChanges : {}, newValue);\n        // this.diagram.refreshDiagramLayer();\n        this.diagram.updateSelector();\n    };\n    /**\n     * @param obj\n     * @param tx\n     * @param ty\n     * @param preventUpdate\n     * @param point\n     * @param endPoint\n     * @param update\n     * @param target\n     * @param targetPortId\n     * @param isDragSource\n     * @param segment\n     * @private\n     */\n    CommandHandler.prototype.dragSourceEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, target, targetPortId, isDragSource, segment) {\n        var connector = this.diagram.nameTable[obj.id];\n        var oldChanges = {};\n        var checkBoundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n        if (canDragSourceEnd(connector) && checkBoundaryConstraints\n            && (endPoint !== 'BezierSourceThumb') && canPageEditable(this.diagram)) {\n            oldChanges = { sourcePoint: connector.sourcePoint };\n            connector.sourcePoint.x += tx;\n            connector.sourcePoint.y += ty;\n            if (endPoint === 'ConnectorSourceEnd' && connector.type === 'Orthogonal') {\n                this.changeSegmentLength(connector, target, targetPortId, isDragSource);\n            }\n            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n                this.updatePathElementOffset(connector);\n            }\n        }\n        if (connector.type === 'Bezier') {\n            oldChanges = { sourcePoint: connector.sourcePoint };\n            if (segment) {\n                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, segment, point, !update);\n            }\n            else {\n                for (var i = 0; i < obj.segments.length; i++) {\n                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorSourceEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n                }\n            }\n        }\n        if (!preventUpdate) {\n            this.updateEndPoint(connector, oldChanges);\n        }\n        if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n            this.diagram.refreshCanvasLayers();\n        }\n        return checkBoundaryConstraints;\n    };\n    /**\n     * Update Path Element offset\n     */\n    CommandHandler.prototype.updatePathElementOffset = function (connector) {\n        connector.wrapper.children.splice(3, 1);\n        var pathElement = new PathElement();\n        var anglePoints = connector.intermediatePoints;\n        pathElement = updatePathElement(anglePoints, connector);\n        connector.wrapper.children.splice(3, 0, pathElement);\n    };\n    /**\n     * Upadte the connector segments when change the source node\n     */\n    CommandHandler.prototype.changeSegmentLength = function (connector, target, targetPortId, isDragSource) {\n        if (connector.segments && connector.segments[0].direction !== null\n            && ((!target && connector.sourceID === '') || isDragSource)) {\n            var first = connector.segments[0];\n            var second = connector.segments[1];\n            var node = this.diagram.nameTable[connector.sourceID];\n            var secPoint = void 0;\n            first.points[0] = connector.sourcePoint;\n            if (first.direction === 'Top' || first.direction === 'Bottom') {\n                first.points[first.points.length - 1].x = connector.sourcePoint.x;\n                second.points[0].y = first.points[first.points.length - 1].y;\n            }\n            else {\n                first.points[first.points.length - 1].y = connector.sourcePoint.y;\n                second.points[0].x = first.points[first.points.length - 1].x;\n            }\n            if (first.direction && (first.length || first.length === 0)) {\n                first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n            }\n            if (second.direction && (second.length || second.length === 0)) {\n                second.length = Point.distancePoints(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n                second.direction = Point.direction(first.points[first.points.length - 1], second.points[second.points.length - 1]);\n            }\n            if (connector.sourcePortID !== '' && first.length < 10) {\n                if (connector.segments.length > 2) {\n                    var next = connector.segments[2];\n                    var nextDirection = Point.direction(next.points[0], next.points[1]);\n                    if (first.direction === getOppositeDirection(nextDirection)) {\n                        if (first.direction === 'Right') {\n                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleRight.x + 20;\n                        }\n                        else if (first.direction === 'Left') {\n                            next.points[0].x = first.points[first.points.length - 1].x = node.wrapper.corners.middleLeft.x - 20;\n                        }\n                        else if (first.direction === 'Top') {\n                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.topCenter.y - 20;\n                        }\n                        else {\n                            next.points[0].y = first.points[first.points.length - 1].y = node.wrapper.corners.bottomCenter.y + 20;\n                        }\n                        if (next.direction && next.length) {\n                            next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                        }\n                        first.length = Point.distancePoints(first.points[0], first.points[first.points.length - 1]);\n                    }\n                    else if (first.direction === nextDirection && next.direction && next.length) {\n                        if (first.direction === 'Top' || first.direction === 'Bottom') {\n                            next.points[0] = first.points[0];\n                            next.points[next.points.length - 1].x = next.points[0].x;\n                        }\n                        else {\n                            next.points[0] = first.points[0];\n                            next.points[next.points.length - 1].y = next.points[0].y;\n                        }\n                        next.length = Point.distancePoints(next.points[0], next.points[next.points.length - 1]);\n                        connector.segments.splice(0, 2);\n                    }\n                    else {\n                        first.length = 20;\n                    }\n                }\n                else {\n                    first.length = 20;\n                }\n            }\n            else if (first.length < 1) {\n                if (connector.sourceID !== '') {\n                    if (second.direction === 'Right') {\n                        secPoint = node.wrapper.corners.middleRight;\n                        second.points[second.points.length - 1].y = secPoint.y;\n                    }\n                    else if (second.direction === 'Left') {\n                        secPoint = node.wrapper.corners.middleLeft;\n                        second.points[second.points.length - 1].y = secPoint.y;\n                    }\n                    else if (second.direction === 'Top') {\n                        secPoint = node.wrapper.corners.topCenter;\n                        second.points[second.points.length - 1].x = secPoint.x;\n                    }\n                    else {\n                        secPoint = node.wrapper.corners.bottomCenter;\n                        second.points[second.points.length - 1].x = secPoint.x;\n                    }\n                    second.length = Point.distancePoints(secPoint, second.points[second.points.length - 1]);\n                    if (connector.segments.length > 2) {\n                        var next = connector.segments[2];\n                        if (next.direction && next.length) {\n                            next.length = Point.distancePoints(second.points[second.points.length - 1], next.points[next.points.length - 1]);\n                        }\n                    }\n                    connector.segments.splice(0, 1);\n                }\n                else {\n                    connector.segments.splice(0, 1);\n                }\n            }\n        }\n        else {\n            if (target && !targetPortId && connector.sourceID !== target.id &&\n                connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n                this.changeSourceEndToNode(connector, target);\n            }\n            if (target && targetPortId && connector.sourcePortID !== targetPortId &&\n                connector.segments && connector.segments[0].direction !== null && target && target instanceof Node) {\n                this.changeSourceEndToPort(connector, target, targetPortId);\n            }\n        }\n    };\n    /**\n     * Change the connector endPoint to port\n     */\n    CommandHandler.prototype.changeSourceEndToPort = function (connector, target, targetPortId) {\n        var port = this.diagram.getWrapper(target.wrapper, targetPortId);\n        var point = { x: port.offsetX, y: port.offsetY };\n        var direction = getPortDirection(point, cornersPointsBeforeRotation(target.wrapper), target.wrapper.bounds, false);\n        var firstSegment = connector.segments[0];\n        var secondSegment = connector.segments[1];\n        if (firstSegment.direction !== direction) {\n            var segments = [];\n            var segValues = {};\n            if (firstSegment.direction === getOppositeDirection(direction)) {\n                segValues = {};\n                var segValues1 = void 0;\n                if (direction === 'Top' || direction === 'Bottom') {\n                    segValues1 = (direction === 'Top') ? {\n                        type: 'Orthogonal', isTerminal: true, direction: direction,\n                        length: Math.abs(firstSegment.points[0].y - point.y)\n                    } :\n                        {\n                            type: 'Orthogonal', isTerminal: true, direction: direction,\n                            length: Math.abs(point.y - firstSegment.points[0].y)\n                        };\n                    segValues = (firstSegment.points[0].x > point.x) ?\n                        { type: 'Orthogonal', isTerminal: true, direction: 'Right', length: (firstSegment.points[0].x - point.x) } :\n                        { type: 'Orthogonal', isTerminal: true, direction: 'Left', length: (point.x - firstSegment.points[0].x) };\n                }\n                else {\n                    segValues1 = (direction === 'Right') ? {\n                        type: 'Orthogonal', isTerminal: true, direction: direction,\n                        length: Math.abs(firstSegment.points[0].x - point.x)\n                    } :\n                        {\n                            type: 'Orthogonal', isTerminal: true, direction: direction,\n                            length: Math.abs(point.x - firstSegment.points[0].x)\n                        };\n                    segValues = (firstSegment.points[0].y > point.y) ?\n                        { type: 'Orthogonal', direction: 'Top', isTerminal: true, length: (firstSegment.points[0].y - point.y) } :\n                        { type: 'Orthogonal', direction: 'Bottom', isTerminal: true, length: (point.y - firstSegment.points[0].y) };\n                }\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues1, true));\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n            }\n            else {\n                segValues = { type: 'Orthogonal', direction: direction, length: 20, isTerminal: true };\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n            }\n            if (firstSegment.direction !== getOppositeDirection(direction)) {\n                if (direction === 'Top' || direction === 'Bottom') {\n                    firstSegment.points[0].x = point.x;\n                    firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = (direction === 'Top') ?\n                        point.y - 20 : point.y + 20;\n                }\n                else {\n                    firstSegment.points[0].y = point.y;\n                    firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = (direction === 'Right') ?\n                        point.x + 20 : point.x - 20;\n                }\n                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n            }\n            connector.segments = segments.concat(connector.segments);\n        }\n        else {\n            firstSegment.points[0] = point;\n            if (direction === 'Top' || direction === 'Bottom') {\n                firstSegment.points[firstSegment.points.length - 1].x = point.x;\n            }\n            else {\n                firstSegment.points[firstSegment.points.length - 1].y = point.y;\n            }\n            firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n            secondSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], secondSegment.points[secondSegment.points.length - 1]);\n        }\n    };\n    /**\n     * @param connector\n     * @param changeTerminal\n     * @private\nRemove terinal segment in initial\n     */\n    CommandHandler.prototype.removeTerminalSegment = function (connector, changeTerminal) {\n        for (var i = 0; i < connector.segments.length - 2; i++) {\n            var segment = connector.segments[0];\n            if (segment.isTerminal) {\n                if (changeTerminal) {\n                    segment.isTerminal = false;\n                }\n                else {\n                    connector.segments.splice(i, 1);\n                    i--;\n                }\n            }\n        }\n    };\n    /**\n     * Change the connector endPoint from point to node\n     */\n    CommandHandler.prototype.changeSourceEndToNode = function (connector, target) {\n        this.removeTerminalSegment(connector);\n        var sourceWrapper = target.wrapper.children[0].corners;\n        var sourcePoint;\n        var sourcePoint2;\n        var firstSegment = connector.segments[0];\n        var nextSegment = connector.segments[1];\n        var segments = [];\n        if (firstSegment.direction === 'Right' || firstSegment.direction === 'Left') {\n            sourcePoint = (firstSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n            if (firstSegment.length > sourceWrapper.width || ((firstSegment.direction === 'Left' &&\n                sourcePoint.x >= firstSegment.points[0].x) || (firstSegment.direction === 'Right' &&\n                sourcePoint.x <= firstSegment.points[0].x))) {\n                firstSegment.points[0].y = firstSegment.points[firstSegment.points.length - 1].y = sourcePoint.y;\n                firstSegment.points[0].x = sourcePoint.x;\n                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n            }\n            else {\n                var direction = void 0;\n                if (nextSegment.direction) {\n                    direction = nextSegment.direction;\n                }\n                else {\n                    direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n                }\n                sourcePoint2 = (direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n                if (nextSegment.length && nextSegment.direction) {\n                    nextSegment.length =\n                        (direction === 'Top') ? firstSegment.points[firstSegment.points.length - 1].y - (sourcePoint2.y + 20) :\n                            (sourcePoint2.y + 20) - firstSegment.points[firstSegment.points.length - 1].y;\n                }\n                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].x - sourcePoint2.x;\n                firstSegment.direction = (firstSegment.length > 0) ? 'Right' : 'Left';\n                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n                connector.segments = segments.concat(connector.segments);\n            }\n        }\n        else {\n            sourcePoint = (firstSegment.direction === 'Bottom') ? sourceWrapper.bottomCenter : sourceWrapper.topCenter;\n            if (firstSegment.length > sourceWrapper.height || ((firstSegment.direction === 'Top' &&\n                sourcePoint.y >= firstSegment.points[0].y) ||\n                (firstSegment.direction === 'Bottom' && sourcePoint.y <= firstSegment.points[0].y))) {\n                firstSegment.points[0].x = firstSegment.points[firstSegment.points.length - 1].x = sourcePoint.x;\n                firstSegment.points[0].y = sourcePoint.y;\n                firstSegment.length = Point.distancePoints(firstSegment.points[0], firstSegment.points[firstSegment.points.length - 1]);\n                nextSegment.length = Point.distancePoints(firstSegment.points[firstSegment.points.length - 1], nextSegment.points[nextSegment.points.length - 1]);\n            }\n            else {\n                sourcePoint2 = (nextSegment.direction === 'Left') ? sourceWrapper.middleLeft : sourceWrapper.middleRight;\n                var direction = void 0;\n                if (nextSegment.direction) {\n                    direction = nextSegment.direction;\n                }\n                else {\n                    direction = Point.direction(nextSegment.points[0], nextSegment.points[nextSegment.points.length - 1]);\n                }\n                if (nextSegment.length && nextSegment.direction) {\n                    nextSegment.length =\n                        (direction === 'Left') ? firstSegment.points[firstSegment.points.length - 1].x - (sourcePoint2.x + 20) :\n                            (sourcePoint2.x + 20) - firstSegment.points[firstSegment.points.length - 1].x;\n                }\n                firstSegment.length = firstSegment.points[firstSegment.points.length - 1].y - sourcePoint2.y;\n                firstSegment.direction = (firstSegment.length > 0) ? 'Bottom' : 'Top';\n                var segValues = { type: 'Orthogonal', direction: direction, length: 20 };\n                segments.push(new OrthogonalSegment(connector, 'segments', segValues, true));\n                connector.segments = segments.concat(connector.segments);\n            }\n        }\n    };\n    //Translate the bezier points during the interaction\n    CommandHandler.prototype.translateBezierPoints = function (connector, value, tx, ty, seg, point, update) {\n        var index = (connector.segments.indexOf(seg));\n        var segment = connector.segments[index];\n        if (segment) {\n            if (value === 'BezierSourceThumb' && (segment.vector1.angle || segment.vector1.distance)) {\n                segment.vector1 = {\n                    distance: connector.distance(connector.sourcePoint, point),\n                    angle: Point.findAngle(connector.sourcePoint, point)\n                };\n            }\n            else if (value === 'BezierTargetThumb' && (segment.vector2.angle || segment.vector2.distance)) {\n                segment.vector2 = {\n                    distance: connector.distance(connector.targetPoint, point),\n                    angle: Point.findAngle(connector.targetPoint, point)\n                };\n            }\n            else if ((value === 'ConnectorSourceEnd' && !connector.sourceID || value === 'ConnectorTargetEnd' && !connector.targetID)\n                && update && isEmptyVector(segment.vector1) && isEmptyVector(segment.vector2)) {\n                if (Point.isEmptyPoint(segment.point1)) {\n                    segment.bezierPoint1 = getBezierPoints(connector.sourcePoint, connector.targetPoint);\n                }\n                if (Point.isEmptyPoint(segment.point2)) {\n                    segment.bezierPoint2 = getBezierPoints(connector.targetPoint, connector.sourcePoint);\n                }\n            }\n            else if (value === 'BezierSourceThumb' || (value === 'ConnectorSourceEnd' && !update && isEmptyVector(segment.vector1))) {\n                segment.bezierPoint1.x += tx;\n                segment.bezierPoint1.y += ty;\n                if ((!Point.isEmptyPoint(segment.point1)) || (update)) {\n                    segment.point1 = { x: segment.bezierPoint1.x, y: segment.bezierPoint1.y };\n                }\n            }\n            else if (value === 'BezierTargetThumb' || (value === 'ConnectorTargetEnd' && !update && isEmptyVector(segment.vector2))) {\n                segment.bezierPoint2.x += tx;\n                segment.bezierPoint2.y += ty;\n                if ((!Point.isEmptyPoint(segment.point2)) || (update)) {\n                    segment.point2 = { x: segment.bezierPoint2.x, y: segment.bezierPoint2.y };\n                }\n            }\n        }\n    };\n    /**\n     * dragTargetEnd method \\\n     *\n     * @returns { void }     dragTargetEnd method .\\\n     * @param {ConnectorModel} obj - provide the obj value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the ty value.\n     * @param {boolean} preventUpdate - provide the preventUpdate value.\n     * @param {PointModel} point - provide the point value.\n     * @param {string} endPoint - provide the endPoint value.\n     * @param {boolean} update - provide the update value.\n     * @param {OrthogonalSegmentModel | BezierSegmentModel | StraightSegmentModel} segment - provide the segment value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dragTargetEnd = function (obj, tx, ty, preventUpdate, point, endPoint, update, segment) {\n        var connector = this.diagram.nameTable[obj.id];\n        var oldChanges;\n        var boundaryConstraints = this.checkBoundaryConstraints(tx, ty, connector.wrapper.bounds);\n        if (canDragTargetEnd(connector) && endPoint !== 'BezierTargetThumb'\n            && boundaryConstraints && canPageEditable(this.diagram)) {\n            oldChanges = { targetPoint: connector.targetPoint };\n            connector.targetPoint.x += tx;\n            connector.targetPoint.y += ty;\n            if (endPoint === 'ConnectorTargetEnd' && connector.type === 'Orthogonal' &&\n                connector.segments && connector.segments.length > 0) {\n                var prev = connector.segments[connector.segments.length - 2];\n                if (prev && connector.segments[connector.segments.length - 1].points.length === 2) {\n                    if (prev.direction === 'Left' || prev.direction === 'Right') {\n                        prev.points[prev.points.length - 1].x = connector.targetPoint.x;\n                    }\n                    else {\n                        prev.points[prev.points.length - 1].y = connector.targetPoint.y;\n                    }\n                    prev.length = Point.distancePoints(prev.points[0], prev.points[prev.points.length - 1]);\n                    prev.direction = Point.direction(prev.points[0], prev.points[prev.points.length - 1]);\n                }\n            }\n            if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n                this.updatePathElementOffset(connector);\n            }\n        }\n        if (connector.type === 'Bezier') {\n            oldChanges = { targetPoint: connector.targetPoint };\n            if (segment) {\n                this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, segment, point, !update);\n            }\n            else {\n                for (var i = 0; i < obj.segments.length; i++) {\n                    this.translateBezierPoints(obj, (endPoint === '') ? 'ConnectorTargetEnd' : endPoint, tx, ty, obj.segments[i], point, !update);\n                }\n            }\n        }\n        if (!preventUpdate) {\n            this.updateEndPoint(connector, oldChanges);\n        }\n        if (!(this.diagram.realActions & RealAction.AnimationClick)) {\n            this.diagram.refreshCanvasLayers();\n        }\n        return boundaryConstraints;\n    };\n    /**\n     * dragControlPoint method \\\n     *\n     * @returns { void }     dragControlPoint method .\\\n     * @param {ConnectorModel} obj - provide the obj value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the ty value.\n     * @param {boolean} preventUpdate - provide the preventUpdate value.\n     * @param {number} segmentNumber - provide the segmentNumber value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dragControlPoint = function (obj, tx, ty, preventUpdate, segmentNumber) {\n        var connector = this.diagram.nameTable[obj.id];\n        if ((connector.type === 'Straight' || connector.type === 'Bezier') && connector.segments.length > 0) {\n            if (segmentNumber !== undefined && connector.segments[segmentNumber]) {\n                connector.segments[segmentNumber].point.x += tx;\n                connector.segments[segmentNumber].point.y += ty;\n            }\n            else {\n                for (var i = 0; i < connector.segments.length - 1; i++) {\n                    connector.segments[i].point.x += tx;\n                    connector.segments[i].point.y += ty;\n                }\n            }\n            if (!preventUpdate) {\n                this.updateEndPoint(connector);\n            }\n        }\n        return true;\n    };\n    /**\n     * rotatePropertyChnage method \\\n     *\n     * @returns { void }     rotatePropertyChnage method .\\\n     * @param {number} angle - provide the obj value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotatePropertyChnage = function (angle) {\n        var selectedItems = this.diagram.selectedItems;\n        var objects = [];\n        objects = objects.concat(selectedItems.nodes);\n        objects = objects.concat(selectedItems.connectors);\n        var pivotValue = { x: selectedItems.offsetX, y: selectedItems.offsetY };\n        this.rotateObjects(selectedItems, objects, angle - selectedItems.rotateAngle, pivotValue);\n        selectedItems.wrapper.rotateAngle = selectedItems.rotateAngle = angle;\n        this.diagram.updateSelector();\n    };\n    /**\n     * rotateObjects method \\\n     *\n     * @returns { void }     rotateObjects method .\\\n     * @param {NodeModel | SelectorModel} parent - provide the parent value.\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the objects value.\n     * @param {number} angle - provide the angle value.\n     * @param {PointModel} pivot - provide the pivot value.\n     * @param {boolean} includeParent - provide the includeParent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotateObjects = function (parent, objects, angle, pivot, includeParent) {\n        pivot = pivot || {};\n        var matrix = identityMatrix();\n        rotateMatrix(matrix, angle, pivot.x, pivot.y);\n        var oldValues;\n        for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {\n            var obj = objects_2[_i];\n            if (obj instanceof Node) {\n                if (canRotate(obj) && canPageEditable(this.diagram)) {\n                    if (includeParent !== false || parent !== obj) {\n                        oldValues = { rotateAngle: obj.rotateAngle };\n                        obj.rotateAngle += angle;\n                        obj.rotateAngle = (obj.rotateAngle + 360) % 360;\n                        var newOffset = transformPointByMatrix(matrix, { x: obj.offsetX, y: obj.offsetY });\n                        obj.offsetX = newOffset.x;\n                        obj.offsetY = newOffset.y;\n                        this.diagram.nodePropertyChange(obj, {}, { offsetX: obj.offsetX, offsetY: obj.offsetY, rotateAngle: obj.rotateAngle });\n                    }\n                    if (obj.processId) {\n                        var parent_1 = this.diagram.nameTable[obj.processId];\n                        var bound = this.diagram.bpmnModule.getChildrenBound(parent_1, obj.id, this.diagram);\n                        this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n                    }\n                    if (obj.children && obj.children.length && !obj.container) {\n                        this.getChildren(obj, objects);\n                    }\n                }\n            }\n            else {\n                this.rotatePoints(obj, angle, pivot || { x: obj.wrapper.offsetX, y: obj.wrapper.offsetY });\n            }\n            this.diagram.updateDiagramObject(obj);\n        }\n        this.diagram.refreshCanvasLayers();\n        this.diagram.updateSelector();\n    };\n    /**\n     * snapConnectorEnd method \\\n     *\n     * @returns { PointModel }     snapConnectorEnd method .\\\n     * @param {PointModel} currentPosition - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.snapConnectorEnd = function (currentPosition) {\n        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines)\n            && this.snappingModule) {\n            this.diagram.snappingModule.snapConnectorEnd(currentPosition);\n        }\n        return currentPosition;\n    };\n    /**\n     * snapAngle method \\\n     *\n     * @returns { number }     snapAngle method .\\\n     * @param {number} angle - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.snapAngle = function (angle) {\n        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToLines)\n            && this.snappingModule) {\n            return this.snappingModule.snapAngle(this.diagram, angle);\n        }\n        else {\n            return 0;\n        }\n    };\n    /**\n     * rotatePoints method \\\n     *\n     * @returns { number }     rotatePoints method .\\\n     * @param {Connector} conn - provide the parent value.\n     * @param {number} angle - provide the parent value.\n     * @param {PointModel} pivot - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.rotatePoints = function (conn, angle, pivot) {\n        if (!conn.sourceWrapper || !conn.targetWrapper) {\n            var matrix = identityMatrix();\n            rotateMatrix(matrix, angle, pivot.x, pivot.y);\n            conn.sourcePoint = transformPointByMatrix(matrix, conn.sourcePoint);\n            conn.targetPoint = transformPointByMatrix(matrix, conn.targetPoint);\n            if (conn.shape.type === 'Bpmn' && conn.shape.sequence === 'Default') {\n                this.updatePathElementOffset(conn);\n            }\n            var newProp = { sourcePoint: conn.sourcePoint, targetPoint: conn.targetPoint };\n            this.diagram.connectorPropertyChange(conn, {}, newProp);\n        }\n    };\n    CommandHandler.prototype.updateInnerParentProperties = function (tempNode) {\n        var elements = [];\n        var protect = 'isProtectedOnChange';\n        var protectChange = this.diagram[protect];\n        this.diagram.protectPropertyChange(true);\n        var innerParents = this.getAllDescendants(tempNode, elements, false, true);\n        for (var i = 0; i < innerParents.length; i++) {\n            var obj = this.diagram.nameTable[innerParents[i].id];\n            obj.offsetX = obj.wrapper.offsetX;\n            obj.offsetY = obj.wrapper.offsetY;\n            obj.width = obj.wrapper.width;\n            obj.height = obj.wrapper.height;\n        }\n        this.diagram.protectPropertyChange(protectChange);\n    };\n    /**\n     * scale method \\\n     *\n     * @returns { boolean }     scale method .\\\n     * @param {NodeModel | ConnectorModel} obj - provide the parent value.\n     * @param {number} sw - provide the parent value.\n     * @param {number} sh - provide the parent value.\n     * @param {number} pivot - provide the parent value.\n     * @param {number} refObject - provide the parent value.\n     * @param {boolean} isOutsideBoundary - provide the parent value.\n     *\n     * @private\n     */\n    // eslint-disable-next-line max-len\n    CommandHandler.prototype.scale = function (obj, sw, sh, pivot, refObject, isOutsideBoundary) {\n        var node = this.diagram.nameTable[obj.id];\n        var tempNode = node;\n        var elements = [];\n        var element = node.wrapper;\n        if (!refObject) {\n            refObject = obj;\n        }\n        var refWrapper = refObject.wrapper;\n        var x = refWrapper.offsetX - refWrapper.actualSize.width * refWrapper.pivot.x;\n        var y = refWrapper.offsetY - refWrapper.actualSize.height * refWrapper.pivot.y;\n        var refPoint = getPoint(x, y, refWrapper.actualSize.width, refWrapper.actualSize.height, refWrapper.rotateAngle, refWrapper.offsetX, refWrapper.offsetY, pivot);\n        if (element.actualSize.width !== undefined && element.actualSize.height !== undefined && canPageEditable(this.diagram)) {\n            if (tempNode.children && !(tempNode.container)) {\n                var nodes = this.getAllDescendants(tempNode, elements);\n                for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n                    var temp = nodes_1[_i];\n                    this.scaleObject(sw, sh, refPoint, temp, element, refObject);\n                }\n                obj.wrapper.measure(new Size());\n                obj.wrapper.arrange(obj.wrapper.desiredSize);\n                this.diagram.updateGroupOffset(node);\n                this.updateInnerParentProperties(tempNode);\n            }\n            else {\n                this.scaleObject(sw, sh, refPoint, node, element, refObject);\n            }\n            var bounds = getBounds(obj.wrapper);\n            var checkBoundaryConstraints = this.checkBoundaryConstraints(undefined, undefined, bounds);\n            if (!checkBoundaryConstraints && isOutsideBoundary) {\n                this.scale(obj, 1 / sw, 1 / sh, pivot, undefined, true);\n                return false;\n            }\n            this.diagram.updateDiagramObject(obj);\n        }\n        return true;\n    };\n    /** @private */\n    CommandHandler.prototype.getAllDescendants = function (node, nodes, includeParent, innerParent) {\n        var temp = node;\n        var parentNodes = [];\n        for (var i = 0; i < temp.children.length; i++) {\n            node = (this.diagram.nameTable[temp.children[i]]);\n            if (node) {\n                if (!node.children) {\n                    nodes.push(node);\n                }\n                else {\n                    if (includeParent) {\n                        nodes.push(node);\n                    }\n                    if (innerParent) {\n                        parentNodes.push(node);\n                    }\n                    nodes = this.getAllDescendants(node, nodes);\n                }\n            }\n        }\n        return (innerParent) ? parentNodes : nodes;\n    };\n    /**\n     * getChildren method \\\n     *\n     * @returns { (NodeModel | ConnectorModel)[]): (NodeModel | ConnectorModel)[] }     getChildren method .\\\n     * @param {NodeModel} node - provide the sw value.\n     * @param {(NodeModel | ConnectorModel)[]} nodes - provide the sw value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.getChildren = function (node, nodes) {\n        var temp = node;\n        if (node.children) {\n            for (var i = 0; i < temp.children.length; i++) {\n                node = (this.diagram.nameTable[temp.children[i]]);\n                nodes.push(node);\n            }\n        }\n        return nodes;\n    };\n    /**\n     * scaleObject method \\\n     *\n     * @returns { NodeModel }     scaleObject method .\\\n     * @param {string} id - provide the sw value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.cloneChild = function (id) {\n        var node = this.diagram.nameTable[id];\n        return node;\n    };\n    /**\n     * scaleObject method \\\n     *\n     * @returns { void }     scaleObject method .\\\n     * @param {End} sw - provide the sw value.\n     * @param {End} sh - provide the sh value.\n     * @param {PointModel} pivot - provide the pivot value.\n     * @param {IElement} obj - provide the pivot value.\n     * @param {DiagramElement} element - provide the element value.\n     * @param {IElement} refObject - provide the refObject value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.scaleObject = function (sw, sh, pivot, obj, element, refObject) {\n        sw = sw < 0 ? 1 : sw;\n        sh = sh < 0 ? 1 : sh;\n        var oldValues = {};\n        if (sw !== 1 || sh !== 1) {\n            var width = void 0;\n            var height = void 0;\n            if (obj instanceof Node) {\n                var node = obj;\n                var isResize = void 0;\n                var bound = void 0;\n                oldValues = {\n                    width: obj.wrapper.actualSize.width, height: obj.wrapper.actualSize.height,\n                    offsetX: obj.wrapper.offsetX, offsetY: obj.wrapper.offsetY,\n                    margin: { top: node.margin.top, left: node.margin.left }\n                };\n                if (node.shape.type === 'Bpmn' && node.shape.activity.subProcess.processes\n                    && node.shape.activity.subProcess.processes.length > 0) {\n                    bound = this.diagram.bpmnModule.getChildrenBound(node, node.id, this.diagram);\n                    isResize = node.wrapper.bounds.containsRect(bound);\n                }\n                width = node.wrapper.actualSize.width * sw;\n                height = node.wrapper.actualSize.height * sh;\n                if (node.maxWidth !== undefined && node.maxWidth !== 0) {\n                    width = Math.min(node.maxWidth, width);\n                }\n                if (node.minWidth !== undefined && node.minWidth !== 0) {\n                    width = Math.max(node.minWidth, width);\n                }\n                if (node.maxHeight !== undefined && node.maxHeight !== 0) {\n                    height = Math.min(node.maxHeight, height);\n                }\n                if (node.minHeight !== undefined && node.minHeight !== 0) {\n                    height = Math.max(node.minHeight, height);\n                }\n                if (isResize) {\n                    width = Math.max(width, (bound.right - node.wrapper.bounds.x));\n                    height = Math.max(height, (bound.bottom - node.wrapper.bounds.y));\n                }\n                sw = width / node.actualSize.width;\n                sh = height / node.actualSize.height;\n            }\n            var matrix = identityMatrix(); // let refWrapper: DiagramElement;\n            if (!refObject) {\n                refObject = obj;\n            }\n            var refWrapper = refObject.wrapper;\n            rotateMatrix(matrix, -refWrapper.rotateAngle, pivot.x, pivot.y);\n            scaleMatrix(matrix, sw, sh, pivot.x, pivot.y);\n            rotateMatrix(matrix, refWrapper.rotateAngle, pivot.x, pivot.y);\n            if (obj instanceof Node) {\n                var node = obj; //let left: number; let top: number;\n                var newPosition = transformPointByMatrix(matrix, { x: node.wrapper.offsetX, y: node.wrapper.offsetY });\n                var oldleft = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n                var oldtop = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n                if (width > 0) {\n                    if (node.processId) {\n                        var parent_2 = this.diagram.nameTable[node.processId];\n                        if (!parent_2.maxWidth || ((node.margin.left + width) < parent_2.maxWidth)) {\n                            node.width = width;\n                            node.offsetX = newPosition.x;\n                        }\n                    }\n                    else {\n                        node.width = width;\n                        node.offsetX = newPosition.x;\n                    }\n                }\n                if (height > 0) {\n                    if (node.processId) {\n                        var parent_3 = this.diagram.nameTable[node.processId];\n                        if (!parent_3.maxHeight || ((node.margin.top + height) < parent_3.maxHeight)) {\n                            node.height = height;\n                            node.offsetY = newPosition.y;\n                        }\n                    }\n                    else {\n                        node.height = height;\n                        node.offsetY = newPosition.y;\n                    }\n                }\n                var left = node.wrapper.offsetX - node.wrapper.actualSize.width * node.pivot.x;\n                var top_1 = node.wrapper.offsetY - node.wrapper.actualSize.height * node.pivot.y;\n                var parent_4 = this.diagram.nameTable[node.processId];\n                if (parent_4 && ((node.margin.top + (top_1 - oldtop)) <= 0 ||\n                    (node.margin.left + (left - oldleft) <= 0))) {\n                    this.diagram.nodePropertyChange(obj, {}, {\n                        margin: { top: node.margin.top, left: node.margin.left }\n                    });\n                }\n                else {\n                    if (checkParentAsContainer(this.diagram, obj, true)) {\n                        checkChildNodeInContainer(this.diagram, obj);\n                    }\n                    else {\n                        this.diagram.nodePropertyChange(obj, oldValues, {\n                            width: node.width, height: node.height, offsetX: node.offsetX, offsetY: node.offsetY,\n                            margin: { top: node.margin.top + (top_1 - oldtop), left: node.margin.left + (left - oldleft) }\n                        });\n                    }\n                }\n            }\n            else {\n                var connector = obj;\n                var oldValues_1 = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n                if (!connector.sourceWrapper || !connector.targetWrapper) {\n                    this.scaleConnector(connector, matrix, oldValues_1);\n                }\n            }\n            var parentNode = this.diagram.nameTable[obj.processId];\n            if (parentNode) {\n                var parent_5 = parentNode.wrapper.bounds;\n                var child = obj.wrapper.bounds;\n                var bound = this.diagram.bpmnModule.getChildrenBound(parentNode, obj.id, this.diagram);\n                this.diagram.bpmnModule.updateSubProcessess(bound, obj, this.diagram);\n            }\n        }\n    };\n    CommandHandler.prototype.scaleConnector = function (connector, matrix, oldValues) {\n        connector.sourcePoint = transformPointByMatrix(matrix, connector.sourcePoint);\n        connector.targetPoint = transformPointByMatrix(matrix, connector.targetPoint);\n        if (connector.shape.type === 'Bpmn' && connector.shape.sequence === 'Default') {\n            this.updatePathElementOffset(connector);\n        }\n        var newProp = { sourcePoint: connector.sourcePoint, targetPoint: connector.targetPoint };\n        this.diagram.connectorPropertyChange(connector, oldValues, newProp);\n    };\n    /**\n     * portDrag method \\\n     *\n     * @returns { void }     portDrag method .\\\n     * @param { NodeModel | ConnectorModel} obj - provide the obj value.\n     * @param {DiagramElement} portElement - provide the portElement value.\n     * @param {number} tx - provide the tx value.\n     * @param {number} ty - provide the tx value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.portDrag = function (obj, portElement, tx, ty) {\n        var oldValues;\n        var changedvalues;\n        var port = this.findTarget(portElement, obj);\n        var bounds = getBounds(obj.wrapper);\n        if (port && canDrag(port, this.diagram)) {\n            oldValues = this.getPortChanges(obj, port);\n            port.offset.x += (tx / bounds.width);\n            port.offset.y += (ty / bounds.height);\n            changedvalues = this.getPortChanges(obj, port);\n            this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n            this.diagram.updateDiagramObject(obj);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.labelDrag = function (obj, textElement, tx, ty) {\n        //let changedvalues: Object;\n        //let label: ShapeAnnotationModel | PathAnnotationModel;\n        // eslint-disable-next-line max-len\n        var label = this.findTarget(textElement, obj);\n        var bounds = cornersPointsBeforeRotation(obj.wrapper);\n        var oldValues = this.getAnnotationChanges(obj, label);\n        if (label instanceof ShapeAnnotation) {\n            label.offset.x += (tx / bounds.width);\n            label.offset.y += (ty / bounds.height);\n        }\n        else {\n            this.updatePathAnnotationOffset(obj, label, tx, ty);\n            if (label instanceof PathAnnotation) {\n                label.alignment = 'Center';\n            }\n        }\n        var changedvalues = this.getAnnotationChanges(obj, label);\n        if (obj instanceof Node) {\n            this.diagram.nodePropertyChange(obj, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(obj, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(obj);\n        if (!isSelected(this.diagram, label, false, textElement)) {\n            this.labelSelect(obj, textElement);\n        }\n    };\n    CommandHandler.prototype.updatePathAnnotationOffset = function (object, label, tx, ty, newPosition, size) {\n        var textWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n        var offsetX = textWrapper.offsetX;\n        var offsetY = textWrapper.offsetY;\n        var offset;\n        var intermediatePoints = object.intermediatePoints;\n        var prev;\n        var pointLength = 0;\n        var totalLength = 0;\n        var intersectingOffset;\n        var currentPosition = (newPosition) ? newPosition : { x: offsetX + tx, y: offsetY + ty };\n        var intersetingPts = this.getInterceptWithSegment(currentPosition, intermediatePoints);\n        var newOffset = intermediatePoints[intermediatePoints.length - 1];\n        totalLength = Point.getLengthFromListOfPoints(intermediatePoints);\n        if (intersetingPts.length > 0) {\n            if (label.dragLimit.top || label.dragLimit.bottom || label.dragLimit.left || label.dragLimit.right) {\n                var minDistance = { minDistance: null };\n                newOffset = this.getRelativeOffset(currentPosition, intermediatePoints, minDistance);\n                var distance = { minDistance: null };\n                intersectingOffset = this.getRelativeOffset(currentPosition, intersetingPts, distance);\n                if (minDistance != null && distance.minDistance < minDistance.minDistance) {\n                    newOffset = intersectingOffset;\n                }\n                else {\n                    var connectorOffset = getOffsetOfConnector(object.intermediatePoints, label);\n                    newOffset = connectorOffset.point;\n                }\n            }\n            else {\n                intersectingOffset = intersetingPts[intersetingPts.length - 1];\n                newOffset = intersectingOffset;\n            }\n            if (newOffset) {\n                var p = void 0;\n                var bounds = void 0;\n                for (p = 0; p < intermediatePoints.length; p++) {\n                    if (prev != null) {\n                        bounds = Rect.toBounds([prev, intermediatePoints[p]]);\n                        if (bounds.containsPoint(newOffset)) {\n                            pointLength += Point.findLength(prev, newOffset);\n                            break;\n                        }\n                        else {\n                            pointLength += Point.findLength(prev, intermediatePoints[p]);\n                        }\n                    }\n                    prev = intermediatePoints[p];\n                }\n                offset = { x: pointLength / totalLength, y: 0 };\n            }\n            this.updateLabelMargin(object, label, offset, currentPosition, size, tx, ty);\n        }\n        else {\n            this.updateLabelMargin(object, label, null, currentPosition, size, tx, ty);\n        }\n    };\n    CommandHandler.prototype.getRelativeOffset = function (currentPosition, points, minDistance) {\n        var newOffset;\n        var distance;\n        var pt;\n        var i;\n        for (i = 0; i < points.length; i++) {\n            pt = points[i];\n            distance = Math.round(Math.sqrt(Math.pow((currentPosition.x - pt.x), 2) +\n                Math.pow((currentPosition.y - pt.y), 2)));\n            if (minDistance.minDistance === null ||\n                Math.min(Math.abs(minDistance.minDistance), Math.abs(distance)) === Math.abs(distance)) {\n                newOffset = pt;\n                minDistance.minDistance = distance;\n            }\n        }\n        return newOffset;\n    };\n    CommandHandler.prototype.dragLimitValue = function (label, point, tempPt, contentDimension) {\n        var x = false;\n        var y = false;\n        if ((tempPt.x >= (point.x - label.dragLimit.left - (contentDimension.width / 2))) &&\n            (tempPt.x <= point.x + label.dragLimit.right + (contentDimension.width / 2))) {\n            x = true;\n        }\n        if ((tempPt.y >= (point.y - label.dragLimit.top - (contentDimension.height / 2))) &&\n            (tempPt.y <= point.y + label.dragLimit.bottom + (contentDimension.height / 2))) {\n            y = true;\n        }\n        return { x: x, y: y };\n    };\n    /* eslint-disable */\n    CommandHandler.prototype.updateLabelMargin = function (node, label, offset, tempPt, size, tx, ty) {\n        offset = offset ? offset : { x: label.offset, y: 0 };\n        if (label && offset && offset.x > 0 && offset.x < 1) {\n            //let point: PointModel;\n            var length_1 = Point.getLengthFromListOfPoints(node.intermediatePoints);\n            var point = this.getPointAtLength(length_1 * offset.x, node.intermediatePoints, 0);\n            var curZoomfactor = this.diagram.scrollSettings.currentZoom;\n            var dragLimit = label.dragLimit;\n            if (dragLimit.top || dragLimit.bottom || dragLimit.left || dragLimit.right) {\n                var labelBounds = this.diagram.getWrapper(node.wrapper, label.id);\n                var contentDimension = new Rect(0, 0, 0, 0);\n                var annotationWrtapper = this.diagram.getWrapper(node.wrapper, label.id);\n                contentDimension.x = ((annotationWrtapper).offsetX / curZoomfactor) + tx;\n                contentDimension.y = (annotationWrtapper.offsetY / curZoomfactor) + ty;\n                contentDimension.width = annotationWrtapper.bounds.width / curZoomfactor;\n                contentDimension.height = annotationWrtapper.bounds.height / curZoomfactor;\n                var draggableBounds = new Rect(point.x - (dragLimit.left || 0) - contentDimension.width / 2, point.y - (dragLimit.top || 0) - contentDimension.height / 2, (dragLimit.left || 0) + (dragLimit.right || 0) + contentDimension.width, (dragLimit.top || 0) + (dragLimit.bottom || 0) + contentDimension.height);\n                if (draggableBounds.containsPoint(tempPt)) {\n                    tempPt = tempPt;\n                }\n                else {\n                    var lineIntersects = void 0;\n                    var line1 = [point, tempPt];\n                    lineIntersects = this.boundsInterSects(line1, draggableBounds, false);\n                    for (var _i = 0, lineIntersects_1 = lineIntersects; _i < lineIntersects_1.length; _i++) {\n                        var i = lineIntersects_1[_i];\n                        var ptt = i;\n                        tempPt = ptt;\n                    }\n                }\n                var cursorLimit = this.dragLimitValue(label, point, tempPt, contentDimension);\n                label.margin = {\n                    left: cursorLimit.x ? tempPt.x - point.x : label.margin.left,\n                    top: cursorLimit.y ? tempPt.y - point.y : label.margin.top, right: 0, bottom: 0\n                };\n            }\n            else {\n                label.margin = { left: tempPt.x - point.x, top: tempPt.y - point.y, right: 0, bottom: 0 };\n            }\n            label.offset = offset.x;\n            if (size) {\n                label.width = size.width;\n                label.height = size.height;\n            }\n        }\n    };\n    CommandHandler.prototype.boundsInterSects = function (polyLine, bounds, self) {\n        var intersects;\n        if (bounds) {\n            var polyLine2 = [\n                { x: bounds.x, y: bounds.y },\n                { x: bounds.x + bounds.width, y: bounds.y },\n                { x: bounds.x + bounds.width, y: bounds.y + bounds.height },\n                { x: bounds.x, y: bounds.y + bounds.height },\n                { x: bounds.x, y: bounds.y }\n            ];\n            intersects = this.intersect(polyLine, polyLine2, self);\n        }\n        return intersects;\n    };\n    CommandHandler.prototype.intersect = function (polyLine1, polyLine2, self) {\n        var intersect = [];\n        for (var i = 0; i < polyLine1.length - 1; i++) {\n            for (var j = 0; j < polyLine2.length - 1; j++) {\n                var p = intersect2(polyLine1[i], polyLine1[i + 1], polyLine2[j], polyLine2[j + 1]);\n                if (p.x !== 0 && p.y !== 0) {\n                    intersect.push(p);\n                }\n            }\n        }\n        return intersect;\n    };\n    CommandHandler.prototype.getPointAtLength = function (length, points, angle) {\n        angle = 0;\n        var run = 0;\n        var pre;\n        var found = { x: 0, y: 0 };\n        var pt;\n        for (var i = 0; i < points.length; i++) {\n            pt = points[i];\n            if (!pre) {\n                pre = pt;\n                continue;\n            }\n            else {\n                var l = Point.findLength(pre, pt);\n                var r = void 0;\n                var deg = void 0;\n                var x = void 0;\n                var y = void 0;\n                if (run + l >= length) {\n                    r = length - run;\n                    deg = Point.findAngle(pre, pt);\n                    x = r * Math.cos(deg * Math.PI / 180);\n                    y = r * Math.sin(deg * Math.PI / 180);\n                    found = { x: pre.x + x, y: pre.y + y };\n                    angle = deg;\n                    break;\n                }\n                else {\n                    run += l;\n                }\n            }\n            pre = pt;\n        }\n        return found;\n    };\n    CommandHandler.prototype.getInterceptWithSegment = function (currentPosition, conPoints) {\n        var intercepts = [];\n        var imgLine = [];\n        var segemnt = [];\n        var tarAngle;\n        var srcAngle; //let maxLength: number;\n        var maxLength = Point.findLength({ x: 0, y: 0 }, { x: this.diagram.scroller.viewPortWidth, y: this.diagram.scroller.viewPortHeight });\n        for (var i = 1; i < conPoints.length; i++) {\n            segemnt = [conPoints[i - 1], conPoints[i]];\n            imgLine = [];\n            srcAngle = Math.round(Point.findAngle(segemnt[0], segemnt[1]) % 360);\n            tarAngle = Math.round(Point.findAngle(segemnt[1], segemnt[0]) % 360);\n            var angleAdd = (srcAngle > 0 && srcAngle <= 90) || (srcAngle > 180 && srcAngle <= 270) ? 90 : -90;\n            imgLine.push(Point.transform(currentPosition, srcAngle + angleAdd, maxLength));\n            imgLine.push(Point.transform(currentPosition, tarAngle + angleAdd, maxLength));\n            var lineUtil1 = { x1: segemnt[0].x, y1: segemnt[0].y, x2: segemnt[1].x, y2: segemnt[1].y };\n            var lineUtil2 = { x1: imgLine[0].x, y1: imgLine[0].y, x2: imgLine[1].x, y2: imgLine[1].y };\n            var line3 = intersect3(lineUtil1, lineUtil2);\n            if (line3.enabled) {\n                intercepts.push(line3.intersectPt);\n            }\n        }\n        return intercepts;\n    };\n    /** @private */\n    CommandHandler.prototype.getAnnotationChanges = function (object, label) {\n        var index = findObjectIndex(object, label.id, true);\n        var annotations = {};\n        annotations[index] = {\n            width: label.width, height: label.height, offset: (object instanceof Node) ? ({\n                x: label.offset.x,\n                y: label.offset.y\n            }) : label.offset,\n            rotateAngle: label.rotateAngle,\n            margin: { left: label.margin.left, right: label.margin.right, top: label.margin.top, bottom: label.margin.bottom },\n            horizontalAlignment: label.horizontalAlignment, verticalAlignment: label.verticalAlignment,\n            alignment: ((object instanceof Connector) ? label.alignment : undefined)\n        };\n        return { annotations: annotations };\n    };\n    /** @private */\n    CommandHandler.prototype.getPortChanges = function (object, port) {\n        var index = findObjectIndex(object, port.id, false);\n        var ports = {};\n        ports[index] = { offset: port.offset };\n        return { ports: ports };\n    };\n    /** @private */\n    CommandHandler.prototype.labelRotate = function (object, label, currentPosition, selector) {\n        var oldValues;\n        var changedvalues;\n        oldValues = this.getAnnotationChanges(object, label);\n        var matrix = identityMatrix();\n        var rotateAngle = label.rotateAngle;\n        var labelWrapper = this.diagram.getWrapper(object.wrapper, label.id);\n        var angle = findAngle({ x: labelWrapper.offsetX, y: labelWrapper.offsetY }, currentPosition) + 90;\n        var snapAngle = this.snapAngle(angle);\n        angle = snapAngle !== 0 ? snapAngle : angle;\n        if (label instanceof PathAnnotation && label.segmentAngle) {\n            var getPointloop = getAnnotationPosition(object.intermediatePoints, label, object.wrapper.bounds);\n            angle -= getPointloop.angle;\n        }\n        angle = (angle + 360) % 360;\n        label.rotateAngle += angle - (label.rotateAngle + labelWrapper.parentTransform);\n        label.margin.bottom += (labelWrapper.verticalAlignment === 'Top') ? (-label.height / 2) : ((labelWrapper.verticalAlignment === 'Bottom') ? (label.height / 2) : 0);\n        label.margin.right += (labelWrapper.horizontalAlignment === 'Left') ? (-label.width / 2) : ((labelWrapper.horizontalAlignment === 'Right') ? (label.width / 2) : 0);\n        if (label instanceof PathAnnotation) {\n            label.alignment = 'Center';\n        }\n        else {\n            label.horizontalAlignment = label.verticalAlignment = 'Center';\n        }\n        selector.wrapper.rotateAngle = selector.rotateAngle = label.rotateAngle;\n        changedvalues = this.getAnnotationChanges(object, label);\n        if (object instanceof Node) {\n            this.diagram.nodePropertyChange(object, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(object, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(object);\n    };\n    /** @private */\n    CommandHandler.prototype.labelResize = function (node, label, deltaWidth, deltaHeight, pivot, selector) {\n        var oldValues;\n        var changedvalues;\n        var rotateAngle;\n        oldValues = this.getAnnotationChanges(node, label);\n        var textElement = selector.wrapper.children[0];\n        if ((deltaWidth && deltaWidth !== 1) || (deltaHeight && deltaHeight !== 1)) {\n            var newMat = identityMatrix();\n            var matrix = identityMatrix();\n            rotateMatrix(newMat, -node.rotateAngle, node.offsetX, node.offsetY);\n            rotateAngle = ((textElement.rotateAngle + ((node instanceof Node) ? node.rotateAngle : 0)) + 360) % 360;\n            rotateMatrix(matrix, -rotateAngle, pivot.x, pivot.y);\n            scaleMatrix(matrix, deltaWidth, deltaHeight, pivot.x, pivot.y);\n            rotateMatrix(matrix, rotateAngle, pivot.x, pivot.y);\n            var newPosition = transformPointByMatrix(matrix, { x: textElement.offsetX, y: textElement.offsetY });\n            var height = textElement.actualSize.height * deltaHeight;\n            var width = textElement.actualSize.width * deltaWidth;\n            var shape = this.findTarget(textElement, node);\n            if (shape instanceof PathAnnotation) {\n                this.updatePathAnnotationOffset(node, label, 0, 0, newPosition, new Size(width, height));\n            }\n            else {\n                var bounds = cornersPointsBeforeRotation(node.wrapper);\n                newPosition = transformPointByMatrix(newMat, newPosition);\n                newPosition.x = newPosition.x - textElement.margin.left + textElement.margin.right;\n                newPosition.y = newPosition.y - textElement.margin.top + textElement.margin.bottom;\n                newPosition.y += (shape.verticalAlignment === 'Top') ? (-height / 2) : ((shape.verticalAlignment === 'Bottom') ? (height / 2) : 0);\n                newPosition.x += (shape.horizontalAlignment === 'Left') ? (-width / 2) : ((shape.horizontalAlignment === 'Right') ? (width / 2) : 0);\n                var offsetx = bounds.width / (newPosition.x - bounds.x);\n                var offsety = bounds.height / (newPosition.y - bounds.y);\n                if (width > 1) {\n                    shape.width = width;\n                    shape.offset.x = 1 / offsetx;\n                }\n                if (height > 1) {\n                    shape.height = height;\n                    shape.offset.y = 1 / offsety;\n                }\n            }\n        }\n        if (label instanceof PathAnnotation) {\n            label.alignment = 'Center';\n        }\n        changedvalues = this.getAnnotationChanges(node, label);\n        if (node instanceof Node) {\n            this.diagram.nodePropertyChange(node, oldValues, changedvalues);\n        }\n        else {\n            this.diagram.connectorPropertyChange(node, oldValues, changedvalues);\n        }\n        this.diagram.updateDiagramObject(node);\n    };\n    /** @private */\n    CommandHandler.prototype.getSubProcess = function (source) {\n        var selector = { nodes: [], connectors: [] };\n        var process;\n        if (source instanceof Node) {\n            process = source.processId;\n        }\n        else if (source && source.nodes && (source.nodes.length)\n            && source.nodes[0].processId) {\n            process = source.nodes[0].processId;\n        }\n        if (process) {\n            selector.nodes.push(clone(this.diagram.nameTable[process]));\n            return selector;\n        }\n        return selector;\n    };\n    /**   @private  */\n    CommandHandler.prototype.checkBoundaryConstraints = function (tx, ty, nodeBounds) {\n        var pageSettings = this.diagram.pageSettings;\n        var boundaryConstraints = this.diagram.pageSettings.boundaryConstraints;\n        var scroller = this.diagram.scroller;\n        if (boundaryConstraints === 'Page' || boundaryConstraints === 'Diagram') {\n            var selectorBounds = !nodeBounds ? this.diagram.selectedItems.wrapper.bounds : undefined;\n            var width = boundaryConstraints === 'Page' ? pageSettings.width : scroller.viewPortWidth;\n            var height = boundaryConstraints === 'Page' ? pageSettings.height : scroller.viewPortHeight;\n            var bounds = nodeBounds;\n            var right = (nodeBounds ? bounds.right : selectorBounds.right) + (tx || 0);\n            var left = (nodeBounds ? bounds.left : selectorBounds.left) + (tx || 0);\n            var top_2 = (nodeBounds ? bounds.top : selectorBounds.top) + (ty || 0);\n            var bottom = (nodeBounds ? bounds.bottom : selectorBounds.bottom) + (ty || 0);\n            if (right <= width && left >= 0\n                && bottom <= height && top_2 >= 0) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    };\n    //interfaces\n    /** @private */\n    CommandHandler.prototype.dragSelectedObjects = function (tx, ty) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.offsetX = obj.offsetX;\n            this.state.backup.offsetY = obj.offsetY;\n        }\n        obj = renderContainerHelper(this.diagram, obj) || obj;\n        if (this.checkBoundaryConstraints(tx, ty)) {\n            this.diagram.diagramActions = this.diagram.diagramActions | (DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n            var actualObject = this.diagram.selectedObject.actualObject;\n            if ((actualObject && actualObject instanceof Node && actualObject.isLane &&\n                canLaneInterchange(actualObject, this.diagram)) || (!actualObject || !actualObject.isLane)) {\n                this.diagram.drag(obj, tx, ty);\n            }\n            this.diagram.diagramActions = this.diagram.diagramActions & ~(DiagramAction.PreventZIndexOnDragging | DiagramAction.DragUsingMouse);\n            this.diagram.refreshCanvasLayers();\n            return true;\n        }\n        return false;\n    };\n    /** @private */\n    CommandHandler.prototype.scaleSelectedItems = function (sx, sy, pivot) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.offsetX = obj.offsetX;\n            this.state.backup.offsetY = obj.offsetY;\n            this.state.backup.width = obj.width;\n            this.state.backup.height = obj.height;\n            this.state.backup.pivot = pivot;\n        }\n        obj = renderContainerHelper(this.diagram, obj) || obj;\n        return this.diagram.scale(obj, sx, sy, pivot);\n    };\n    /** @private */\n    CommandHandler.prototype.rotateSelectedItems = function (angle) {\n        var obj = this.diagram.selectedItems;\n        if (this.state && !this.state.backup) {\n            this.state.backup = {};\n            this.state.backup.angle = obj.rotateAngle;\n        }\n        obj = renderContainerHelper(this.diagram, obj) || obj;\n        return this.diagram.rotate(obj, angle);\n    };\n    /** @private */\n    CommandHandler.prototype.hasSelection = function () {\n        return hasSelection(this.diagram);\n    };\n    /** @private */\n    CommandHandler.prototype.isSelected = function (element) {\n        return isSelected(this.diagram, element);\n    };\n    /**\n     * initExpand is used for layout expand and collapse interaction\n     */\n    CommandHandler.prototype.initExpand = function (args) {\n        var propName = 'isProtectedOnChange';\n        var protectedChange = this.diagram[propName];\n        this.diagram.protectPropertyChange(true);\n        var node = (args.target || args.source);\n        var oldValues = { isExpanded: node.isExpanded };\n        node.isExpanded = !node.isExpanded;\n        this.diagram.preventNodesUpdate = true;\n        this.diagram.diagramActions |= DiagramAction.PreventIconsUpdate;\n        this.diagram.nodePropertyChange(node, oldValues, { isExpanded: node.isExpanded });\n        this.diagram.diagramActions = this.diagram.diagramActions & ~DiagramAction.PreventIconsUpdate;\n        this.diagram.preventNodesUpdate = false;\n        for (var _i = 0, _a = this.diagram.views; _i < _a.length; _i++) {\n            var temp = _a[_i];\n            var view = this.diagram.views[temp];\n            if (!(view instanceof Diagram)) {\n                this.diagram.refreshCanvasDiagramLayer(view);\n            }\n        }\n        this.diagram.protectPropertyChange(protectedChange);\n    };\n    /** @private */\n    CommandHandler.prototype.expandNode = function (node, diagram) {\n        var animation;\n        //let objects: ILayout;\n        var preventNodesUpdate = this.diagram.preventNodesUpdate;\n        var expand = node.isExpanded;\n        this.diagram.preventNodesUpdate = true;\n        this.diagram.preventConnectorsUpdate = true;\n        this.expandCollapse(node, expand, this.diagram);\n        node.isExpanded = expand;\n        var fixedNode = this.diagram.layout.fixedNode;\n        this.diagram.layout.fixedNode = node.id;\n        if ((this.diagram.diagramActions != DiagramAction.Render) && this.diagram.layoutAnimateModule && this.diagram.layout.enableAnimation && this.diagram.organizationalChartModule) {\n            this.diagram.organizationalChartModule.isAnimation = true;\n        }\n        this.diagram.blazorActions |= BlazorAction.expandNode;\n        var objects = this.diagram.doLayout();\n        this.diagram.blazorActions &= ~BlazorAction.expandNode;\n        this.diagram.preventNodesUpdate = preventNodesUpdate;\n        this.diagram.preventConnectorsUpdate = false;\n        if (this.diagram.layoutAnimateModule && this.diagram.organizationalChartModule) {\n            this.diagram.allowServerDataBinding = false;\n            this.layoutAnimateModule.expand(this.diagram.layout.enableAnimation, objects, node, this.diagram);\n            this.diagram.allowServerDataBinding = true;\n        }\n        else {\n            var arg = {\n                element: cloneBlazorObject(clone(node)), state: (node.isExpanded) ? true : false\n            };\n            this.triggerEvent(DiagramEvent.expandStateChange, arg);\n            if (this.diagram.lineRoutingModule && this.diagram.constraints & DiagramConstraints.LineRouting) {\n                this.diagram.resetSegments();\n            }\n        }\n        this.diagram.layout.fixedNode = fixedNode === '' ? '' : this.diagram.layout.fixedNode;\n        return objects;\n    };\n    CommandHandler.prototype.getparentexpand = function (target, diagram, visibility, connector) {\n        var boolean;\n        for (var i = 0; i < target.inEdges.length; i++) {\n            var newConnector = diagram.nameTable[target.inEdges[i]];\n            var previousNode = diagram.nameTable[newConnector.sourceID];\n            if (previousNode.isExpanded && !visibility && previousNode.id !== connector.sourceID && newConnector.visible) {\n                return false;\n            }\n            else {\n                boolean = true;\n            }\n        }\n        return boolean;\n    };\n    /**\n     * Setinterval and Clear interval for layout animation\n     */\n    /** @private */\n    CommandHandler.prototype.expandCollapse = function (source, visibility, diagram) {\n        for (var i = 0; i < source.outEdges.length; i++) {\n            var connector = diagram.nameTable[source.outEdges[i]];\n            var target = diagram.nameTable[connector.targetID];\n            var value = this.getparentexpand(target, diagram, visibility, connector);\n            connector.visible = visibility;\n            var oldValues = {\n                visible: target.visible,\n                style: { opacity: target.wrapper.style.opacity }\n            };\n            var newValues = {\n                visible: target.visible,\n                style: { opacity: target.wrapper.style.opacity }\n            };\n            if (value) {\n                if (target.isExpanded) {\n                    this.expandCollapse(target, visibility, diagram);\n                }\n                target.visible = visibility;\n                target.style.opacity = (this.diagram.layoutAnimateModule &&\n                    this.diagram.layout.enableAnimation && visibility) ? 0.1 : target.style.opacity;\n                diagram.nodePropertyChange(target, oldValues, newValues);\n            }\n            diagram.connectorPropertyChange(connector, oldValues, newValues);\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateNodeDimension = function (obj, rect) {\n        if (obj instanceof Node) {\n            obj.offsetX = rect.x + rect.width / 2;\n            obj.offsetY = rect.y + rect.height / 2;\n            obj.width = rect.width;\n            obj.height = rect.height;\n            obj.wrapper.children[0].canMeasurePath = true;\n            this.diagram.nodePropertyChange(obj, {}, {\n                width: rect.width, height: rect.height, offsetX: obj.offsetX,\n                offsetY: obj.offsetY\n            });\n            if (this.diagram.mode !== 'SVG') {\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateConnectorPoints = function (obj, rect) {\n        if (obj instanceof Connector) {\n            this.diagram.connectorPropertyChange(obj, {}, {\n                targetPoint: obj.targetPoint\n            });\n            this.diagram.updateDiagramObject(obj);\n        }\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.updateSelectedNodeProperties = function (object) {\n        if (this.diagram.lineRoutingModule && (this.diagram.constraints & DiagramConstraints.LineRouting)) {\n            var previousNodeObject = [];\n            var previousConnectorObject = [];\n            var updateNodeObject = [];\n            var updateConnectorObject = [];\n            var changeNodes = [];\n            var changeConnectors = [];\n            this.diagram.protectPropertyChange(true);\n            var objects = [];\n            var connectors = [];\n            var actualObject = this.diagram.selectedObject.actualObject;\n            var helperObject = this.diagram.selectedObject.helperObject;\n            if (helperObject && actualObject) {\n                var offsetX = (helperObject.offsetX - actualObject.offsetX);\n                var offsetY = (helperObject.offsetY - actualObject.offsetY);\n                var width = (helperObject.width - actualObject.width);\n                var height = (helperObject.height - actualObject.height);\n                var rotateAngle = (helperObject.rotateAngle - actualObject.rotateAngle);\n                if (this.diagram.selectedItems.nodes.length + this.diagram.selectedItems.connectors.length > 0) {\n                    this.diagram.selectedItems.wrapper.rotateAngle = this.diagram.selectedItems.rotateAngle = helperObject.rotateAngle;\n                }\n                if (actualObject instanceof Node &&\n                    actualObject.shape.type !== 'SwimLane' && !actualObject.isLane && !actualObject.isPhase && !actualObject.isHeader) {\n                    if (actualObject.offsetX !== actualObject.wrapper.offsetX || actualObject.offsetY !== actualObject.wrapper.offsetY ||\n                        actualObject.width !== actualObject.wrapper.width || actualObject.height !== actualObject.wrapper.height ||\n                        actualObject.rotateAngle !== actualObject.wrapper.rotateAngle) {\n                        if (isBlazor()) {\n                            previousNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n                        }\n                        actualObject.offsetX += offsetX;\n                        actualObject.offsetY += offsetY;\n                        actualObject.width += width;\n                        actualObject.height += height;\n                        actualObject.rotateAngle += rotateAngle;\n                        this.diagram.nodePropertyChange(actualObject, {}, {\n                            offsetX: actualObject.offsetX, offsetY: actualObject.offsetY,\n                            width: actualObject.width, height: actualObject.height, rotateAngle: actualObject.rotateAngle\n                        });\n                        if (isBlazor()) {\n                            updateNodeObject.push(cloneObject(actualObject, undefined, undefined, true));\n                        }\n                    }\n                    objects = this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds);\n                }\n                else if (actualObject instanceof Selector) {\n                    for (var i = 0; i < actualObject.nodes.length; i++) {\n                        var node = actualObject.nodes[i];\n                        if (node instanceof Node && node.shape.type !== 'SwimLane' && !node.isLane\n                            && !node.isPhase && !node.isHeader) {\n                            node.offsetX += offsetX;\n                            node.offsetY += offsetY;\n                            node.width += width;\n                            node.height += height;\n                            node.rotateAngle += rotateAngle;\n                            this.diagram.nodePropertyChange(node, {}, {\n                                offsetX: node.offsetX, offsetY: node.offsetY,\n                                width: node.width, height: node.height, rotateAngle: node.rotateAngle\n                            });\n                            objects = objects.concat(this.diagram.spatialSearch.findObjects(actualObject.wrapper.outerBounds));\n                        }\n                    }\n                }\n            }\n            else {\n                if (object instanceof Connector) {\n                    objects.push(object);\n                }\n                else if (object instanceof Selector && object.connectors.length) {\n                    objects = objects.concat(object.connectors);\n                }\n            }\n            for (var i = 0; i < objects.length; i++) {\n                if (objects[i] instanceof Connector && connectors.indexOf(objects[i].id) === -1) {\n                    connectors.push(objects[i].id);\n                }\n            }\n            this.diagram.lineRoutingModule.renderVirtualRegion(this.diagram, true);\n            for (var i = 0; i < connectors.length; i++) {\n                var connector = this.diagram.nameTable[connectors[i]];\n                if (connector instanceof Connector && connector.type === 'Orthogonal') {\n                    if (isBlazor()) {\n                        previousConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n                    }\n                    this.diagram.lineRoutingModule.refreshConnectorSegments(this.diagram, connector, true);\n                    if (isBlazor()) {\n                        updateConnectorObject.push(cloneObject(connector, undefined, undefined, true));\n                    }\n                }\n            }\n            this.updateSelector();\n            if (isBlazor()) {\n                this.getObjectChanges(previousNodeObject, updateNodeObject, changeNodes);\n                this.getObjectChanges(previousConnectorObject, updateConnectorObject, changeConnectors);\n                var blazorInterop = 'sfBlazor';\n                var blazor = 'Blazor';\n                var diagramObject = { nodes: changeNodes, connectors: changeConnectors };\n                if (window && window[blazor] && (changeConnectors.length + changeNodes.length)) {\n                    var obj = { 'methodName': 'UpdateBlazorProperties', 'diagramobj': diagramObject };\n                    window[blazorInterop].updateBlazorProperties(obj, this.diagram);\n                }\n            }\n            this.diagram.protectPropertyChange(false);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drawSelectionRectangle = function (x, y, width, height) {\n        this.diagram.drawSelectionRectangle(x, y, width, height);\n    };\n    /** @private */\n    CommandHandler.prototype.startGroupAction = function () {\n        this.diagram.startGroupAction();\n    };\n    /** @private */\n    CommandHandler.prototype.endGroupAction = function () {\n        this.diagram.endGroupAction();\n    };\n    /** @private */\n    CommandHandler.prototype.removeChildFromBPmn = function (child, newTarget, oldTarget) {\n        var obj = this.diagram.nameTable[child.id] || child.nodes[0];\n        if (oldTarget) {\n            if ((obj) && obj.processId && obj.processId === oldTarget.wrapper.id) {\n                var node = clone(obj);\n                node.processId = obj.processId;\n                this.diagram.startGroupAction();\n                var edges = [];\n                edges = edges.concat(obj.outEdges, obj.inEdges);\n                for (var i = edges.length - 1; i >= 0; i--) {\n                    var connector = this.diagram.nameTable[edges[i]];\n                    if (connector) {\n                        this.diagram.remove(connector);\n                    }\n                }\n                //let nodeCollection: string[];\n                var nodeCollection = (this.diagram.nameTable[obj.processId].shape.activity.subProcess.processes) || [];\n                nodeCollection.splice(nodeCollection.indexOf((obj).id), 1);\n                this.diagram.bpmnModule.removeChildFromBPMN(this.diagram.nameTable[obj.processId].wrapper, (obj).id);\n                this.diagram.nameTable[(obj).id].processId = '';\n                obj.offsetX = obj.wrapper.offsetX;\n                obj.offsetY = obj.wrapper.offsetY;\n                var undoElement = clone(obj);\n                var entry = {\n                    type: 'PositionChanged', redoObject: { nodes: [undoElement] }, undoObject: { nodes: [node] }, category: 'Internal'\n                };\n                this.addHistoryEntry(entry);\n                this.diagram.endGroupAction();\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.isDroppable = function (source, targetNodes) {\n        var node = this.diagram.nameTable[source.id] || source.nodes[0];\n        if (node) {\n            if ((!isBlazor() && node.shape.shape === 'TextAnnotation') ||\n                (isBlazor() && node.shape.bpmnShape === 'TextAnnotation')) {\n                return true;\n            }\n            if (node && node.shape.type === 'Bpmn') {\n                if ((node.processId === targetNodes.id) || (node.id === targetNodes.processId) ||\n                    targetNodes.shape.type === 'Bpmn'\n                        && targetNodes.shape.activity.subProcess.collapsed) {\n                    return false;\n                }\n            }\n            return true;\n        }\n        return false;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.renderHighlighter = function (args, connectHighlighter, source) {\n        var bounds = new Rect();\n        if (args.target instanceof Node || (connectHighlighter && args.source instanceof Node)) {\n            var tgt = connectHighlighter ? args.source : args.target;\n            var tgtWrap = connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n            var target = this.findTarget(tgtWrap, tgt, source, true);\n            var element = void 0;\n            if (target instanceof BpmnSubEvent) {\n                var portId = target.id;\n                var node = args.target;\n                var parent_6 = node.wrapper.children[0].children[0].children[2];\n                for (var _i = 0, _a = parent_6.children; _i < _a.length; _i++) {\n                    var child = _a[_i];\n                    if (child.id === node.id + '_' + portId) {\n                        element = child.children[0];\n                        break;\n                    }\n                }\n            }\n            else {\n                element = target instanceof Node ?\n                    target.wrapper : connectHighlighter ? args.sourceWrapper : args.targetWrapper;\n            }\n            this.diagram.renderHighlighter(element);\n        }\n    };\n    //additional events\n    /** @private */\n    CommandHandler.prototype.mouseOver = function (source, target, position) {\n        //mouse over\n        //returns whether the source can move over the target or not\n        return true;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.snapPoint = function (startPoint, endPoint, tx, ty) {\n        var obj = this.diagram.selectedItems;\n        var point;\n        var towardsLeft = endPoint.x < startPoint.x;\n        var towardsTop = endPoint.y < startPoint.y;\n        point = { x: tx, y: ty };\n        var snappedPoint = point;\n        if (this.snappingModule) {\n            snappedPoint = this.diagram.snappingModule.snapPoint(this.diagram, obj, towardsLeft, towardsTop, point, startPoint, endPoint);\n        }\n        return snappedPoint;\n    };\n    /**\n     * @private\n     */\n    CommandHandler.prototype.removeSnap = function () {\n        if ((this.diagram.snapSettings.constraints & SnapConstraints.SnapToObject) && this.snappingModule) {\n            this.snappingModule.removeGuidelines(this.diagram);\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.dropAnnotation = function (source, target) {\n        var node = (source instanceof Node) ? source : source.nodes[0];\n        if (this.diagram.bpmnModule && target.shape.type === 'Bpmn'\n            && ((!isBlazor() && node.shape.shape === 'TextAnnotation') ||\n                (isBlazor() && node.shape.bpmnShape === 'TextAnnotation'))) {\n            var hasTarget = 'hasTarget';\n            node[hasTarget] = target.id;\n            node.shape.annotation.nodeId = target.id;\n            if (!this.diagram.currentSymbol) {\n                this.diagram.addTextAnnotation(node.shape.annotation, target);\n                node.shape.annotation.nodeId = '';\n                this.diagram.remove(node);\n            }\n            this.diagram.refreshDiagramLayer();\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.drop = function (source, target, position) {\n        //drop\n        if (this.diagram.bpmnModule) {\n            var sourcenode = (source instanceof Node) ? source : source.nodes[0];\n            if (sourcenode && sourcenode.shape.type === 'Bpmn' && target.shape.type === 'Bpmn') {\n                this.diagram.bpmnModule.dropBPMNchild(target, (source instanceof Node) ? source : source.nodes[0], this.diagram);\n                this.diagram.refreshDiagramLayer();\n            }\n        }\n    };\n    /** @private */\n    CommandHandler.prototype.addHistoryEntry = function (entry) {\n        this.diagram.addHistoryEntry(entry);\n    };\n    /** @private */\n    CommandHandler.prototype.align = function (objects, option, type) {\n        if (objects.length > 0) {\n            var i = 0;\n            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n            var bounds = (type === 'Object') ? getBounds(objects[0].wrapper) : this.diagram.selectedItems.wrapper.bounds;\n            var undoObj = { nodes: [], connectors: [] };\n            var redoObj = { nodes: [], connectors: [] };\n            for (i = ((type === 'Object') ? (i + 1) : i); i < objects.length; i++) {\n                var tx = 0;\n                var ty = 0;\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n                var objectBounds = getBounds(objects[i].wrapper);\n                if (option === 'Left') {\n                    tx = bounds.left + objectBounds.width / 2 - objectBounds.center.x;\n                }\n                else if (option === 'Right') {\n                    tx = bounds.right - objectBounds.width / 2 - objectBounds.center.x;\n                }\n                else if (option === 'Top') {\n                    ty = bounds.top + objectBounds.height / 2 - objectBounds.center.y;\n                }\n                else if (option === 'Bottom') {\n                    ty = bounds.bottom - objectBounds.height / 2 - objectBounds.center.y;\n                }\n                else if (option === 'Center') {\n                    tx = bounds.center.x - objectBounds.center.x;\n                }\n                else if (option === 'Middle') {\n                    ty = bounds.center.y - objectBounds.center.y;\n                }\n                undoObj = this.storeObject(undoObj, objects[i]);\n                this.drag(objects[i], tx, ty);\n                this.diagram.updateSelector();\n                redoObj = this.storeObject(redoObj, objects[i]);\n            }\n            undoObj = clone(undoObj);\n            redoObj = clone(redoObj);\n            var entry = {\n                type: 'Align', category: 'Internal',\n                undoObject: cloneObject(undoObj), redoObject: cloneObject(redoObj)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    /**\n     * distribute method \\\n     *\n     * @returns { void }     distribute method .\\\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n     * @param {SizingOptions} option - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.distribute = function (objects, option) {\n        if (objects.length > 0) {\n            var i = 0;\n            //const j: number = 0;\n            //const rect: Rect = new Rect();\n            //const b: Rect[] = [];\n            //let temp: NodeModel | ConnectorModel;\n            var right = 0;\n            var left = 0;\n            var top_3 = 0;\n            var bottom = 0;\n            var center = 0;\n            var middle = 0;\n            var btt = 0;\n            //const sum: number = 0;\n            var undoSelectorObj = { nodes: [], connectors: [] };\n            var redoSelectorObj = { nodes: [], connectors: [] };\n            for (i = 0; i < objects.length; i++) {\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[i];\n            }\n            objects = sort(objects, option);\n            for (i = 1; i < objects.length; i++) {\n                right = right + objects[i].wrapper.bounds.topRight.x - objects[i - 1].wrapper.bounds.topRight.x;\n                left = left + objects[i].wrapper.bounds.topLeft.x - objects[i - 1].wrapper.bounds.topLeft.x;\n                top_3 = top_3 + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.topRight.y;\n                bottom = bottom + objects[i].wrapper.bounds.bottomRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n                center = center + objects[i].wrapper.bounds.center.x - objects[i - 1].wrapper.bounds.center.x;\n                middle = middle + objects[i].wrapper.bounds.center.y - objects[i - 1].wrapper.bounds.center.y;\n                btt = btt + objects[i].wrapper.bounds.topRight.y - objects[i - 1].wrapper.bounds.bottomRight.y;\n            }\n            for (i = 1; i < objects.length - 1; i++) {\n                var tx = 0;\n                var ty = 0;\n                var prev = getBounds(objects[i - 1].wrapper);\n                var current = getBounds(objects[i].wrapper);\n                if (option === 'RightToLeft' || option === 'Center') {\n                    tx = prev.center.x - current.center.x + (center / (objects.length - 1));\n                }\n                else if (option === 'Right') {\n                    tx = prev.topRight.x - current.topRight.x + (right / (objects.length - 1));\n                }\n                else if (option === 'Left') {\n                    tx = prev.topLeft.x - current.topLeft.x + (left / (objects.length - 1));\n                }\n                else if (option === 'Middle') {\n                    ty = prev.center.y - current.center.y + (middle / (objects.length - 1));\n                }\n                else if (option === 'Top') {\n                    ty = prev.topRight.y - current.topRight.y + (top_3 / (objects.length - 1));\n                }\n                else if (option === 'Bottom') {\n                    ty = prev.bottomRight.y - current.bottomRight.y + (bottom / (objects.length - 1));\n                }\n                else if (option === 'BottomToTop') {\n                    ty = prev.bottomRight.y - current.topRight.y + (btt / (objects.length - 1));\n                }\n                undoSelectorObj = this.storeObject(undoSelectorObj, objects[i]);\n                this.drag(objects[i], tx, ty);\n                this.diagram.updateSelector();\n                redoSelectorObj = this.storeObject(redoSelectorObj, objects[i]);\n            }\n            undoSelectorObj = clone(undoSelectorObj);\n            redoSelectorObj = clone(redoSelectorObj);\n            var entry = {\n                type: 'Distribute', category: 'Internal',\n                undoObject: cloneObject(undoSelectorObj), redoObject: cloneObject(redoSelectorObj)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    /* eslint-enable */\n    /**\n     * sameSize method \\\n     *\n     * @returns { void }     sameSize method .\\\n     * @param {(NodeModel | ConnectorModel)[]} objects - provide the source value.\n     * @param {SizingOptions} option - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.sameSize = function (objects, option) {\n        if (objects.length > 0) {\n            var i = 0;\n            //let pivot: PointModel;\n            var pivot = { x: 0.5, y: 0.5 };\n            objects[0] = this.diagram.nameTable[objects[0].id] || objects[0];\n            var bounds = getBounds(objects[0].wrapper);\n            var undoObject = { nodes: [], connectors: [] };\n            var redoObject = { nodes: [], connectors: [] };\n            for (i = 1; i < objects.length; i++) {\n                objects[i] = this.diagram.nameTable[objects[i].id] || objects[0];\n                var rect = getBounds(objects[i].wrapper);\n                var sw = 1;\n                var sh = 1;\n                if (option === 'Width') {\n                    sw = bounds.width / rect.width;\n                }\n                else if (option === 'Height') {\n                    sh = bounds.height / rect.height;\n                }\n                else if (option === 'Size') {\n                    sw = bounds.width / rect.width;\n                    sh = bounds.height / rect.height;\n                }\n                undoObject = this.storeObject(undoObject, objects[i]);\n                this.scale(objects[i], sw, sh, pivot);\n                redoObject = this.storeObject(redoObject, objects[i]);\n            }\n            this.diagram.updateSelector();\n            undoObject = clone(undoObject);\n            redoObject = clone(redoObject);\n            var entry = {\n                type: 'Sizing', category: 'Internal',\n                undoObject: cloneObject(undoObject), redoObject: cloneObject(redoObject)\n            };\n            this.addHistoryEntry(entry);\n        }\n    };\n    CommandHandler.prototype.storeObject = function (selectorObject, obj) {\n        if (obj instanceof Node) {\n            selectorObject.nodes.push(clone(obj));\n        }\n        else {\n            selectorObject.connectors.push(clone(obj));\n        }\n        return selectorObject;\n    };\n    /**\n     * updatePanState method \\\n     *\n     * @returns { any }     updatePanState method .\\\n     * @param {number} eventCheck - provide the eventCheck value.\n     *\n     * @private\n     */\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    CommandHandler.prototype.updatePanState = function (eventCheck) {\n        if (eventCheck) {\n            this.diagram.realActions = this.diagram.realActions | RealAction.PanInProgress;\n        }\n        else {\n            this.diagram.dataBind();\n            var diagramScrollSettings = this.diagram.scrollSettings;\n            this.diagram.realActions = this.diagram.realActions & ~RealAction.PanInProgress;\n            var Values = {\n                VerticalOffset: diagramScrollSettings.verticalOffset, HorizontalOffset: diagramScrollSettings.horizontalOffset,\n                ViewportHeight: diagramScrollSettings.viewPortHeight, ViewportWidth: diagramScrollSettings.viewPortWidth,\n                CurrentZoom: diagramScrollSettings.currentZoom\n            };\n            var arg = {\n                oldValue: Values,\n                newValue: Values, source: this.diagram, panState: 'Completed'\n            };\n            this.triggerEvent(DiagramEvent.scrollChange, arg);\n        }\n    };\n    /**\n     * dataBinding method \\\n     *\n     * @returns { void }     dataBinding method .\\\n     *\n     * @private\n     */\n    CommandHandler.prototype.dataBinding = function () {\n        this.diagram.dataBind();\n    };\n    CommandHandler.prototype.setBlazorDiagramProps = function (arg) {\n        this.diagram.setBlazorDiagramProps(arg);\n    };\n    /**\n     * scroll method \\\n     *\n     * @returns { void }     scroll method .\\\n     * @param {number} scrollX - provide the source value.\n     * @param {number} scrollY - provide the target value.\n     * @param {PointModel} focusPoint - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.scroll = function (scrollX, scrollY, focusPoint) {\n        var panx = canPanX(this.diagram);\n        var pany = canPanY(this.diagram);\n        if (isBlazor()) {\n            this.diagram.setCursor('grabbing');\n            this.diagram.scroller.zoom(1, (scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n        }\n        else {\n            this.diagram.pan((scrollX = panx ? scrollX : 0) * this.diagram.scroller.currentZoom, (scrollY = pany ? scrollY : 0) * this.diagram.scroller.currentZoom, focusPoint);\n        }\n    };\n    /**\n     * drawHighlighter method \\\n     *\n     * @returns { NodeModel | ConnectorModel }     drawHighlighter method .\\\n     * @param {IElement} element - provide the element value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.drawHighlighter = function (element) {\n        this.diagram.renderHighlighter(element.wrapper);\n    };\n    /**\n     * removeHighlighter method \\\n     *\n     * @returns { void }     removeHighlighter method .\\\n     *\n     * @private\n     */\n    CommandHandler.prototype.removeHighlighter = function () {\n        this.diagram.clearHighlighter();\n    };\n    /**\n     * renderContainerHelper method \\\n     *\n     * @returns { NodeModel | ConnectorModel }     renderContainerHelper method .\\\n     * @param {NodeModel | SelectorModel | ConnectorModel} node - provide the parent value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.renderContainerHelper = function (node) {\n        return renderContainerHelper(this.diagram, node);\n    };\n    /**\n     * isParentAsContainer method \\\n     *\n     * @returns { boolean }     isParentAsContainer method .\\\n     * @param {NodeModel} node - provide the parent value.\n     * @param {boolean} isChild - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.isParentAsContainer = function (node, isChild) {\n        return checkParentAsContainer(this.diagram, node, isChild);\n    };\n    /**\n     * dropChildToContainer method \\\n     *\n     * @returns { void }     dropChildToContainer method .\\\n     * @param {NodeModel} parent - provide the parent value.\n     * @param {NodeModel} node - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.dropChildToContainer = function (parent, node) {\n        if (!(this.diagram.diagramActions & DiagramAction.PreventLaneContainerUpdate)) {\n            addChildToContainer(this.diagram, parent, node);\n        }\n    };\n    /**\n    *\n    * @private\n    */\n    CommandHandler.prototype.updateLaneChildrenZindex = function (node, target) {\n        var lowerIndexobject = this.findLeastIndexObject(node, target);\n        var swimlane = this.diagram.nameTable[target.parentId];\n        if (swimlane.zIndex > lowerIndexobject.zIndex) {\n            var layerIndex = this.diagram.layers.indexOf(this.diagram.getActiveLayer());\n            var layerZIndexTable = this.diagram.layers[layerIndex].zIndexTable;\n            var startIndex = lowerIndexobject.zIndex;\n            var endIndex = swimlane.zIndex;\n            for (var i = endIndex; i >= startIndex; i--) {\n                if (startIndex !== i) {\n                    if (!layerZIndexTable[i - 1]) {\n                        layerZIndexTable[i - 1] = layerZIndexTable[i];\n                        this.diagram.nameTable[layerZIndexTable[i - 1]].zIndex = i;\n                        delete layerZIndexTable[i];\n                    }\n                    else {\n                        //bringing the objects forward\n                        layerZIndexTable[i] = layerZIndexTable[i - 1];\n                        this.diagram.nameTable[layerZIndexTable[i]].zIndex = i;\n                    }\n                }\n                else {\n                    layerZIndexTable[i] = swimlane.id;\n                    this.diagram.nameTable[swimlane.id].zIndex = i;\n                }\n            }\n            if (this.diagram.mode === 'SVG') {\n                this.moveSvgNode(target.parentId, lowerIndexobject.id);\n                this.updateNativeNodeIndex(target.parentId, lowerIndexobject.id);\n            }\n            else {\n                this.diagram.refreshCanvasLayers();\n            }\n        }\n    };\n    CommandHandler.prototype.findLeastIndexConnector = function (edges, target, index) {\n        for (var i = 0; i < edges.length; i++) {\n            var connector = this.diagram.nameTable[edges[i]];\n            if (index.zIndex > connector.zIndex) {\n                index = connector;\n            }\n        }\n        return index;\n    };\n    CommandHandler.prototype.findLeastIndexObject = function (node, target) {\n        var lowerIndexobject = node;\n        if (node instanceof Node) {\n            lowerIndexobject = this.findLeastIndexConnector(node.inEdges, target, lowerIndexobject);\n            lowerIndexobject = this.findLeastIndexConnector(node.outEdges, target, lowerIndexobject);\n        }\n        return lowerIndexobject;\n    };\n    /**\n     * checkSelection method \\\n     *\n     * @returns { void }     checkSelection method .\\\n     * @param {SelectorModel} selector - provide the source value.\n     * @param {string} corner - provide the target value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.checkSelection = function (selector, corner) {\n        var node; // let wrapper: GridPanel; let child: Container; let index: number; let shape: SwimLaneModel;\n        if (selector.nodes.length === 1 && selector.connectors.length === 0) {\n            if (checkParentAsContainer(this.diagram, selector.nodes[0], true)) {\n                node = (selector.nodes[0].shape === 'SwimLane') ? selector.nodes[0] :\n                    this.diagram.nameTable[selector.nodes[0].parentId];\n                var child = selector.nodes[0];\n                if (node.shape.type === 'SwimLane') {\n                    var orientation_1 = (node.shape.orientation === 'Horizontal') ? true : false;\n                    if ((child.isPhase && ((orientation_1 && corner === 'ResizeSouth') || (!orientation_1 && corner === 'ResizeEast'))) ||\n                        (child.isLane && ((orientation_1 && corner === 'ResizeEast') || (!orientation_1 && corner === 'ResizeSouth')))) {\n                        swimLaneSelection(this.diagram, node, corner);\n                    }\n                }\n                else if (node.container.type === 'Grid') {\n                    if (((node.container.orientation === 'Horizontal' && child.rowIndex === 1) ||\n                        (node.container.orientation === 'Vertical' && child.rowIndex > 0 && child.columnIndex > 0))) {\n                        if (corner === 'ResizeSouth') {\n                            for (var i = 0; i < this.diagram.nodes.length; i++) {\n                                var obj = this.diagram.nodes[i];\n                                if (obj.rowIndex === node.rows.length - 1 && obj.columnIndex === 0) {\n                                    this.select(obj);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                    else {\n                        if (corner === 'ResizeEast') {\n                            for (var i = 0; i < this.diagram.nodes.length; i++) {\n                                var obj = this.diagram.nodes[i];\n                                if (obj.rowIndex === 1 && obj.columnIndex === node.columns.length - 1) {\n                                    this.select(obj);\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            else {\n                swimLaneSelection(this.diagram, selector.nodes[0], corner);\n            }\n        }\n    };\n    /**\n     * zoom method \\\n     *\n     * @returns { void }     zoom method .\\\n     * @param {number} scale - provide the source value.\n     * @param {number} scrollX - provide the target value.\n     * @param {number} scrollY - provide the layoutOrientation value.\n     * @param {PointModel} focusPoint - provide the layoutOrientation value.\n     *\n     * @private\n     */\n    CommandHandler.prototype.zoom = function (scale, scrollX, scrollY, focusPoint) {\n        this.diagram.scroller.zoom(scale, scrollX * this.diagram.scroller.currentZoom, scrollY * this.diagram.scroller.currentZoom, focusPoint);\n    };\n    return CommandHandler;\n}());\nexport { CommandHandler };\n"]},"metadata":{},"sourceType":"module"}