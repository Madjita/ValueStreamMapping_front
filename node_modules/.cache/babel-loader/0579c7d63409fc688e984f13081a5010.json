{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];\n    };\n\n    return extendStatics(d, b);\n  };\n\n  return function (d, b) {\n    extendStatics(d, b);\n\n    function __() {\n      this.constructor = d;\n    }\n\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable jsdoc/require-param */\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\n/* eslint-disable valid-jsdoc */\n\n/* eslint-disable jsdoc/require-returns */\n\n/* eslint-disable @typescript-eslint/ban-types */\n\n/* eslint-disable no-self-assign */\n\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path='./node-base-model.d.ts'/>\n\n\nimport { Property, Complex, Collection, ChildProperty, ComplexFactory, CollectionFactory, isBlazor } from '@syncfusion/ej2-base';\nimport { ShapeStyle, StrokeStyle } from '../core/appearance';\nimport { Point } from '../primitives/point';\nimport { TextElement } from '../core/elements/text-element';\nimport { Transform, ConnectorConstraints } from '../enum/enum';\nimport { PortConstraints } from '../enum/enum';\nimport { Rect } from '../primitives/rect';\nimport { Size } from '../primitives/size';\nimport { findAngle, findConnectorPoints, getOuterBounds } from '../utility/connector';\nimport { getAnnotationPosition, alignLabelOnSegments, updateConnector } from '../utility/diagram-util';\nimport { setUMLActivityDefaults, initfixedUserHandlesSymbol } from '../utility/diagram-util';\nimport { findDistance, findPath, updatePathElement, setConnectorDefaults } from '../utility/diagram-util';\nimport { randomId, getFunction } from './../utility/base-util';\nimport { flipConnector } from './../utility/diagram-util';\nimport { PathElement } from '../core/elements/path-element';\nimport { PathAnnotation } from './annotation';\nimport { Canvas } from '../core/containers/canvas';\nimport { getDecoratorShape } from './dictionary/common';\nimport { DiagramElement } from '../core/elements/diagram-element';\nimport { DiagramAction } from '../enum/enum';\nimport { NodeBase } from './node-base';\nimport { DiagramTooltip } from './tooltip';\nimport { identityMatrix, rotateMatrix, scaleMatrix, transformPointsByMatrix, transformPointByMatrix } from '../primitives/matrix';\nimport { DiagramHtmlElement } from '../core/elements/html-element';\nimport { getTemplateContent } from '../utility/dom-util';\nimport { SymbolSize } from './preview';\nimport { ConnectorFixedUserHandle } from './fixed-user-handle';\n\nvar getConnectorType = function (obj) {\n  if (isBlazor()) {\n    return DiagramConnectorShape;\n  } else {\n    if (obj) {\n      switch (obj.type) {\n        case 'Bpmn':\n          return BpmnFlow;\n\n        case 'UmlActivity':\n          return ActivityFlow;\n\n        case 'UmlClassifier':\n          return RelationShip;\n\n        default:\n          return ConnectorShape;\n      }\n    }\n\n    return ConnectorShape;\n  }\n};\n\nvar getSegmentType = function (obj) {\n  if (obj) {\n    if (isBlazor()) {\n      return DiagramConnectorSegment;\n    } else {\n      switch (obj.type) {\n        case 'Straight':\n          return StraightSegment;\n\n        case 'Bezier':\n          return BezierSegment;\n\n        case 'Orthogonal':\n          return OrthogonalSegment;\n\n        default:\n          return StraightSegment;\n      }\n    }\n  }\n\n  return undefined;\n};\n/**\n * Decorators are used to decorate the end points of the connector with some predefined path geometry\n */\n\n\nvar Decorator =\n/** @class */\nfunction (_super) {\n  __extends(Decorator, _super);\n\n  function Decorator() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(10)], Decorator.prototype, \"width\", void 0);\n\n  __decorate([Property(10)], Decorator.prototype, \"height\", void 0);\n\n  __decorate([Property('Arrow')], Decorator.prototype, \"shape\", void 0);\n\n  __decorate([Complex({\n    fill: 'black',\n    strokeColor: 'black',\n    strokeWidth: 1\n  }, ShapeStyle)], Decorator.prototype, \"style\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0.5\n  }, Point)], Decorator.prototype, \"pivot\", void 0);\n\n  __decorate([Property('')], Decorator.prototype, \"pathData\", void 0);\n\n  return Decorator;\n}(ChildProperty);\n\nexport { Decorator };\n/**\n * Describes the length and angle between the control point and the start point of bezier segment\n */\n\nvar Vector =\n/** @class */\nfunction (_super) {\n  __extends(Vector, _super);\n\n  function Vector() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(0)], Vector.prototype, \"angle\", void 0);\n\n  __decorate([Property(0)], Vector.prototype, \"distance\", void 0);\n\n  return Vector;\n}(ChildProperty);\n\nexport { Vector };\n/**\n * Sets the type of the connector\n */\n\nvar ConnectorShape =\n/** @class */\nfunction (_super) {\n  __extends(ConnectorShape, _super);\n\n  function ConnectorShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('None')], ConnectorShape.prototype, \"type\", void 0);\n\n  return ConnectorShape;\n}(ChildProperty);\n\nexport { ConnectorShape };\n/**\n * Sets the type of the flow in a BPMN Process\n */\n\nvar ActivityFlow =\n/** @class */\nfunction (_super) {\n  __extends(ActivityFlow, _super);\n\n  function ActivityFlow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('Object')], ActivityFlow.prototype, \"flow\", void 0);\n\n  __decorate([Property(30)], ActivityFlow.prototype, \"exceptionFlowHeight\", void 0);\n\n  return ActivityFlow;\n}(ConnectorShape);\n\nexport { ActivityFlow };\n/**\n * Sets the type of the flow in a BPMN Process\n */\n\nvar BpmnFlow =\n/** @class */\nfunction (_super) {\n  __extends(BpmnFlow, _super);\n\n  function BpmnFlow() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('Sequence')], BpmnFlow.prototype, \"flow\", void 0);\n\n  __decorate([Property('Normal')], BpmnFlow.prototype, \"sequence\", void 0);\n\n  __decorate([Property('Default')], BpmnFlow.prototype, \"message\", void 0);\n\n  __decorate([Property('Default')], BpmnFlow.prototype, \"association\", void 0);\n\n  return BpmnFlow;\n}(ConnectorShape);\n\nexport { BpmnFlow };\n/**\n * Defines the behavior of connector segments\n */\n\nvar ConnectorSegment =\n/** @class */\nfunction (_super) {\n  __extends(ConnectorSegment, _super); // tslint:disable-next-line:no-any\n\n\n  function ConnectorSegment(parent, propName, defaultValue, isArray) {\n    var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n\n    _this.points = [];\n    return _this;\n  }\n\n  __decorate([Property('Straight')], ConnectorSegment.prototype, \"type\", void 0);\n\n  __decorate([Property(true)], ConnectorSegment.prototype, \"allowDrag\", void 0);\n\n  return ConnectorSegment;\n}(ChildProperty);\n\nexport { ConnectorSegment };\n/**\n * Defines the behavior of straight segments\n */\n\nvar StraightSegment =\n/** @class */\nfunction (_super) {\n  __extends(StraightSegment, _super);\n\n  function StraightSegment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Returns the name of class StraightSegment\n   *\n   * @private\n   */\n\n\n  StraightSegment.prototype.getClassName = function () {\n    return 'StraightSegment';\n  };\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, Point)], StraightSegment.prototype, \"point\", void 0);\n\n  return StraightSegment;\n}(ConnectorSegment);\n\nexport { StraightSegment };\n/**\n * Defines the behavior of bezier segments\n */\n\nvar BezierSegment =\n/** @class */\nfunction (_super) {\n  __extends(BezierSegment, _super);\n\n  function BezierSegment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @private\n   * Returns the name of class BezierSegment\n   */\n\n\n  BezierSegment.prototype.getClassName = function () {\n    return 'BezierSegment';\n  };\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, Point)], BezierSegment.prototype, \"point1\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, Point)], BezierSegment.prototype, \"point2\", void 0);\n\n  __decorate([Complex({\n    angle: 0,\n    distance: 0\n  }, Vector)], BezierSegment.prototype, \"vector1\", void 0);\n\n  __decorate([Complex({\n    angle: 0,\n    distance: 0\n  }, Vector)], BezierSegment.prototype, \"vector2\", void 0);\n\n  return BezierSegment;\n}(StraightSegment);\n\nexport { BezierSegment };\n/**\n * Defines the behavior of orthogonal segments\n */\n\nvar OrthogonalSegment =\n/** @class */\nfunction (_super) {\n  __extends(OrthogonalSegment, _super);\n\n  function OrthogonalSegment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * Returns the module of class OrthogonalSegment\n   *\n   * @private\n   */\n\n\n  OrthogonalSegment.prototype.getClassName = function () {\n    return 'OrthogonalSegment';\n  };\n\n  __decorate([Property(null)], OrthogonalSegment.prototype, \"length\", void 0);\n\n  __decorate([Property(null)], OrthogonalSegment.prototype, \"direction\", void 0);\n\n  return OrthogonalSegment;\n}(ConnectorSegment);\n\nexport { OrthogonalSegment };\n/**\n * Defines the behavior of orthogonal segments\n */\n\nvar DiagramConnectorSegment =\n/** @class */\nfunction (_super) {\n  __extends(DiagramConnectorSegment, _super);\n\n  function DiagramConnectorSegment() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  /**\n   * @private\n   * Returns the module of class OrthogonalSegment\n   */\n\n\n  DiagramConnectorSegment.prototype.getClassName = function () {\n    return 'DiagramConnectorSegment';\n  };\n\n  __decorate([Property('Straight')], DiagramConnectorSegment.prototype, \"type\", void 0);\n\n  __decorate([Property(true)], DiagramConnectorSegment.prototype, \"allowDrag\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, Point)], DiagramConnectorSegment.prototype, \"point\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, Point)], DiagramConnectorSegment.prototype, \"point1\", void 0);\n\n  __decorate([Complex({\n    x: 0,\n    y: 0\n  }, Point)], DiagramConnectorSegment.prototype, \"point2\", void 0);\n\n  __decorate([Complex({\n    angle: 0,\n    distance: 0\n  }, Vector)], DiagramConnectorSegment.prototype, \"vector1\", void 0);\n\n  __decorate([Complex({\n    angle: 0,\n    distance: 0\n  }, Vector)], DiagramConnectorSegment.prototype, \"vector2\", void 0);\n\n  __decorate([Property(null)], DiagramConnectorSegment.prototype, \"length\", void 0);\n\n  __decorate([Property(null)], DiagramConnectorSegment.prototype, \"direction\", void 0);\n\n  return DiagramConnectorSegment;\n}(ChildProperty);\n\nexport { DiagramConnectorSegment };\n/**\n * Get the direction of the control points while the bezier is connected to the node\n */\n\nexport function getDirection(bounds, points, excludeBounds) {\n  var center = bounds.center;\n  var direction;\n  var part = excludeBounds ? 45 : 180 / (2 + 2 / (bounds.height / bounds.width));\n  var fourty5 = part;\n  var one35 = 180 - part;\n  var two25 = one35 + 2 * part;\n  var three15 = 360 - part;\n  var angle = findAngle(points, center);\n\n  if (angle > fourty5 && angle < one35) {\n    return direction = 'top';\n  } else if (angle > one35 && angle < two25) {\n    return direction = 'right';\n  } else if (angle > two25 && angle < three15) {\n    return direction = 'bottom';\n  } else {\n    return direction = 'left';\n  }\n}\nexport function isEmptyVector(element) {\n  if (!element.distance && !element.angle) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * Get the bezier points if control points are not given.\n */\n\nexport function getBezierPoints(sourcePoint, targetPoint, direction) {\n  var distance = 60;\n  var value = {\n    x: 0,\n    y: 0\n  };\n\n  if (!direction) {\n    if (Math.abs(targetPoint.x - sourcePoint.x) > Math.abs(targetPoint.y - sourcePoint.y)) {\n      direction = sourcePoint.x < targetPoint.x ? 'right' : 'left';\n    } else {\n      direction = sourcePoint.y < targetPoint.y ? 'bottom' : 'top';\n    }\n  }\n\n  switch (direction) {\n    case 'bottom':\n    case 'top':\n      distance = Math.min(Math.abs(sourcePoint.y - targetPoint.y) * 0.45, distance);\n      value = {\n        x: sourcePoint.x,\n        y: sourcePoint.y + (direction === 'bottom' ? distance : -distance)\n      };\n      break;\n\n    case 'right':\n    case 'left':\n      distance = Math.min(Math.abs(sourcePoint.x - targetPoint.x) * 0.45, distance);\n      value = {\n        x: sourcePoint.x + (direction === 'right' ? distance : -distance),\n        y: sourcePoint.y\n      };\n      break;\n  }\n\n  return value;\n}\n/**\n * Get the bezier curve bounds.\n */\n\nexport function getBezierBounds(startPoint, controlPoint1, controlPoint2, endPoint, connector) {\n  var minx = 0;\n  var miny = 0;\n  var maxx = 0;\n  var maxy = 0;\n  var tolerancevalue = 3;\n  var max = Number((connector.distance(controlPoint1, startPoint) + connector.distance(controlPoint2, controlPoint1) + connector.distance(endPoint, controlPoint2)) / tolerancevalue);\n\n  if (max !== 0) {\n    for (var i = 0; i <= max; i++) {\n      var t = i / max;\n      var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x + 3 * t * (1 - t) * (1 - t) * controlPoint1.x + 3 * t * t * (1 - t) * controlPoint2.x + t * t * t * endPoint.x;\n      var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y + 3 * t * (1 - t) * (1 - t) * controlPoint1.y + 3 * t * t * (1 - t) * controlPoint2.y + t * t * t * endPoint.y;\n\n      if (i === 0) {\n        minx = maxx = x;\n        miny = maxy = y;\n      } else {\n        minx = Math.min(x, minx);\n        miny = Math.min(y, miny);\n        maxx = Math.max(x, maxx);\n        maxy = Math.max(y, maxy);\n      }\n    }\n  }\n\n  return {\n    x: minx,\n    y: miny,\n    width: maxx - minx,\n    height: maxy - miny,\n    left: minx,\n    top: miny,\n    right: minx + (maxx - minx),\n    bottom: miny + (maxy - miny),\n    center: {\n      x: (minx + (maxx - minx)) / 2,\n      y: (miny + (maxy - miny)) / 2\n    }\n  };\n}\n/**\n * Get the intermediate bezier curve for point over connector\n */\n\nexport function bezierPoints(connector, startPoint, point1, point2, endPoint, i, max) {\n  var pt = {\n    x: 0,\n    y: 0\n  };\n  var t = i / max;\n  var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x + 3 * t * (1 - t) * (1 - t) * point1.x + 3 * t * t * (1 - t) * point2.x + t * t * t * endPoint.x;\n  pt.x = x;\n  var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y + 3 * t * (1 - t) * (1 - t) * point1.y + 3 * t * t * (1 - t) * point2.y + t * t * t * endPoint.y;\n  pt.y = y;\n  return pt;\n}\n/**\n * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults\n */\n\nvar MultiplicityLabel =\n/** @class */\nfunction (_super) {\n  __extends(MultiplicityLabel, _super);\n\n  function MultiplicityLabel() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property(true)], MultiplicityLabel.prototype, \"optional\", void 0);\n\n  __decorate([Property(undefined)], MultiplicityLabel.prototype, \"lowerBounds\", void 0);\n\n  __decorate([Property(undefined)], MultiplicityLabel.prototype, \"upperBounds\", void 0);\n\n  return MultiplicityLabel;\n}(ChildProperty);\n\nexport { MultiplicityLabel };\n/**\n * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults\n */\n\nvar ClassifierMultiplicity =\n/** @class */\nfunction (_super) {\n  __extends(ClassifierMultiplicity, _super);\n\n  function ClassifierMultiplicity() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('OneToOne')], ClassifierMultiplicity.prototype, \"type\", void 0);\n\n  __decorate([Complex({}, MultiplicityLabel)], ClassifierMultiplicity.prototype, \"target\", void 0);\n\n  __decorate([Complex({}, MultiplicityLabel)], ClassifierMultiplicity.prototype, \"source\", void 0);\n\n  return ClassifierMultiplicity;\n}(ChildProperty);\n\nexport { ClassifierMultiplicity };\n/**\n * Defines the behavior of the UMLActivity shape\n */\n\nvar RelationShip =\n/** @class */\nfunction (_super) {\n  __extends(RelationShip, _super);\n\n  function RelationShip() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('UmlClassifier')], RelationShip.prototype, \"type\", void 0);\n\n  __decorate([Property('Aggregation')], RelationShip.prototype, \"relationship\", void 0);\n\n  __decorate([Property('Directional')], RelationShip.prototype, \"associationType\", void 0);\n\n  __decorate([Complex({}, ClassifierMultiplicity)], RelationShip.prototype, \"multiplicity\", void 0);\n\n  return RelationShip;\n}(ConnectorShape);\n\nexport { RelationShip };\n/**\n * Connector shape for blazor\n */\n\nvar DiagramConnectorShape =\n/** @class */\nfunction (_super) {\n  __extends(DiagramConnectorShape, _super);\n\n  function DiagramConnectorShape() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n\n  __decorate([Property('None')], DiagramConnectorShape.prototype, \"type\", void 0);\n\n  __decorate([Property('Directional')], DiagramConnectorShape.prototype, \"associationType\", void 0);\n\n  __decorate([Property('Aggregation')], DiagramConnectorShape.prototype, \"relationship\", void 0);\n\n  __decorate([Complex({}, ClassifierMultiplicity)], DiagramConnectorShape.prototype, \"multiplicity\", void 0);\n\n  __decorate([Property('Sequence')], DiagramConnectorShape.prototype, \"bpmnFlow\", void 0);\n\n  __decorate([Property('Default')], DiagramConnectorShape.prototype, \"message\", void 0);\n\n  __decorate([Property('Normal')], DiagramConnectorShape.prototype, \"sequence\", void 0);\n\n  __decorate([Property('Default')], DiagramConnectorShape.prototype, \"association\", void 0);\n\n  __decorate([Property('Object')], DiagramConnectorShape.prototype, \"umlActivityFlow\", void 0);\n\n  __decorate([Property(30)], DiagramConnectorShape.prototype, \"exceptionFlowHeight\", void 0);\n\n  return DiagramConnectorShape;\n}(ChildProperty);\n\nexport { DiagramConnectorShape };\n/**\n * Connectors are used to create links between nodes\n */\n\nvar Connector =\n/** @class */\nfunction (_super) {\n  __extends(Connector, _super); // tslint:disable-next-line:no-any\n\n\n  function Connector(parent, propName, defaultValue, isArray) {\n    var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n    /** @private */\n\n\n    _this.parentId = '';\n    /** @private */\n\n    _this.bridges = [];\n    /** @private */\n\n    _this.status = 'None';\n\n    if (_this.shape && _this.shape.type === 'UmlActivity') {\n      setUMLActivityDefaults(defaultValue, _this);\n    }\n\n    if (defaultValue && defaultValue.shape && defaultValue.shape.type !== 'None') {\n      setConnectorDefaults(defaultValue, _this);\n    }\n\n    return _this;\n  }\n  /* tslint:disable */\n\n\n  Connector.prototype.setPortID = function (diagram, isTarget) {\n    if (this.targetID && this.sourceID) {\n      var targetNode = diagram.nameTable[this.targetID];\n      var sourceNode = diagram.nameTable[this.sourceID];\n      var ports = isTarget ? targetNode && targetNode.ports : sourceNode && sourceNode.ports;\n      var port = void 0;\n\n      for (var i = 0; ports && i < ports.length; i++) {\n        port = ports[i];\n\n        if (this.targetPortID === port.id && isTarget) {\n          if (port.constraints & PortConstraints.None || !(port.constraints & PortConstraints.InConnect)) {\n            this.targetPortID = '';\n          }\n        } else if (this.sourcePortID === port.id && !isTarget) {\n          if (port.constraints & PortConstraints.None || !(port.constraints & PortConstraints.OutConnect)) {\n            this.sourcePortID = '';\n          }\n        }\n      }\n    }\n  };\n  /* tslint:enable */\n\n  /** @private */\n  // tslint:disable-next-line:no-any\n\n\n  Connector.prototype.init = function (diagram) {\n    if (!this.id) {\n      this.id = randomId();\n    }\n\n    if (this.sourcePortID) {\n      this.setPortID(diagram);\n    }\n\n    if (this.targetPortID) {\n      this.setPortID(diagram, true);\n    }\n\n    var bpmnElement;\n    var container = new Canvas();\n    var segment = new PathElement();\n    segment.id = this.id + '_path';\n    var srcDecorator = new PathElement();\n    var targetDecorator = new PathElement();\n    segment = this.getSegmentElement(this, segment); //let bounds: Rect;\n\n    var points = [];\n    points = this.getConnectorPoints(this.type);\n    points = this.clipDecorators(this, points);\n    var bounds = Rect.toBounds(points);\n    container.width = bounds.width;\n    container.height = bounds.height;\n    container.offsetX = bounds.x + container.pivot.x * bounds.width;\n    container.offsetY = bounds.y + container.pivot.y * bounds.height;\n\n    switch (this.shape.type) {\n      case 'Bpmn':\n        // eslint-disable-next-line no-case-declarations\n        var flow = isBlazor() ? this.shape.bpmnFlow : this.shape.flow;\n\n        switch (flow) {\n          case 'Sequence':\n            bpmnElement = this.getBpmnSequenceFlow();\n            break;\n\n          case 'Association':\n            bpmnElement = new PathElement();\n            bpmnElement.visible = false;\n            this.getBpmnAssociationFlow();\n            break;\n\n          case 'Message':\n            bpmnElement = this.getBpmnMessageFlow();\n            segment = this.getSegmentElement(this, segment);\n            this.updateShapePosition(this, bpmnElement);\n            break;\n        }\n\n        break;\n\n      case 'UmlActivity':\n        // eslint-disable-next-line no-case-declarations\n        var activityFlow = isBlazor() ? this.shape.umlActivityFlow : this.shape.flow;\n\n        switch (activityFlow) {\n          case 'Object':\n            this.getUMLObjectFlow();\n            break;\n\n          case 'Exception':\n            this.getUMLExceptionFlow(segment);\n            break;\n        }\n\n        break;\n\n      case 'UmlClassifier':\n        this.getConnectorRelation();\n        break;\n    }\n\n    var anglePoints = this.intermediatePoints;\n\n    if (this.type === 'Bezier') {\n      var firstSegment = this.segments[0];\n      var lastSegment = this.segments[this.segments.length - 1];\n      anglePoints = [!Point.isEmptyPoint(lastSegment.point2) ? lastSegment.point2 : lastSegment.bezierPoint2, !Point.isEmptyPoint(firstSegment.point1) ? firstSegment.point1 : firstSegment.bezierPoint1];\n    }\n\n    var accessContent = 'getDescription';\n    var getDescription = diagram[accessContent]; //const strokeWidth: number = this.sourceWrapper ? this.sourceWrapper.style.strokeWidth / 2 / 2 : 0;\n\n    srcDecorator = this.getDecoratorElement(points[0], anglePoints[1], this.sourceDecorator, true, getDescription);\n    targetDecorator = this.getDecoratorElement(points[points.length - 1], anglePoints[anglePoints.length - 2], this.targetDecorator, false, getDescription);\n    srcDecorator.id = this.id + '_srcDec';\n    targetDecorator.id = this.id + '_tarDec';\n    segment.style = this.style;\n    /* tslint:disable:no-string-literal */\n\n    segment.style['fill'] = 'transparent';\n\n    if (getDescription !== undefined) {\n      // tslint:disable-next-line:no-any\n      var wrapperContent = getDescription(this, diagram);\n      segment.description = wrapperContent ? wrapperContent : this.id;\n    }\n\n    container.style.strokeColor = 'transparent';\n    container.style.fill = 'transparent';\n    container.style.strokeWidth = 0;\n    container.children = [segment, srcDecorator, targetDecorator];\n    container.id = this.id;\n\n    if (bpmnElement !== undefined) {\n      container.children.push(bpmnElement);\n    }\n\n    container.offsetX = segment.offsetX;\n    container.offsetY = segment.offsetY;\n    container.width = segment.width;\n    container.height = segment.height;\n\n    for (var i = 0; this.annotations !== undefined, i < this.annotations.length; i++) {\n      container.children.push(this.getAnnotationElement(this.annotations[i], this.intermediatePoints, bounds, getDescription, diagram.element.id, diagram.annotationTemplate));\n    }\n\n    for (var i = 0; this.fixedUserHandles !== undefined, i < this.fixedUserHandles.length; i++) {\n      container.children.push(this.getfixedUserHandle(this.fixedUserHandles[i], this.intermediatePoints, bounds));\n    }\n\n    this.wrapper = container;\n    return container;\n  };\n\n  Connector.prototype.getConnectorRelation = function () {\n    var shape = this.shape;\n\n    if (shape.relationship === 'Association') {\n      this.segments[0].type = 'Straight';\n      this.sourceDecorator.shape = 'None';\n      this.targetDecorator.shape = 'Arrow';\n    } else if (shape.relationship === 'Inheritance') {\n      this.segments[0].type = 'Orthogonal';\n      this.sourceDecorator.shape = 'None';\n      this.targetDecorator.shape = 'Arrow';\n    } else if (shape.relationship === 'Composition') {\n      this.segments[0].type = 'Orthogonal';\n      this.sourceDecorator.shape = 'Diamond';\n      this.targetDecorator.shape = 'None';\n    } else if (shape.relationship === 'Aggregation') {\n      this.segments[0].type = 'Orthogonal';\n      this.sourceDecorator.shape = 'Diamond';\n      this.targetDecorator.shape = 'None';\n    } else if (shape.relationship === 'Dependency') {\n      this.segments[0].type = 'Orthogonal';\n      this.sourceDecorator.shape = 'None';\n      this.targetDecorator.shape = 'OpenArrow';\n    } else if (shape.relationship === 'Realization') {\n      this.segments[0].type = 'Orthogonal';\n      this.sourceDecorator.shape = 'None';\n      this.targetDecorator.shape = 'Arrow';\n    }\n\n    if (shape.associationType === 'BiDirectional') {\n      this.sourceDecorator.shape = 'None';\n      this.targetDecorator.shape = 'None';\n    }\n\n    var text1 = ''; //let lower: MultiplicityLabelModel;\n    //let upper: MultiplicityLabelModel;\n\n    var sourceText = '';\n    var targetText = '';\n    var text = '';\n\n    if (shape.multiplicity.source) {\n      shape.multiplicity.source.lowerBounds = shape.multiplicity.source.lowerBounds;\n      shape.multiplicity.source.upperBounds = shape.multiplicity.source.upperBounds;\n    }\n\n    if (shape.multiplicity.target) {\n      shape.multiplicity.target.lowerBounds = shape.multiplicity.target.lowerBounds;\n      shape.multiplicity.target.upperBounds = shape.multiplicity.target.upperBounds;\n    }\n\n    var lower = shape.multiplicity.source;\n    var upper = shape.multiplicity.target;\n    text = lower.upperBounds ? lower.lowerBounds + '...' + lower.upperBounds : lower.lowerBounds;\n    text1 = upper.upperBounds ? upper.lowerBounds + '...' + upper.upperBounds : upper.lowerBounds;\n\n    if (shape.multiplicity.type === 'ManyToOne') {\n      shape.multiplicity.target.optional = false;\n      sourceText = text ? text : '*';\n      targetText = '1';\n    }\n\n    if (shape.multiplicity.type === 'OneToMany') {\n      shape.multiplicity.source.optional = false;\n      targetText = text1 ? text1 : '*';\n      sourceText = '1';\n    }\n\n    if (shape.multiplicity.type === 'ManyToOne') {\n      sourceText = text ? text : '*';\n      targetText = text1 ? text1 : '*';\n    }\n\n    if (shape.multiplicity.type === 'OneToOne') {\n      shape.multiplicity.target.optional = false;\n      shape.multiplicity.source.optional = false;\n      sourceText = '1';\n      targetText = '1';\n    }\n\n    this.annotations = [{\n      id: this.id + 'sourcelabel',\n      content: sourceText,\n      offset: 0,\n      alignment: 'Before',\n      margin: {\n        right: 5,\n        bottom: 5\n      }\n    }, {\n      id: this.id + 'targetlabel',\n      content: targetText,\n      offset: 1,\n      alignment: 'Before',\n      margin: {\n        right: 5,\n        bottom: 5\n      }\n    }];\n  };\n\n  Connector.prototype.getBpmnSequenceFlow = function () {\n    var segment = new PathElement();\n    var pathseq = new PathElement();\n    var pathseqData;\n\n    if (this.shape.sequence === 'Normal' && this.type !== 'Bezier') {\n      this.targetDecorator.shape = 'Arrow';\n    }\n\n    if (this.shape.sequence === 'Default') {\n      segment = this.getSegmentElement(this, segment);\n      var anglePoints = this.intermediatePoints;\n      pathseq = updatePathElement(anglePoints, this);\n      this.targetDecorator.shape = 'Arrow';\n    }\n\n    if (this.shape.sequence === 'Conditional') {\n      this.targetDecorator.shape = 'Arrow';\n      this.sourceDecorator.shape = 'Diamond';\n      pathseq.id = this.id + this.shape.type;\n    }\n\n    return pathseq;\n  };\n  /** @private */\n\n\n  Connector.prototype.getUMLObjectFlow = function () {\n    if (this.annotations) {\n      for (var i = 0; i < this.annotations.length; i++) {\n        this.annotations[i].content = '[' + this.annotations[i].content + ']';\n      }\n    }\n  };\n  /** @private */\n\n\n  Connector.prototype.getUMLExceptionFlow = function (segment) {\n    this.type = 'Straight';\n    var height = this.shape.exceptionFlowHeight / 2;\n    var midPt = {\n      x: (this.targetPoint.x + this.sourcePoint.x) / 2,\n      y: (this.targetPoint.y + this.sourcePoint.y) / 2\n    };\n    var xDist = midPt.x - this.sourcePoint.x;\n    var yDist = midPt.y - this.sourcePoint.y;\n    var dist = Math.sqrt(xDist * xDist + yDist * yDist);\n    var fractionOfTotal = height / dist;\n    var midPt2 = {\n      x: midPt.x - xDist * fractionOfTotal,\n      y: midPt.y - yDist * fractionOfTotal\n    };\n    var midPt1 = {\n      x: midPt.x + xDist * fractionOfTotal,\n      y: midPt.y + yDist * fractionOfTotal\n    };\n    var matrix = identityMatrix();\n    rotateMatrix(matrix, 315, midPt.x, midPt.y);\n    this.segments = [];\n    var segments = new StraightSegment(this, 'segments', {\n      type: 'Straight',\n      point: transformPointByMatrix(matrix, midPt1)\n    }, true);\n    this.segments.push(segments);\n    segments = new StraightSegment(this, 'segments', {\n      type: 'Straight',\n      point: transformPointByMatrix(matrix, midPt2)\n    }, true);\n    this.segments.push(segments);\n    segment = this.getSegmentElement(this, segment);\n  };\n\n  Connector.prototype.getBpmnAssociationFlow = function () {\n    if (this.shape.association === 'Default') {\n      this.targetDecorator.shape = 'Arrow';\n    }\n\n    if (this.shape.association === 'Directional') {\n      this.targetDecorator.shape = 'Arrow';\n    }\n\n    if (this.shape.association === 'BiDirectional') {\n      this.targetDecorator.shape = 'Arrow';\n      this.sourceDecorator.shape = 'Arrow';\n    }\n  };\n  /** @private */\n\n\n  Connector.prototype.getfixedUserHandle = function (fixedUserHandle, points, bounds) {\n    var fixedUserHandleContainer = new Canvas();\n    fixedUserHandleContainer.float = true;\n    var children = [];\n    fixedUserHandle.id = fixedUserHandle.id || randomId();\n    fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;\n    fixedUserHandleContainer.children = children;\n    fixedUserHandleContainer.visible = fixedUserHandle.visibility;\n    fixedUserHandleContainer.width = fixedUserHandle.width;\n    fixedUserHandleContainer.height = fixedUserHandle.height;\n    fixedUserHandleContainer.style.strokeWidth = fixedUserHandle.handleStrokeWidth;\n    fixedUserHandleContainer.style.fill = fixedUserHandle.fill;\n    fixedUserHandleContainer.style.strokeColor = fixedUserHandle.handleStrokeColor;\n    fixedUserHandleContainer.cornerRadius = fixedUserHandle.cornerRadius;\n    this.updateAnnotation(fixedUserHandle, points, bounds, fixedUserHandleContainer);\n    var symbolIcon = initfixedUserHandlesSymbol(fixedUserHandle, fixedUserHandleContainer);\n    fixedUserHandleContainer.children.push(symbolIcon);\n    fixedUserHandleContainer.description = fixedUserHandleContainer.id;\n    return fixedUserHandleContainer;\n  };\n\n  Connector.prototype.getBpmnMessageFlow = function () {\n    var segmentMessage = new PathElement();\n    this.targetDecorator.shape = 'Arrow';\n    this.targetDecorator.width = 5;\n    this.targetDecorator.height = 10;\n    this.sourceDecorator.shape = 'Circle';\n\n    if (this.shape.message === 'InitiatingMessage' || this.shape.message === 'NonInitiatingMessage') {\n      segmentMessage.id = this.id + '_' + this.shape.message;\n      segmentMessage.width = 25;\n      segmentMessage.height = 15;\n      segmentMessage.data = 'M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0';\n      segmentMessage.horizontalAlignment = 'Center';\n      segmentMessage.verticalAlignment = 'Center';\n      segmentMessage.transform = Transform.Self;\n      segmentMessage.style.fill = this.shape.message === 'NonInitiatingMessage' ? 'lightgrey' : 'white';\n    }\n\n    return segmentMessage;\n  };\n  /** @private */\n\n\n  Connector.prototype.distance = function (pt1, pt2) {\n    return findDistance(pt1, pt2);\n  };\n  /**   @private  */\n\n\n  Connector.prototype.findPath = function (sourcePt, targetPt) {\n    return findPath(sourcePt, targetPt);\n  };\n  /** @private */\n\n\n  Connector.prototype.getAnnotationElement = function (annotation, points, bounds, getDescription, diagramId, annotationTemplate) {\n    annotation.id = annotation.id || randomId();\n    var textele;\n\n    if (isBlazor() && annotation.annotationType === 'Template') {\n      annotation.template = annotation.template ? annotation.template : '';\n    }\n\n    if (diagramId && (annotation.template || annotation.annotationType === 'Template' || annotationTemplate && annotation.content === '')) {\n      textele = new DiagramHtmlElement(this.id, diagramId, annotation.id, annotationTemplate);\n      textele = getTemplateContent(textele, annotation, annotationTemplate);\n    } else {\n      textele = new TextElement();\n      textele.content = annotation.content;\n      textele.style.textOverflow = 'Wrap';\n    }\n\n    textele.constraints = annotation.constraints;\n    textele.visible = annotation.visibility;\n    textele.rotateAngle = annotation.rotateAngle;\n    textele.horizontalAlignment = annotation.horizontalAlignment;\n    textele.verticalAlignment = annotation.verticalAlignment;\n    textele.width = annotation.width;\n    textele.height = annotation.height;\n\n    if (bounds.width !== undefined && !annotation.template) {\n      textele.width = (annotation.width || bounds.width) - annotation.margin.left - annotation.margin.right;\n    }\n\n    textele.margin = annotation.margin;\n    textele.id = this.id + '_' + annotation.id;\n\n    if (bounds.width === 0) {\n      bounds.width = this.style.strokeWidth;\n    }\n\n    if (bounds.height === 0) {\n      bounds.height = this.style.strokeWidth;\n    }\n\n    textele.style = annotation.style; // tslint:disable-next-line:no-any\n\n    var wrapperContent;\n    var description = getFunction(getDescription);\n\n    if (description) {\n      wrapperContent = description(annotation, this);\n    }\n\n    textele.description = wrapperContent ? wrapperContent : textele.id;\n    this.updateAnnotation(annotation, points, bounds, textele);\n    return textele;\n  };\n  /** @private */\n\n\n  Connector.prototype.updateAnnotation = function (annotation, points, bounds, textElement, canRefresh) {\n    //let getPointloop: SegmentInfo;\n    //let align: Alignment; let hAlign: string;\n    var pivotPoint = {\n      x: 0,\n      y: 0\n    };\n\n    if (!(textElement instanceof DiagramHtmlElement || DiagramElement) && !canRefresh) {\n      textElement.refreshTextElement();\n    }\n\n    textElement.width = annotation.width || bounds.width;\n    var getPointloop = getAnnotationPosition(points, annotation, bounds);\n    var newPoint = getPointloop.point;\n\n    if (annotation instanceof PathAnnotation && annotation.segmentAngle) {\n      textElement.rotateAngle = annotation.rotateAngle + getPointloop.angle;\n      textElement.rotateAngle = (textElement.rotateAngle + 360) % 360;\n    }\n\n    if (bounds.width === 0) {\n      bounds.width = this.style.strokeWidth;\n    }\n\n    if (bounds.height === 0) {\n      bounds.height = this.style.strokeWidth;\n    }\n\n    var offsetPoint = {\n      x: (newPoint.x - bounds.x) / bounds.width,\n      y: (newPoint.y - bounds.y) / bounds.height\n    };\n    pivotPoint.x = bounds.width * offsetPoint.x;\n    pivotPoint.y = bounds.height * offsetPoint.y;\n    var align = alignLabelOnSegments(annotation, getPointloop.angle, points);\n    var hAlign = align.hAlign;\n    var vAlign = align.vAlign;\n    var horizor;\n    var verzor;\n\n    if (hAlign === 'left') {\n      horizor = 'Left';\n      pivotPoint.x += annotation.displacement.x;\n    } else if (hAlign === 'right') {\n      horizor = 'Right';\n      pivotPoint.x -= annotation.displacement.x;\n    } else if (hAlign === 'center') {\n      horizor = 'Center';\n    }\n\n    if (vAlign === 'top') {\n      verzor = 'Top';\n      pivotPoint.y += annotation.displacement.y;\n    } else if (vAlign === 'bottom') {\n      verzor = 'Bottom';\n      pivotPoint.y -= annotation.displacement.y;\n    } else if (vAlign === 'center') {\n      verzor = 'Center';\n    }\n\n    textElement.horizontalAlignment = horizor;\n    textElement.verticalAlignment = verzor;\n    textElement.setOffsetWithRespectToBounds(pivotPoint.x, pivotPoint.y, 'Absolute');\n    textElement.relativeMode = 'Point';\n  };\n  /** @private */\n\n\n  Connector.prototype.getConnectorPoints = function (type, points, layoutOrientation, lineDistribution) {\n    //const width: number = Math.abs(this.sourcePoint.x - this.targetPoint.x);\n    //const height: number = Math.abs(this.sourcePoint.y - this.targetPoint.y);\n    points = findConnectorPoints(this, layoutOrientation, lineDistribution);\n    var newPoints = points.slice(0);\n\n    if (newPoints && newPoints.length > 0) {\n      this.sourcePoint = newPoints[0];\n      this.targetPoint = newPoints[newPoints.length - 1];\n    }\n\n    return newPoints;\n  };\n  /** @private */\n\n\n  Connector.prototype.clipDecorator = function (connector, points, isSource, diagramAction) {\n    var point = {\n      x: 0,\n      y: 0\n    };\n    var start = {\n      x: 0,\n      y: 0\n    };\n    var end = {\n      x: 0,\n      y: 0\n    };\n    var length = points.length;\n    start = !isSource ? points[length - 1] : points[0];\n    end = !isSource ? points[length - 2] : points[1];\n    var len = Point.distancePoints(start, end);\n    len = len === 0 ? 1 : len;\n    var strokeWidth = 1;\n    var node = isSource ? connector.sourceWrapper : connector.targetWrapper;\n\n    if (node) {\n      strokeWidth = node.style.strokeWidth;\n\n      if (diagramAction && diagramAction & DiagramAction.DecoratorPropertyChange) {\n        strokeWidth = 1;\n      }\n    }\n\n    var width = strokeWidth - 1;\n    point.x = Math.round(start.x + width * (end.x - start.x) / len);\n    point.y = Math.round(start.y + width * (end.y - start.y) / len);\n\n    if (isSource && connector.sourceDecorator.shape !== 'None' || !isSource && connector.targetDecorator.shape !== 'None') {\n      point = Point.adjustPoint(point, end, true, diagramAction & DiagramAction.DecoratorPropertyChange ? 0 : strokeWidth / 2);\n    }\n\n    return point;\n  };\n  /** @private */\n\n\n  Connector.prototype.clipDecorators = function (connector, pts, diagramAction) {\n    if (connector.sourceDecorator.shape !== 'None') {\n      pts[0] = this.clipDecorator(connector, pts, true, diagramAction);\n    }\n\n    if (connector.targetDecorator.shape !== 'None') {\n      pts[pts.length - 1] = this.clipDecorator(connector, pts, false, diagramAction);\n    }\n\n    return pts;\n  };\n  /** @private */\n\n\n  Connector.prototype.updateSegmentElement = function (connector, points, element, diagramActions) {\n    var bounds = new Rect(); //let point: PointModel[];\n\n    var segmentPath = this.getSegmentPath(connector, points, diagramActions);\n\n    if (connector.type === 'Bezier') {\n      if (this.segments.length > 0) {\n        for (var i = 0; i < this.segments.length; i++) {\n          var segment = this.segments[i];\n          var connectorSegment = connector.segments[i]; // eslint-disable-next-line max-len\n\n          var point1 = !Point.isEmptyPoint(segment.point1) ? connectorSegment.point1 : connectorSegment.bezierPoint1; // eslint-disable-next-line max-len\n\n          var point2 = !Point.isEmptyPoint(segment.point2) ? connectorSegment.point2 : connectorSegment.bezierPoint2;\n          bounds.uniteRect(getBezierBounds(segment.points[0], point1, point2, segment.points[1], connector));\n        }\n      }\n    } else {\n      bounds = Rect.toBounds(points);\n    }\n\n    element.width = bounds.width;\n    element.height = bounds.height;\n    element.offsetX = bounds.x + element.width / 2;\n    element.offsetY = bounds.y + element.height / 2;\n    element.data = segmentPath;\n\n    if (connector.wrapper) {\n      connector.wrapper.offsetX = element.offsetX;\n      connector.wrapper.offsetY = element.offsetY;\n      connector.wrapper.width = bounds.width;\n      connector.wrapper.height = bounds.height;\n    }\n\n    return element;\n  };\n  /** @private */\n\n\n  Connector.prototype.getSegmentElement = function (connector, segmentElement, layoutOrientation, diagramActions) {\n    //let bounds: Rect; let segmentPath: string;\n    var points = [];\n    flipConnector(connector);\n    points = this.getConnectorPoints(connector.type, undefined, layoutOrientation);\n    this.intermediatePoints = points;\n    segmentElement.staticSize = true;\n    segmentElement = this.updateSegmentElement(connector, points, segmentElement, diagramActions);\n    return segmentElement;\n  };\n  /** @private */\n\n\n  Connector.prototype.getDecoratorElement = function (offsetPoint, adjacentPoint, decorator, isSource, getDescription) {\n    var decEle = new PathElement();\n    var getPath;\n    var angle;\n    decEle.transform = Transform.Self;\n    this.updateDecoratorElement(decEle, offsetPoint, adjacentPoint, decorator);\n\n    if (getDescription !== undefined) {\n      // tslint:disable-next-line:no-any\n      var wrapperContent = getDescription(decorator, this);\n      decEle.description = wrapperContent ? wrapperContent : 'Specifies the ' + isSource ? 'source' : 'target' + 'port element of the connector';\n    }\n\n    return decEle;\n  };\n\n  Connector.prototype.bridgePath = function (connector, path, pointIndex) {\n    var pathData = path;\n\n    if (connector.bridges.length > 0) {\n      if (connector.type === 'Straight' && connector.segments.length < 2) {\n        for (var n = 0; n < connector.bridges.length; n++) {\n          var bridge = connector.bridges[n];\n\n          if (!bridge.rendered) {\n            pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;\n            pathData += bridge.path;\n            bridge.rendered = true;\n          }\n        }\n      } else if (connector.type === 'Orthogonal' || connector.type === 'Straight' && connector.segments.length > 1) {\n        for (var n = 0; n < connector.bridges.length; n++) {\n          var bridge = connector.bridges[n];\n\n          if (bridge.segmentPointIndex === pointIndex) {\n            if (!bridge.rendered) {\n              if (bridge.segmentPointIndex === pointIndex) {\n                pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;\n                pathData += bridge.path;\n                bridge.rendered = true;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return pathData;\n  };\n  /** @private */\n\n\n  Connector.prototype.updateDecoratorElement = function (element, pt, adjacentPoint, decorator) {\n    //let getPath: string;// let angle: number;\n    element.offsetX = pt.x;\n    element.offsetY = pt.y;\n    var angle = Point.findAngle(pt, adjacentPoint);\n    var getPath = getDecoratorShape(decorator.shape, decorator);\n    var size = new Size(decorator.width, decorator.height);\n    element.pivot.x = decorator.pivot.x;\n    element.pivot.y = decorator.pivot.y;\n    element.style = decorator.style;\n    element.rotateAngle = angle;\n    element.data = getPath;\n    element.canMeasurePath = true;\n    element.width = size.width;\n    element.height = size.height;\n  };\n  /** @private */\n\n\n  Connector.prototype.getSegmentPath = function (connector, points, diagramAction) {\n    var path = '';\n    var getPt;\n    var end;\n    var st;\n    var pts = [];\n    var j = 0;\n\n    while (j < points.length) {\n      pts.push({\n        x: points[j].x,\n        y: points[j].y\n      });\n      j++;\n    }\n\n    for (var m = 0; m < connector.bridges.length; m++) {\n      var bridge = connector.bridges[m];\n      bridge.rendered = false;\n    }\n\n    pts = this.clipDecorators(connector, pts, diagramAction);\n\n    if (this.cornerRadius > 0 && this.type !== 'Bezier') {\n      for (var j_1 = 0; j_1 < pts.length - 1; j_1++) {\n        getPt = pts[j_1];\n\n        if (j_1 === 0) {\n          path = 'M' + getPt.x + ' ' + getPt.y;\n        }\n\n        var segLength = Point.distancePoints(pts[j_1], pts[j_1 + 1]);\n\n        if (segLength > 0) {\n          if (j_1 < pts.length - 2) {\n            if (segLength < this.cornerRadius * 2) {\n              end = Point.adjustPoint(pts[j_1], pts[j_1 + 1], false, segLength / 2);\n            } else {\n              end = Point.adjustPoint(pts[j_1], pts[j_1 + 1], false, this.cornerRadius);\n            }\n          } else {\n            end = pts[j_1 + 1];\n          }\n\n          if (j_1 > 0) {\n            if (segLength < this.cornerRadius * 2) {\n              st = Point.adjustPoint(pts[j_1], pts[j_1 + 1], true, segLength / 2);\n\n              if (j_1 < pts.length - 2) {\n                end = null;\n              }\n            } else {\n              st = Point.adjustPoint(pts[j_1], pts[j_1 + 1], true, this.cornerRadius);\n            }\n          }\n\n          if (st) {\n            path += 'Q' + getPt.x + ' ' + getPt.y + ' ' + st.x + ' ' + st.y;\n          }\n\n          if (end) {\n            if (connector.bridges.length > 0) {\n              path = this.bridgePath(connector, path, j_1);\n\n              if (connector.type === 'Orthogonal') {\n                path = this.bridgePath(connector, path, j_1 + 1);\n              }\n            }\n\n            path += ' L' + end.x + ' ' + end.y;\n          }\n        }\n      }\n    } else {\n      if (this.type === 'Bezier') {\n        var direction = void 0;\n        var segments = this.segments;\n\n        for (var j_2 = 0; j_2 < segments.length; j_2++) {\n          if (pts.length > 2) {\n            segments[j_2].bezierPoint1 = {\n              x: 0,\n              y: 0\n            };\n            segments[j_2].bezierPoint2 = {\n              x: 0,\n              y: 0\n            };\n          }\n\n          if (Point.isEmptyPoint(segments[j_2].point1) && !segments[j_2].vector1.angle && !segments[j_2].vector1.distance) {\n            if ((connector.sourceID || this.sourcePortID) && this.sourceWrapper) {\n              direction = getDirection(this.sourceWrapper.bounds, pts[j_2], true);\n            }\n\n            segments[j_2].bezierPoint1 = getBezierPoints(pts[j_2], pts[j_2 + 1], direction);\n          } else if (segments[j_2].vector1.angle || segments[j_2].vector1.distance) {\n            segments[j_2].bezierPoint1 = Point.transform(pts[j_2], segments[j_2].vector1.angle, segments[j_2].vector1.distance);\n          } else {\n            segments[j_2].bezierPoint1 = {\n              x: segments[j_2].point1.x || segments[j_2].bezierPoint1.x,\n              y: segments[j_2].point1.y || segments[j_2].bezierPoint1.y\n            };\n          }\n\n          if (Point.isEmptyPoint(segments[j_2].point2) && !segments[j_2].vector2.angle && !segments[j_2].vector2.distance) {\n            if ((connector.targetID || this.targetPortID) && this.targetWrapper) {\n              direction = getDirection(this.targetWrapper.bounds, pts[j_2 + 1], true);\n            }\n\n            segments[j_2].bezierPoint2 = getBezierPoints(pts[j_2 + 1], pts[j_2], direction);\n          } else if (segments[j_2].vector2.angle || segments[j_2].vector2.distance) {\n            segments[j_2].bezierPoint2 = Point.transform(pts[j_2 + 1], segments[j_2].vector2.angle, segments[j_2].vector2.distance);\n          } else {\n            segments[j_2].bezierPoint2 = {\n              x: segments[j_2].point2.x || segments[j_2].bezierPoint2.x,\n              y: segments[j_2].point2.y || segments[j_2].bezierPoint2.y\n            };\n          }\n        }\n\n        pts.splice(1, 0, {\n          x: segments[0].bezierPoint1.x,\n          y: segments[0].bezierPoint1.y\n        });\n        pts.splice(pts.length - 1, 0, {\n          x: segments[segments.length - 1].bezierPoint2.x,\n          y: segments[segments.length - 1].bezierPoint2.y\n        });\n        pts = this.clipDecorators(connector, pts, diagramAction);\n\n        for (var j_3 = 0; j_3 < segments.length; j_3++) {\n          if (j_3 === 0) {\n            path = 'M' + pts[0].x + ' ' + pts[0].y;\n          }\n\n          var lastPoint = j_3 === segments.length - 1 ? pts[pts.length - 1].x + ' ' + pts[pts.length - 1].y : segments[j_3].points[segments[j_3].points.length - 1].x + ' ' + segments[j_3].points[segments[j_3].points.length - 1].y;\n          path += 'C' + segments[j_3].bezierPoint1.x + ' ' + segments[j_3].bezierPoint1.y + ' ' + segments[j_3].bezierPoint2.x + ' ' + segments[j_3].bezierPoint2.y + ' ' + lastPoint;\n        }\n      } else {\n        for (var k = 0; k < pts.length; k++) {\n          getPt = pts[k];\n\n          if (k === 0) {\n            path = 'M' + getPt.x + ' ' + getPt.y;\n          }\n\n          if (k > 0) {\n            path = this.bridgePath(connector, path, k);\n            path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n          }\n        }\n      }\n    }\n\n    return path;\n  };\n  /** @private */\n\n\n  Connector.prototype.updateShapeElement = function (connector) {\n    var element;\n\n    switch (connector.shape.type) {\n      case 'Bpmn':\n        if (connector.wrapper.children[3] instanceof PathElement) {\n          element = connector.wrapper.children[3];\n        }\n\n        if (connector.shape.flow === 'Message' || isBlazor() && connector.shape.bpmnFlow === 'Message') {\n          this.updateShapePosition(connector, element);\n        }\n\n        break;\n\n      case 'UmlActivity':\n        if (connector.shape.flow === 'Exception' || isBlazor() && connector.shape.umlActivityFlow === 'Exception') {\n          this.getUMLExceptionFlow(connector.wrapper.children[0]);\n        }\n\n        break;\n    }\n  };\n  /** @private */\n\n\n  Connector.prototype.updateShapePosition = function (connector, element) {\n    var segmentOffset = 0.5;\n    var angle;\n    var pt;\n    var length = 0;\n    var anglePoints = this.intermediatePoints;\n\n    for (var i = 0; i < anglePoints.length - 1; i++) {\n      length = length + this.distance(anglePoints[i], anglePoints[i + 1]);\n      var offsetLength = length * segmentOffset;\n\n      if (length >= offsetLength) {\n        angle = findAngle(anglePoints[i], anglePoints[i + 1]);\n        pt = Point.transform(anglePoints[i], angle, offsetLength);\n      }\n    }\n\n    element.offsetX = pt.x;\n    element.offsetY = pt.y;\n  };\n  /** @hidden */\n\n\n  Connector.prototype.scale = function (sw, sh, width, height, refObject) {\n    var tx = 0;\n    var ty = 0;\n\n    if (this.wrapper && this.wrapper.outerBounds) {\n      var outerBounds = getOuterBounds(this);\n      var connWidth = (this.wrapper.bounds.width || this.style.strokeWidth || 1) - 2;\n      var connHeight = (this.wrapper.bounds.height || this.style.strokeWidth || 1) - 2;\n      tx = outerBounds.width - connWidth;\n      ty = outerBounds.height - connHeight;\n      sw = (width - Math.max(tx, ty)) / connWidth;\n      sh = (height - Math.max(tx, ty)) / connHeight;\n      tx = ty = Math.min(tx, ty);\n    }\n\n    sw = sh = Math.min(sw, sh);\n    var matrix = identityMatrix();\n    refObject = refObject || this.wrapper;\n    rotateMatrix(matrix, -refObject.rotateAngle, refObject.offsetX, refObject.offsetY);\n    scaleMatrix(matrix, sw, sh, refObject.offsetX, refObject.offsetY);\n    rotateMatrix(matrix, refObject.rotateAngle, refObject.offsetX, refObject.offsetY);\n    var points = transformPointsByMatrix(matrix, this.intermediatePoints);\n    this.sourcePoint = points[0];\n    this.targetPoint = points[points.length - 1];\n    points = this.intermediatePoints = findConnectorPoints(this);\n    updateConnector(this, points);\n    return {\n      x: tx,\n      y: ty\n    };\n  };\n  /**\n   * @private\n   * Returns the name of class Connector\n   */\n\n\n  Connector.prototype.getClassName = function () {\n    return 'Connector';\n  };\n\n  __decorate([ComplexFactory(getConnectorType)], Connector.prototype, \"shape\", void 0);\n\n  __decorate([Property(ConnectorConstraints.Default)], Connector.prototype, \"constraints\", void 0);\n\n  __decorate([Property(10)], Connector.prototype, \"bridgeSpace\", void 0);\n\n  __decorate([Collection([], PathAnnotation)], Connector.prototype, \"annotations\", void 0);\n\n  __decorate([Complex({}, Point)], Connector.prototype, \"sourcePoint\", void 0);\n\n  __decorate([Complex({}, Point)], Connector.prototype, \"targetPoint\", void 0);\n\n  __decorate([Collection([], ConnectorFixedUserHandle)], Connector.prototype, \"fixedUserHandles\", void 0);\n\n  __decorate([CollectionFactory(getSegmentType)], Connector.prototype, \"segments\", void 0);\n\n  __decorate([Property('')], Connector.prototype, \"sourceID\", void 0);\n\n  __decorate([Property('')], Connector.prototype, \"targetID\", void 0);\n\n  __decorate([Property(10)], Connector.prototype, \"hitPadding\", void 0);\n\n  __decorate([Property(0)], Connector.prototype, \"connectionPadding\", void 0);\n\n  __decorate([Property('Straight')], Connector.prototype, \"type\", void 0);\n\n  __decorate([Property(0)], Connector.prototype, \"cornerRadius\", void 0);\n\n  __decorate([Complex({\n    shape: 'None'\n  }, Decorator)], Connector.prototype, \"sourceDecorator\", void 0);\n\n  __decorate([Complex({\n    shape: 'Arrow'\n  }, Decorator)], Connector.prototype, \"targetDecorator\", void 0);\n\n  __decorate([Complex({}, DiagramTooltip)], Connector.prototype, \"tooltip\", void 0);\n\n  __decorate([Property('')], Connector.prototype, \"sourcePortID\", void 0);\n\n  __decorate([Property('')], Connector.prototype, \"targetPortID\", void 0);\n\n  __decorate([Property(0)], Connector.prototype, \"sourcePadding\", void 0);\n\n  __decorate([Complex({}, SymbolSize)], Connector.prototype, \"previewSize\", void 0);\n\n  __decorate([Complex({}, SymbolSize)], Connector.prototype, \"dragSize\", void 0);\n\n  __decorate([Property(0)], Connector.prototype, \"targetPadding\", void 0);\n\n  __decorate([Complex({\n    strokeWidth: 1,\n    strokeColor: 'black'\n  }, StrokeStyle)], Connector.prototype, \"style\", void 0);\n\n  __decorate([Property(null)], Connector.prototype, \"wrapper\", void 0);\n\n  return Connector;\n}(NodeBase);\n\nexport { Connector };","map":{"version":3,"sources":["/Users/sergeismogliuk/Documents/Project/Project_node/Diplom/react-diplom/react-diplom/node_modules/@syncfusion/ej2-diagrams/src/diagram/objects/connector.js"],"names":["__extends","extendStatics","d","b","Object","setPrototypeOf","__proto__","Array","p","hasOwnProperty","__","constructor","prototype","create","__decorate","decorators","target","key","desc","c","arguments","length","r","getOwnPropertyDescriptor","Reflect","decorate","i","defineProperty","Property","Complex","Collection","ChildProperty","ComplexFactory","CollectionFactory","isBlazor","ShapeStyle","StrokeStyle","Point","TextElement","Transform","ConnectorConstraints","PortConstraints","Rect","Size","findAngle","findConnectorPoints","getOuterBounds","getAnnotationPosition","alignLabelOnSegments","updateConnector","setUMLActivityDefaults","initfixedUserHandlesSymbol","findDistance","findPath","updatePathElement","setConnectorDefaults","randomId","getFunction","flipConnector","PathElement","PathAnnotation","Canvas","getDecoratorShape","DiagramElement","DiagramAction","NodeBase","DiagramTooltip","identityMatrix","rotateMatrix","scaleMatrix","transformPointsByMatrix","transformPointByMatrix","DiagramHtmlElement","getTemplateContent","SymbolSize","ConnectorFixedUserHandle","getConnectorType","obj","DiagramConnectorShape","type","BpmnFlow","ActivityFlow","RelationShip","ConnectorShape","getSegmentType","DiagramConnectorSegment","StraightSegment","BezierSegment","OrthogonalSegment","undefined","Decorator","_super","apply","fill","strokeColor","strokeWidth","x","y","Vector","ConnectorSegment","parent","propName","defaultValue","isArray","_this","call","points","getClassName","angle","distance","getDirection","bounds","excludeBounds","center","direction","part","height","width","fourty5","one35","two25","three15","isEmptyVector","element","getBezierPoints","sourcePoint","targetPoint","value","Math","abs","min","getBezierBounds","startPoint","controlPoint1","controlPoint2","endPoint","connector","minx","miny","maxx","maxy","tolerancevalue","max","Number","t","left","top","right","bottom","bezierPoints","point1","point2","pt","MultiplicityLabel","ClassifierMultiplicity","Connector","parentId","bridges","status","shape","setPortID","diagram","isTarget","targetID","sourceID","targetNode","nameTable","sourceNode","ports","port","targetPortID","id","constraints","None","InConnect","sourcePortID","OutConnect","init","bpmnElement","container","segment","srcDecorator","targetDecorator","getSegmentElement","getConnectorPoints","clipDecorators","toBounds","offsetX","pivot","offsetY","flow","bpmnFlow","getBpmnSequenceFlow","visible","getBpmnAssociationFlow","getBpmnMessageFlow","updateShapePosition","activityFlow","umlActivityFlow","getUMLObjectFlow","getUMLExceptionFlow","getConnectorRelation","anglePoints","intermediatePoints","firstSegment","segments","lastSegment","isEmptyPoint","bezierPoint2","bezierPoint1","accessContent","getDescription","getDecoratorElement","sourceDecorator","style","wrapperContent","description","children","push","annotations","getAnnotationElement","annotationTemplate","fixedUserHandles","getfixedUserHandle","wrapper","relationship","associationType","text1","sourceText","targetText","text","multiplicity","source","lowerBounds","upperBounds","lower","upper","optional","content","offset","alignment","margin","pathseq","pathseqData","sequence","exceptionFlowHeight","midPt","xDist","yDist","dist","sqrt","fractionOfTotal","midPt2","midPt1","matrix","point","association","fixedUserHandle","fixedUserHandleContainer","float","visibility","handleStrokeWidth","handleStrokeColor","cornerRadius","updateAnnotation","symbolIcon","segmentMessage","message","data","horizontalAlignment","verticalAlignment","transform","Self","pt1","pt2","sourcePt","targetPt","annotation","diagramId","textele","annotationType","template","textOverflow","rotateAngle","textElement","canRefresh","pivotPoint","refreshTextElement","getPointloop","newPoint","segmentAngle","offsetPoint","align","hAlign","vAlign","horizor","verzor","displacement","setOffsetWithRespectToBounds","relativeMode","layoutOrientation","lineDistribution","newPoints","slice","clipDecorator","isSource","diagramAction","start","end","len","distancePoints","node","sourceWrapper","targetWrapper","DecoratorPropertyChange","round","adjustPoint","pts","updateSegmentElement","diagramActions","segmentPath","getSegmentPath","connectorSegment","uniteRect","segmentElement","staticSize","adjacentPoint","decorator","decEle","getPath","updateDecoratorElement","bridgePath","path","pointIndex","pathData","n","bridge","rendered","segmentPointIndex","size","canMeasurePath","getPt","st","j","m","j_1","segLength","j_2","vector1","vector2","splice","j_3","lastPoint","k","updateShapeElement","segmentOffset","offsetLength","scale","sw","sh","refObject","tx","ty","outerBounds","connWidth","connHeight","Default"],"mappings":"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","sourcesContent":["var __extends = (this && this.__extends) || (function () {\n    var extendStatics = function (d, b) {\n        extendStatics = Object.setPrototypeOf ||\n            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };\n        return extendStatics(d, b);\n    };\n    return function (d, b) {\n        extendStatics(d, b);\n        function __() { this.constructor = d; }\n        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n    };\n})();\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n/* eslint-disable jsdoc/require-param */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable valid-jsdoc */\n/* eslint-disable jsdoc/require-returns */\n/* eslint-disable @typescript-eslint/ban-types */\n/* eslint-disable no-self-assign */\n/* eslint-disable @typescript-eslint/explicit-module-boundary-types */\n// eslint-disable-next-line @typescript-eslint/triple-slash-reference\n/// <reference path='./node-base-model.d.ts'/>\nimport { Property, Complex, Collection, ChildProperty, ComplexFactory, CollectionFactory, isBlazor } from '@syncfusion/ej2-base';\nimport { ShapeStyle, StrokeStyle } from '../core/appearance';\nimport { Point } from '../primitives/point';\nimport { TextElement } from '../core/elements/text-element';\nimport { Transform, ConnectorConstraints } from '../enum/enum';\nimport { PortConstraints } from '../enum/enum';\nimport { Rect } from '../primitives/rect';\nimport { Size } from '../primitives/size';\nimport { findAngle, findConnectorPoints, getOuterBounds } from '../utility/connector';\nimport { getAnnotationPosition, alignLabelOnSegments, updateConnector } from '../utility/diagram-util';\nimport { setUMLActivityDefaults, initfixedUserHandlesSymbol } from '../utility/diagram-util';\nimport { findDistance, findPath, updatePathElement, setConnectorDefaults } from '../utility/diagram-util';\nimport { randomId, getFunction } from './../utility/base-util';\nimport { flipConnector } from './../utility/diagram-util';\nimport { PathElement } from '../core/elements/path-element';\nimport { PathAnnotation } from './annotation';\nimport { Canvas } from '../core/containers/canvas';\nimport { getDecoratorShape } from './dictionary/common';\nimport { DiagramElement } from '../core/elements/diagram-element';\nimport { DiagramAction } from '../enum/enum';\nimport { NodeBase } from './node-base';\nimport { DiagramTooltip } from './tooltip';\nimport { identityMatrix, rotateMatrix, scaleMatrix, transformPointsByMatrix, transformPointByMatrix } from '../primitives/matrix';\nimport { DiagramHtmlElement } from '../core/elements/html-element';\nimport { getTemplateContent } from '../utility/dom-util';\nimport { SymbolSize } from './preview';\nimport { ConnectorFixedUserHandle } from './fixed-user-handle';\nvar getConnectorType = function (obj) {\n    if (isBlazor()) {\n        return DiagramConnectorShape;\n    }\n    else {\n        if (obj) {\n            switch (obj.type) {\n                case 'Bpmn':\n                    return BpmnFlow;\n                case 'UmlActivity':\n                    return ActivityFlow;\n                case 'UmlClassifier':\n                    return RelationShip;\n                default:\n                    return ConnectorShape;\n            }\n        }\n        return ConnectorShape;\n    }\n};\nvar getSegmentType = function (obj) {\n    if (obj) {\n        if (isBlazor()) {\n            return DiagramConnectorSegment;\n        }\n        else {\n            switch (obj.type) {\n                case 'Straight':\n                    return StraightSegment;\n                case 'Bezier':\n                    return BezierSegment;\n                case 'Orthogonal':\n                    return OrthogonalSegment;\n                default:\n                    return StraightSegment;\n            }\n        }\n    }\n    return undefined;\n};\n/**\n * Decorators are used to decorate the end points of the connector with some predefined path geometry\n */\nvar Decorator = /** @class */ (function (_super) {\n    __extends(Decorator, _super);\n    function Decorator() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property(10)\n    ], Decorator.prototype, \"width\", void 0);\n    __decorate([\n        Property(10)\n    ], Decorator.prototype, \"height\", void 0);\n    __decorate([\n        Property('Arrow')\n    ], Decorator.prototype, \"shape\", void 0);\n    __decorate([\n        Complex({ fill: 'black', strokeColor: 'black', strokeWidth: 1 }, ShapeStyle)\n    ], Decorator.prototype, \"style\", void 0);\n    __decorate([\n        Complex({ x: 0, y: 0.5 }, Point)\n    ], Decorator.prototype, \"pivot\", void 0);\n    __decorate([\n        Property('')\n    ], Decorator.prototype, \"pathData\", void 0);\n    return Decorator;\n}(ChildProperty));\nexport { Decorator };\n/**\n * Describes the length and angle between the control point and the start point of bezier segment\n */\nvar Vector = /** @class */ (function (_super) {\n    __extends(Vector, _super);\n    function Vector() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property(0)\n    ], Vector.prototype, \"angle\", void 0);\n    __decorate([\n        Property(0)\n    ], Vector.prototype, \"distance\", void 0);\n    return Vector;\n}(ChildProperty));\nexport { Vector };\n/**\n * Sets the type of the connector\n */\nvar ConnectorShape = /** @class */ (function (_super) {\n    __extends(ConnectorShape, _super);\n    function ConnectorShape() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property('None')\n    ], ConnectorShape.prototype, \"type\", void 0);\n    return ConnectorShape;\n}(ChildProperty));\nexport { ConnectorShape };\n/**\n * Sets the type of the flow in a BPMN Process\n */\nvar ActivityFlow = /** @class */ (function (_super) {\n    __extends(ActivityFlow, _super);\n    function ActivityFlow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property('Object')\n    ], ActivityFlow.prototype, \"flow\", void 0);\n    __decorate([\n        Property(30)\n    ], ActivityFlow.prototype, \"exceptionFlowHeight\", void 0);\n    return ActivityFlow;\n}(ConnectorShape));\nexport { ActivityFlow };\n/**\n * Sets the type of the flow in a BPMN Process\n */\nvar BpmnFlow = /** @class */ (function (_super) {\n    __extends(BpmnFlow, _super);\n    function BpmnFlow() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property('Sequence')\n    ], BpmnFlow.prototype, \"flow\", void 0);\n    __decorate([\n        Property('Normal')\n    ], BpmnFlow.prototype, \"sequence\", void 0);\n    __decorate([\n        Property('Default')\n    ], BpmnFlow.prototype, \"message\", void 0);\n    __decorate([\n        Property('Default')\n    ], BpmnFlow.prototype, \"association\", void 0);\n    return BpmnFlow;\n}(ConnectorShape));\nexport { BpmnFlow };\n/**\n * Defines the behavior of connector segments\n */\nvar ConnectorSegment = /** @class */ (function (_super) {\n    __extends(ConnectorSegment, _super);\n    // tslint:disable-next-line:no-any\n    function ConnectorSegment(parent, propName, defaultValue, isArray) {\n        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n        _this.points = [];\n        return _this;\n    }\n    __decorate([\n        Property('Straight')\n    ], ConnectorSegment.prototype, \"type\", void 0);\n    __decorate([\n        Property(true)\n    ], ConnectorSegment.prototype, \"allowDrag\", void 0);\n    return ConnectorSegment;\n}(ChildProperty));\nexport { ConnectorSegment };\n/**\n * Defines the behavior of straight segments\n */\nvar StraightSegment = /** @class */ (function (_super) {\n    __extends(StraightSegment, _super);\n    function StraightSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns the name of class StraightSegment\n     *\n     * @private\n     */\n    StraightSegment.prototype.getClassName = function () {\n        return 'StraightSegment';\n    };\n    __decorate([\n        Complex({ x: 0, y: 0 }, Point)\n    ], StraightSegment.prototype, \"point\", void 0);\n    return StraightSegment;\n}(ConnectorSegment));\nexport { StraightSegment };\n/**\n * Defines the behavior of bezier segments\n */\nvar BezierSegment = /** @class */ (function (_super) {\n    __extends(BezierSegment, _super);\n    function BezierSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @private\n     * Returns the name of class BezierSegment\n     */\n    BezierSegment.prototype.getClassName = function () {\n        return 'BezierSegment';\n    };\n    __decorate([\n        Complex({ x: 0, y: 0 }, Point)\n    ], BezierSegment.prototype, \"point1\", void 0);\n    __decorate([\n        Complex({ x: 0, y: 0 }, Point)\n    ], BezierSegment.prototype, \"point2\", void 0);\n    __decorate([\n        Complex({ angle: 0, distance: 0 }, Vector)\n    ], BezierSegment.prototype, \"vector1\", void 0);\n    __decorate([\n        Complex({ angle: 0, distance: 0 }, Vector)\n    ], BezierSegment.prototype, \"vector2\", void 0);\n    return BezierSegment;\n}(StraightSegment));\nexport { BezierSegment };\n/**\n * Defines the behavior of orthogonal segments\n */\nvar OrthogonalSegment = /** @class */ (function (_super) {\n    __extends(OrthogonalSegment, _super);\n    function OrthogonalSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * Returns the module of class OrthogonalSegment\n     *\n     * @private\n     */\n    OrthogonalSegment.prototype.getClassName = function () {\n        return 'OrthogonalSegment';\n    };\n    __decorate([\n        Property(null)\n    ], OrthogonalSegment.prototype, \"length\", void 0);\n    __decorate([\n        Property(null)\n    ], OrthogonalSegment.prototype, \"direction\", void 0);\n    return OrthogonalSegment;\n}(ConnectorSegment));\nexport { OrthogonalSegment };\n/**\n * Defines the behavior of orthogonal segments\n */\nvar DiagramConnectorSegment = /** @class */ (function (_super) {\n    __extends(DiagramConnectorSegment, _super);\n    function DiagramConnectorSegment() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    /**\n     * @private\n     * Returns the module of class OrthogonalSegment\n     */\n    DiagramConnectorSegment.prototype.getClassName = function () {\n        return 'DiagramConnectorSegment';\n    };\n    __decorate([\n        Property('Straight')\n    ], DiagramConnectorSegment.prototype, \"type\", void 0);\n    __decorate([\n        Property(true)\n    ], DiagramConnectorSegment.prototype, \"allowDrag\", void 0);\n    __decorate([\n        Complex({ x: 0, y: 0 }, Point)\n    ], DiagramConnectorSegment.prototype, \"point\", void 0);\n    __decorate([\n        Complex({ x: 0, y: 0 }, Point)\n    ], DiagramConnectorSegment.prototype, \"point1\", void 0);\n    __decorate([\n        Complex({ x: 0, y: 0 }, Point)\n    ], DiagramConnectorSegment.prototype, \"point2\", void 0);\n    __decorate([\n        Complex({ angle: 0, distance: 0 }, Vector)\n    ], DiagramConnectorSegment.prototype, \"vector1\", void 0);\n    __decorate([\n        Complex({ angle: 0, distance: 0 }, Vector)\n    ], DiagramConnectorSegment.prototype, \"vector2\", void 0);\n    __decorate([\n        Property(null)\n    ], DiagramConnectorSegment.prototype, \"length\", void 0);\n    __decorate([\n        Property(null)\n    ], DiagramConnectorSegment.prototype, \"direction\", void 0);\n    return DiagramConnectorSegment;\n}(ChildProperty));\nexport { DiagramConnectorSegment };\n/**\n * Get the direction of the control points while the bezier is connected to the node\n */\nexport function getDirection(bounds, points, excludeBounds) {\n    var center = bounds.center;\n    var direction;\n    var part = excludeBounds ? 45 : (180 / (2 + 2 / (bounds.height / bounds.width)));\n    var fourty5 = part;\n    var one35 = (180 - part);\n    var two25 = one35 + (2 * part);\n    var three15 = 360 - part;\n    var angle = findAngle(points, center);\n    if (angle > fourty5 && angle < one35) {\n        return direction = 'top';\n    }\n    else if (angle > one35 && angle < two25) {\n        return direction = 'right';\n    }\n    else if (angle > two25 && angle < three15) {\n        return direction = 'bottom';\n    }\n    else {\n        return direction = 'left';\n    }\n}\nexport function isEmptyVector(element) {\n    if (!element.distance && !element.angle) {\n        return true;\n    }\n    return false;\n}\n/**\n * Get the bezier points if control points are not given.\n */\nexport function getBezierPoints(sourcePoint, targetPoint, direction) {\n    var distance = 60;\n    var value = { x: 0, y: 0 };\n    if (!direction) {\n        if (Math.abs(targetPoint.x - sourcePoint.x) > Math.abs(targetPoint.y - sourcePoint.y)) {\n            direction = sourcePoint.x < targetPoint.x ? 'right' : 'left';\n        }\n        else {\n            direction = sourcePoint.y < targetPoint.y ? 'bottom' : 'top';\n        }\n    }\n    switch (direction) {\n        case 'bottom':\n        case 'top':\n            distance = Math.min(Math.abs(sourcePoint.y - targetPoint.y) * 0.45, distance);\n            value = { x: sourcePoint.x, y: sourcePoint.y + (direction === 'bottom' ? distance : -distance) };\n            break;\n        case 'right':\n        case 'left':\n            distance = Math.min(Math.abs(sourcePoint.x - targetPoint.x) * 0.45, distance);\n            value = { x: sourcePoint.x + (direction === 'right' ? distance : -distance), y: sourcePoint.y };\n            break;\n    }\n    return value;\n}\n/**\n * Get the bezier curve bounds.\n */\nexport function getBezierBounds(startPoint, controlPoint1, controlPoint2, endPoint, connector) {\n    var minx = 0;\n    var miny = 0;\n    var maxx = 0;\n    var maxy = 0;\n    var tolerancevalue = 3;\n    var max = Number((connector.distance(controlPoint1, startPoint) +\n        connector.distance(controlPoint2, controlPoint1) +\n        connector.distance(endPoint, controlPoint2)) / tolerancevalue);\n    if (max !== 0) {\n        for (var i = 0; i <= max; i++) {\n            var t = i / max;\n            var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x +\n                3 * t * (1 - t) * (1 - t) * controlPoint1.x +\n                3 * t * t * (1 - t) * controlPoint2.x +\n                t * t * t * endPoint.x;\n            var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y +\n                3 * t * (1 - t) * (1 - t) * controlPoint1.y +\n                3 * t * t * (1 - t) * controlPoint2.y +\n                t * t * t * endPoint.y;\n            if (i === 0) {\n                minx = maxx = x;\n                miny = maxy = y;\n            }\n            else {\n                minx = Math.min(x, minx);\n                miny = Math.min(y, miny);\n                maxx = Math.max(x, maxx);\n                maxy = Math.max(y, maxy);\n            }\n        }\n    }\n    return {\n        x: minx, y: miny, width: maxx - minx, height: maxy - miny,\n        left: minx, top: miny, right: (minx + (maxx - minx)), bottom: (miny + (maxy - miny)),\n        center: { x: (minx + (maxx - minx)) / 2, y: (miny + (maxy - miny)) / 2 }\n    };\n}\n/**\n * Get the intermediate bezier curve for point over connector\n */\nexport function bezierPoints(connector, startPoint, point1, point2, endPoint, i, max) {\n    var pt = { x: 0, y: 0 };\n    var t = i / max;\n    var x = (1 - t) * (1 - t) * (1 - t) * startPoint.x +\n        3 * t * (1 - t) * (1 - t) * point1.x +\n        3 * t * t * (1 - t) * point2.x +\n        t * t * t * endPoint.x;\n    pt.x = x;\n    var y = (1 - t) * (1 - t) * (1 - t) * startPoint.y +\n        3 * t * (1 - t) * (1 - t) * point1.y +\n        3 * t * t * (1 - t) * point2.y +\n        t * t * t * endPoint.y;\n    pt.y = y;\n    return pt;\n}\n/**\n * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults\n */\nvar MultiplicityLabel = /** @class */ (function (_super) {\n    __extends(MultiplicityLabel, _super);\n    function MultiplicityLabel() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property(true)\n    ], MultiplicityLabel.prototype, \"optional\", void 0);\n    __decorate([\n        Property(undefined)\n    ], MultiplicityLabel.prototype, \"lowerBounds\", void 0);\n    __decorate([\n        Property(undefined)\n    ], MultiplicityLabel.prototype, \"upperBounds\", void 0);\n    return MultiplicityLabel;\n}(ChildProperty));\nexport { MultiplicityLabel };\n/**\n * Defines the behavior of the UMLActivity Classifier multiplicity connection defaults\n */\nvar ClassifierMultiplicity = /** @class */ (function (_super) {\n    __extends(ClassifierMultiplicity, _super);\n    function ClassifierMultiplicity() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property('OneToOne')\n    ], ClassifierMultiplicity.prototype, \"type\", void 0);\n    __decorate([\n        Complex({}, MultiplicityLabel)\n    ], ClassifierMultiplicity.prototype, \"target\", void 0);\n    __decorate([\n        Complex({}, MultiplicityLabel)\n    ], ClassifierMultiplicity.prototype, \"source\", void 0);\n    return ClassifierMultiplicity;\n}(ChildProperty));\nexport { ClassifierMultiplicity };\n/**\n * Defines the behavior of the UMLActivity shape\n */\nvar RelationShip = /** @class */ (function (_super) {\n    __extends(RelationShip, _super);\n    function RelationShip() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property('UmlClassifier')\n    ], RelationShip.prototype, \"type\", void 0);\n    __decorate([\n        Property('Aggregation')\n    ], RelationShip.prototype, \"relationship\", void 0);\n    __decorate([\n        Property('Directional')\n    ], RelationShip.prototype, \"associationType\", void 0);\n    __decorate([\n        Complex({}, ClassifierMultiplicity)\n    ], RelationShip.prototype, \"multiplicity\", void 0);\n    return RelationShip;\n}(ConnectorShape));\nexport { RelationShip };\n/**\n * Connector shape for blazor\n */\nvar DiagramConnectorShape = /** @class */ (function (_super) {\n    __extends(DiagramConnectorShape, _super);\n    function DiagramConnectorShape() {\n        return _super !== null && _super.apply(this, arguments) || this;\n    }\n    __decorate([\n        Property('None')\n    ], DiagramConnectorShape.prototype, \"type\", void 0);\n    __decorate([\n        Property('Directional')\n    ], DiagramConnectorShape.prototype, \"associationType\", void 0);\n    __decorate([\n        Property('Aggregation')\n    ], DiagramConnectorShape.prototype, \"relationship\", void 0);\n    __decorate([\n        Complex({}, ClassifierMultiplicity)\n    ], DiagramConnectorShape.prototype, \"multiplicity\", void 0);\n    __decorate([\n        Property('Sequence')\n    ], DiagramConnectorShape.prototype, \"bpmnFlow\", void 0);\n    __decorate([\n        Property('Default')\n    ], DiagramConnectorShape.prototype, \"message\", void 0);\n    __decorate([\n        Property('Normal')\n    ], DiagramConnectorShape.prototype, \"sequence\", void 0);\n    __decorate([\n        Property('Default')\n    ], DiagramConnectorShape.prototype, \"association\", void 0);\n    __decorate([\n        Property('Object')\n    ], DiagramConnectorShape.prototype, \"umlActivityFlow\", void 0);\n    __decorate([\n        Property(30)\n    ], DiagramConnectorShape.prototype, \"exceptionFlowHeight\", void 0);\n    return DiagramConnectorShape;\n}(ChildProperty));\nexport { DiagramConnectorShape };\n/**\n * Connectors are used to create links between nodes\n */\nvar Connector = /** @class */ (function (_super) {\n    __extends(Connector, _super);\n    // tslint:disable-next-line:no-any\n    function Connector(parent, propName, defaultValue, isArray) {\n        var _this = _super.call(this, parent, propName, defaultValue, isArray) || this;\n        /** @private */\n        _this.parentId = '';\n        /** @private */\n        _this.bridges = [];\n        /** @private */\n        _this.status = 'None';\n        if (_this.shape && _this.shape.type === 'UmlActivity') {\n            setUMLActivityDefaults(defaultValue, _this);\n        }\n        if (defaultValue && defaultValue.shape && defaultValue.shape.type !== 'None') {\n            setConnectorDefaults(defaultValue, _this);\n        }\n        return _this;\n    }\n    /* tslint:disable */\n    Connector.prototype.setPortID = function (diagram, isTarget) {\n        if (this.targetID && this.sourceID) {\n            var targetNode = diagram.nameTable[this.targetID];\n            var sourceNode = diagram.nameTable[this.sourceID];\n            var ports = isTarget ? (targetNode && targetNode.ports) : (sourceNode && sourceNode.ports);\n            var port = void 0;\n            for (var i = 0; ports && i < ports.length; i++) {\n                port = ports[i];\n                if (this.targetPortID === port.id && isTarget) {\n                    if ((port.constraints & PortConstraints.None) || !(port.constraints & PortConstraints.InConnect)) {\n                        this.targetPortID = '';\n                    }\n                }\n                else if (this.sourcePortID === port.id && !isTarget) {\n                    if ((port.constraints & PortConstraints.None) || !(port.constraints & PortConstraints.OutConnect)) {\n                        this.sourcePortID = '';\n                    }\n                }\n            }\n        }\n    };\n    /* tslint:enable */\n    /** @private */\n    // tslint:disable-next-line:no-any\n    Connector.prototype.init = function (diagram) {\n        if (!this.id) {\n            this.id = randomId();\n        }\n        if (this.sourcePortID) {\n            this.setPortID(diagram);\n        }\n        if (this.targetPortID) {\n            this.setPortID(diagram, true);\n        }\n        var bpmnElement;\n        var container = new Canvas();\n        var segment = new PathElement();\n        segment.id = this.id + '_path';\n        var srcDecorator = new PathElement();\n        var targetDecorator = new PathElement();\n        segment = this.getSegmentElement(this, segment);\n        //let bounds: Rect;\n        var points = [];\n        points = this.getConnectorPoints(this.type);\n        points = this.clipDecorators(this, points);\n        var bounds = Rect.toBounds(points);\n        container.width = bounds.width;\n        container.height = bounds.height;\n        container.offsetX = bounds.x + container.pivot.x * bounds.width;\n        container.offsetY = bounds.y + container.pivot.y * bounds.height;\n        switch (this.shape.type) {\n            case 'Bpmn':\n                // eslint-disable-next-line no-case-declarations\n                var flow = (isBlazor() ? this.shape.bpmnFlow : this.shape.flow);\n                switch (flow) {\n                    case 'Sequence':\n                        bpmnElement = this.getBpmnSequenceFlow();\n                        break;\n                    case 'Association':\n                        bpmnElement = new PathElement();\n                        bpmnElement.visible = false;\n                        this.getBpmnAssociationFlow();\n                        break;\n                    case 'Message':\n                        bpmnElement = this.getBpmnMessageFlow();\n                        segment = this.getSegmentElement(this, segment);\n                        this.updateShapePosition(this, bpmnElement);\n                        break;\n                }\n                break;\n            case 'UmlActivity':\n                // eslint-disable-next-line no-case-declarations\n                var activityFlow = (isBlazor() ? this.shape.umlActivityFlow :\n                    this.shape.flow);\n                switch (activityFlow) {\n                    case 'Object':\n                        this.getUMLObjectFlow();\n                        break;\n                    case 'Exception':\n                        this.getUMLExceptionFlow(segment);\n                        break;\n                }\n                break;\n            case 'UmlClassifier':\n                this.getConnectorRelation();\n                break;\n        }\n        var anglePoints = this.intermediatePoints;\n        if (this.type === 'Bezier') {\n            var firstSegment = this.segments[0];\n            var lastSegment = this.segments[this.segments.length - 1];\n            anglePoints = [!Point.isEmptyPoint(lastSegment.point2) ? lastSegment.point2 : lastSegment.bezierPoint2,\n                !Point.isEmptyPoint(firstSegment.point1) ? firstSegment.point1 : firstSegment.bezierPoint1];\n        }\n        var accessContent = 'getDescription';\n        var getDescription = diagram[accessContent];\n        //const strokeWidth: number = this.sourceWrapper ? this.sourceWrapper.style.strokeWidth / 2 / 2 : 0;\n        srcDecorator = this.getDecoratorElement(points[0], anglePoints[1], this.sourceDecorator, true, getDescription);\n        targetDecorator = this.getDecoratorElement(points[points.length - 1], anglePoints[anglePoints.length - 2], this.targetDecorator, false, getDescription);\n        srcDecorator.id = this.id + '_srcDec';\n        targetDecorator.id = this.id + '_tarDec';\n        segment.style = this.style;\n        /* tslint:disable:no-string-literal */\n        segment.style['fill'] = 'transparent';\n        if (getDescription !== undefined) {\n            // tslint:disable-next-line:no-any\n            var wrapperContent = getDescription(this, diagram);\n            segment.description = wrapperContent ? wrapperContent : this.id;\n        }\n        container.style.strokeColor = 'transparent';\n        container.style.fill = 'transparent';\n        container.style.strokeWidth = 0;\n        container.children = [segment, srcDecorator, targetDecorator];\n        container.id = this.id;\n        if (bpmnElement !== undefined) {\n            container.children.push(bpmnElement);\n        }\n        container.offsetX = segment.offsetX;\n        container.offsetY = segment.offsetY;\n        container.width = segment.width;\n        container.height = segment.height;\n        for (var i = 0; this.annotations !== undefined, i < this.annotations.length; i++) {\n            container.children.push(this.getAnnotationElement(this.annotations[i], this.intermediatePoints, bounds, getDescription, diagram.element.id, diagram.annotationTemplate));\n        }\n        for (var i = 0; this.fixedUserHandles !== undefined, i < this.fixedUserHandles.length; i++) {\n            container.children.push(this.getfixedUserHandle(this.fixedUserHandles[i], this.intermediatePoints, bounds));\n        }\n        this.wrapper = container;\n        return container;\n    };\n    Connector.prototype.getConnectorRelation = function () {\n        var shape = this.shape;\n        if (shape.relationship === 'Association') {\n            this.segments[0].type = 'Straight';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'Arrow';\n        }\n        else if (shape.relationship === 'Inheritance') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'Arrow';\n        }\n        else if (shape.relationship === 'Composition') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'Diamond';\n            this.targetDecorator.shape = 'None';\n        }\n        else if (shape.relationship === 'Aggregation') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'Diamond';\n            this.targetDecorator.shape = 'None';\n        }\n        else if (shape.relationship === 'Dependency') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'OpenArrow';\n        }\n        else if (shape.relationship === 'Realization') {\n            this.segments[0].type = 'Orthogonal';\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if (shape.associationType === 'BiDirectional') {\n            this.sourceDecorator.shape = 'None';\n            this.targetDecorator.shape = 'None';\n        }\n        var text1 = '';\n        //let lower: MultiplicityLabelModel;\n        //let upper: MultiplicityLabelModel;\n        var sourceText = '';\n        var targetText = '';\n        var text = '';\n        if (shape.multiplicity.source) {\n            shape.multiplicity.source.lowerBounds = shape.multiplicity.source.lowerBounds;\n            shape.multiplicity.source.upperBounds = shape.multiplicity.source.upperBounds;\n        }\n        if (shape.multiplicity.target) {\n            shape.multiplicity.target.lowerBounds = shape.multiplicity.target.lowerBounds;\n            shape.multiplicity.target.upperBounds = shape.multiplicity.target.upperBounds;\n        }\n        var lower = shape.multiplicity.source;\n        var upper = shape.multiplicity.target;\n        text = lower.upperBounds ? lower.lowerBounds + '...' + lower.upperBounds : lower.lowerBounds;\n        text1 = upper.upperBounds ? upper.lowerBounds + '...' + upper.upperBounds : upper.lowerBounds;\n        if (shape.multiplicity.type === 'ManyToOne') {\n            shape.multiplicity.target.optional = false;\n            sourceText = text ? text : '*';\n            targetText = '1';\n        }\n        if (shape.multiplicity.type === 'OneToMany') {\n            shape.multiplicity.source.optional = false;\n            targetText = text1 ? text1 : '*';\n            sourceText = '1';\n        }\n        if (shape.multiplicity.type === 'ManyToOne') {\n            sourceText = text ? text : '*';\n            targetText = text1 ? text1 : '*';\n        }\n        if (shape.multiplicity.type === 'OneToOne') {\n            shape.multiplicity.target.optional = false;\n            shape.multiplicity.source.optional = false;\n            sourceText = '1';\n            targetText = '1';\n        }\n        this.annotations = [\n            {\n                id: this.id + 'sourcelabel', content: sourceText, offset: 0, alignment: 'Before',\n                margin: { right: 5, bottom: 5 }\n            },\n            {\n                id: this.id + 'targetlabel', content: targetText, offset: 1, alignment: 'Before',\n                margin: { right: 5, bottom: 5 }\n            }\n        ];\n    };\n    Connector.prototype.getBpmnSequenceFlow = function () {\n        var segment = new PathElement();\n        var pathseq = new PathElement();\n        var pathseqData;\n        if ((this.shape.sequence) === 'Normal' && this.type !== 'Bezier') {\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if ((this.shape.sequence) === 'Default') {\n            segment = this.getSegmentElement(this, segment);\n            var anglePoints = this.intermediatePoints;\n            pathseq = updatePathElement(anglePoints, this);\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if ((this.shape.sequence) === 'Conditional') {\n            this.targetDecorator.shape = 'Arrow';\n            this.sourceDecorator.shape = 'Diamond';\n            pathseq.id = this.id + this.shape.type;\n        }\n        return pathseq;\n    };\n    /** @private */\n    Connector.prototype.getUMLObjectFlow = function () {\n        if (this.annotations) {\n            for (var i = 0; i < this.annotations.length; i++) {\n                this.annotations[i].content = '[' + this.annotations[i].content + ']';\n            }\n        }\n    };\n    /** @private */\n    Connector.prototype.getUMLExceptionFlow = function (segment) {\n        this.type = 'Straight';\n        var height = (this.shape.exceptionFlowHeight) / 2;\n        var midPt = { x: (this.targetPoint.x + this.sourcePoint.x) / 2, y: (this.targetPoint.y + this.sourcePoint.y) / 2 };\n        var xDist = midPt.x - this.sourcePoint.x;\n        var yDist = midPt.y - this.sourcePoint.y;\n        var dist = Math.sqrt(xDist * xDist + yDist * yDist);\n        var fractionOfTotal = (height) / dist;\n        var midPt2 = { x: midPt.x - xDist * fractionOfTotal, y: midPt.y - yDist * fractionOfTotal };\n        var midPt1 = { x: midPt.x + xDist * fractionOfTotal, y: midPt.y + yDist * fractionOfTotal };\n        var matrix = identityMatrix();\n        rotateMatrix(matrix, 315, midPt.x, midPt.y);\n        this.segments = [];\n        var segments = new StraightSegment(this, 'segments', { type: 'Straight', point: transformPointByMatrix(matrix, midPt1) }, true);\n        (this.segments).push(segments);\n        segments = new StraightSegment(this, 'segments', { type: 'Straight', point: transformPointByMatrix(matrix, midPt2) }, true);\n        (this.segments).push(segments);\n        segment = this.getSegmentElement(this, segment);\n    };\n    Connector.prototype.getBpmnAssociationFlow = function () {\n        if ((this.shape.association) === 'Default') {\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if ((this.shape.association) === 'Directional') {\n            this.targetDecorator.shape = 'Arrow';\n        }\n        if ((this.shape.association) === 'BiDirectional') {\n            this.targetDecorator.shape = 'Arrow';\n            this.sourceDecorator.shape = 'Arrow';\n        }\n    };\n    /** @private */\n    Connector.prototype.getfixedUserHandle = function (fixedUserHandle, points, bounds) {\n        var fixedUserHandleContainer = new Canvas();\n        fixedUserHandleContainer.float = true;\n        var children = [];\n        fixedUserHandle.id = fixedUserHandle.id || randomId();\n        fixedUserHandleContainer.id = this.id + '_' + fixedUserHandle.id;\n        fixedUserHandleContainer.children = children;\n        fixedUserHandleContainer.visible = fixedUserHandle.visibility;\n        fixedUserHandleContainer.width = fixedUserHandle.width;\n        fixedUserHandleContainer.height = fixedUserHandle.height;\n        fixedUserHandleContainer.style.strokeWidth = fixedUserHandle.handleStrokeWidth;\n        fixedUserHandleContainer.style.fill = fixedUserHandle.fill;\n        fixedUserHandleContainer.style.strokeColor = fixedUserHandle.handleStrokeColor;\n        fixedUserHandleContainer.cornerRadius = fixedUserHandle.cornerRadius;\n        this.updateAnnotation(fixedUserHandle, points, bounds, fixedUserHandleContainer);\n        var symbolIcon = initfixedUserHandlesSymbol(fixedUserHandle, fixedUserHandleContainer);\n        fixedUserHandleContainer.children.push(symbolIcon);\n        fixedUserHandleContainer.description = fixedUserHandleContainer.id;\n        return fixedUserHandleContainer;\n    };\n    Connector.prototype.getBpmnMessageFlow = function () {\n        var segmentMessage = new PathElement();\n        this.targetDecorator.shape = 'Arrow';\n        this.targetDecorator.width = 5;\n        this.targetDecorator.height = 10;\n        this.sourceDecorator.shape = 'Circle';\n        if (((this.shape.message) === 'InitiatingMessage') ||\n            ((this.shape.message) === 'NonInitiatingMessage')) {\n            segmentMessage.id = this.id + '_' + (this.shape.message);\n            segmentMessage.width = 25;\n            segmentMessage.height = 15;\n            segmentMessage.data = 'M0,0 L19.8,12.8 L40,0 L0, 0 L0, 25.5 L40, 25.5 L 40, 0';\n            segmentMessage.horizontalAlignment = 'Center';\n            segmentMessage.verticalAlignment = 'Center';\n            segmentMessage.transform = Transform.Self;\n            segmentMessage.style.fill = (this.shape.message) === 'NonInitiatingMessage' ? 'lightgrey' : 'white';\n        }\n        return segmentMessage;\n    };\n    /** @private */\n    Connector.prototype.distance = function (pt1, pt2) {\n        return findDistance(pt1, pt2);\n    };\n    /**   @private  */\n    Connector.prototype.findPath = function (sourcePt, targetPt) {\n        return findPath(sourcePt, targetPt);\n    };\n    /** @private */\n    Connector.prototype.getAnnotationElement = function (annotation, points, bounds, getDescription, diagramId, annotationTemplate) {\n        annotation.id = annotation.id || randomId();\n        var textele;\n        if (isBlazor() && annotation.annotationType === 'Template') {\n            annotation.template = annotation.template ? annotation.template : '';\n        }\n        if (diagramId && (annotation.template || annotation.annotationType === 'Template'\n            || (annotationTemplate && annotation.content === ''))) {\n            textele = new DiagramHtmlElement(this.id, diagramId, annotation.id, annotationTemplate);\n            textele = getTemplateContent(textele, annotation, annotationTemplate);\n        }\n        else {\n            textele = new TextElement();\n            textele.content = annotation.content;\n            textele.style.textOverflow = 'Wrap';\n        }\n        textele.constraints = annotation.constraints;\n        textele.visible = annotation.visibility;\n        textele.rotateAngle = annotation.rotateAngle;\n        textele.horizontalAlignment = annotation.horizontalAlignment;\n        textele.verticalAlignment = annotation.verticalAlignment;\n        textele.width = annotation.width;\n        textele.height = annotation.height;\n        if (bounds.width !== undefined && !annotation.template) {\n            textele.width = (annotation.width || bounds.width) - annotation.margin.left - annotation.margin.right;\n        }\n        textele.margin = annotation.margin;\n        textele.id = this.id + '_' + annotation.id;\n        if (bounds.width === 0) {\n            bounds.width = this.style.strokeWidth;\n        }\n        if (bounds.height === 0) {\n            bounds.height = this.style.strokeWidth;\n        }\n        textele.style = annotation.style;\n        // tslint:disable-next-line:no-any\n        var wrapperContent;\n        var description = getFunction(getDescription);\n        if (description) {\n            wrapperContent = description(annotation, this);\n        }\n        textele.description = wrapperContent ? wrapperContent : textele.id;\n        this.updateAnnotation(annotation, points, bounds, textele);\n        return textele;\n    };\n    /** @private */\n    Connector.prototype.updateAnnotation = function (annotation, points, bounds, textElement, canRefresh) {\n        //let getPointloop: SegmentInfo;\n        //let align: Alignment; let hAlign: string;\n        var pivotPoint = { x: 0, y: 0 };\n        if (!(textElement instanceof DiagramHtmlElement || DiagramElement) && (!canRefresh)) {\n            textElement.refreshTextElement();\n        }\n        textElement.width = (annotation.width || bounds.width);\n        var getPointloop = getAnnotationPosition(points, annotation, bounds);\n        var newPoint = getPointloop.point;\n        if (annotation instanceof PathAnnotation && annotation.segmentAngle) {\n            textElement.rotateAngle = annotation.rotateAngle + getPointloop.angle;\n            textElement.rotateAngle = (textElement.rotateAngle + 360) % 360;\n        }\n        if (bounds.width === 0) {\n            bounds.width = this.style.strokeWidth;\n        }\n        if (bounds.height === 0) {\n            bounds.height = this.style.strokeWidth;\n        }\n        var offsetPoint = { x: ((newPoint.x - bounds.x) / bounds.width), y: ((newPoint.y - bounds.y) / bounds.height) };\n        pivotPoint.x = bounds.width * offsetPoint.x;\n        pivotPoint.y = bounds.height * offsetPoint.y;\n        var align = alignLabelOnSegments(annotation, getPointloop.angle, points);\n        var hAlign = align.hAlign;\n        var vAlign = align.vAlign;\n        var horizor;\n        var verzor;\n        if (hAlign === 'left') {\n            horizor = 'Left';\n            pivotPoint.x += annotation.displacement.x;\n        }\n        else if (hAlign === 'right') {\n            horizor = 'Right';\n            pivotPoint.x -= annotation.displacement.x;\n        }\n        else if (hAlign === 'center') {\n            horizor = 'Center';\n        }\n        if (vAlign === 'top') {\n            verzor = 'Top';\n            pivotPoint.y += annotation.displacement.y;\n        }\n        else if (vAlign === 'bottom') {\n            verzor = 'Bottom';\n            pivotPoint.y -= annotation.displacement.y;\n        }\n        else if (vAlign === 'center') {\n            verzor = 'Center';\n        }\n        textElement.horizontalAlignment = horizor;\n        textElement.verticalAlignment = verzor;\n        textElement.setOffsetWithRespectToBounds(pivotPoint.x, pivotPoint.y, 'Absolute');\n        textElement.relativeMode = 'Point';\n    };\n    /** @private */\n    Connector.prototype.getConnectorPoints = function (type, points, layoutOrientation, lineDistribution) {\n        //const width: number = Math.abs(this.sourcePoint.x - this.targetPoint.x);\n        //const height: number = Math.abs(this.sourcePoint.y - this.targetPoint.y);\n        points = findConnectorPoints(this, layoutOrientation, lineDistribution);\n        var newPoints = points.slice(0);\n        if (newPoints && newPoints.length > 0) {\n            this.sourcePoint = newPoints[0];\n            this.targetPoint = newPoints[newPoints.length - 1];\n        }\n        return newPoints;\n    };\n    /** @private */\n    Connector.prototype.clipDecorator = function (connector, points, isSource, diagramAction) {\n        var point = { x: 0, y: 0 };\n        var start = { x: 0, y: 0 };\n        var end = { x: 0, y: 0 };\n        var length = points.length;\n        start = !isSource ? points[length - 1] : points[0];\n        end = !isSource ? points[length - 2] : points[1];\n        var len = Point.distancePoints(start, end);\n        len = (len === 0) ? 1 : len;\n        var strokeWidth = 1;\n        var node = isSource ? connector.sourceWrapper : connector.targetWrapper;\n        if (node) {\n            strokeWidth = node.style.strokeWidth;\n            if (diagramAction && ((diagramAction) & DiagramAction.DecoratorPropertyChange)) {\n                strokeWidth = 1;\n            }\n        }\n        var width = strokeWidth - 1;\n        point.x = (Math.round(start.x + width * (end.x - start.x) / len));\n        point.y = (Math.round(start.y + width * (end.y - start.y) / len));\n        if ((isSource && connector.sourceDecorator.shape !== 'None') ||\n            (!isSource && connector.targetDecorator.shape !== 'None')) {\n            point = Point.adjustPoint(point, end, true, (diagramAction & DiagramAction.DecoratorPropertyChange) ? 0 : (strokeWidth / 2));\n        }\n        return point;\n    };\n    /** @private */\n    Connector.prototype.clipDecorators = function (connector, pts, diagramAction) {\n        if (connector.sourceDecorator.shape !== 'None') {\n            pts[0] = this.clipDecorator(connector, pts, true, diagramAction);\n        }\n        if (connector.targetDecorator.shape !== 'None') {\n            pts[pts.length - 1] = this.clipDecorator(connector, pts, false, diagramAction);\n        }\n        return pts;\n    };\n    /** @private */\n    Connector.prototype.updateSegmentElement = function (connector, points, element, diagramActions) {\n        var bounds = new Rect();\n        //let point: PointModel[];\n        var segmentPath = this.getSegmentPath(connector, points, diagramActions);\n        if (connector.type === 'Bezier') {\n            if (this.segments.length > 0) {\n                for (var i = 0; i < this.segments.length; i++) {\n                    var segment = this.segments[i];\n                    var connectorSegment = connector.segments[i];\n                    // eslint-disable-next-line max-len\n                    var point1 = !Point.isEmptyPoint(segment.point1) ? connectorSegment.point1 : connectorSegment.bezierPoint1;\n                    // eslint-disable-next-line max-len\n                    var point2 = !Point.isEmptyPoint(segment.point2) ? connectorSegment.point2 : connectorSegment.bezierPoint2;\n                    bounds.uniteRect(getBezierBounds(segment.points[0], point1, point2, segment.points[1], connector));\n                }\n            }\n        }\n        else {\n            bounds = Rect.toBounds(points);\n        }\n        element.width = bounds.width;\n        element.height = bounds.height;\n        element.offsetX = bounds.x + element.width / 2;\n        element.offsetY = bounds.y + element.height / 2;\n        element.data = segmentPath;\n        if (connector.wrapper) {\n            connector.wrapper.offsetX = element.offsetX;\n            connector.wrapper.offsetY = element.offsetY;\n            connector.wrapper.width = bounds.width;\n            connector.wrapper.height = bounds.height;\n        }\n        return element;\n    };\n    /** @private */\n    Connector.prototype.getSegmentElement = function (connector, segmentElement, layoutOrientation, diagramActions) {\n        //let bounds: Rect; let segmentPath: string;\n        var points = [];\n        flipConnector(connector);\n        points = this.getConnectorPoints(connector.type, undefined, layoutOrientation);\n        this.intermediatePoints = points;\n        segmentElement.staticSize = true;\n        segmentElement = this.updateSegmentElement(connector, points, segmentElement, diagramActions);\n        return segmentElement;\n    };\n    /** @private */\n    Connector.prototype.getDecoratorElement = function (offsetPoint, adjacentPoint, decorator, isSource, getDescription) {\n        var decEle = new PathElement();\n        var getPath;\n        var angle;\n        decEle.transform = Transform.Self;\n        this.updateDecoratorElement(decEle, offsetPoint, adjacentPoint, decorator);\n        if (getDescription !== undefined) {\n            // tslint:disable-next-line:no-any\n            var wrapperContent = getDescription(decorator, this);\n            decEle.description = wrapperContent ? wrapperContent :\n                ('Specifies the ' + isSource ? 'source' : 'target' + 'port element of the connector');\n        }\n        return decEle;\n    };\n    Connector.prototype.bridgePath = function (connector, path, pointIndex) {\n        var pathData = path;\n        if (connector.bridges.length > 0) {\n            if (connector.type === 'Straight' && connector.segments.length < 2) {\n                for (var n = 0; n < connector.bridges.length; n++) {\n                    var bridge = connector.bridges[n];\n                    if (!bridge.rendered) {\n                        pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;\n                        pathData += bridge.path;\n                        bridge.rendered = true;\n                    }\n                }\n            }\n            else if (connector.type === 'Orthogonal' || (connector.type === 'Straight' && connector.segments.length > 1)) {\n                for (var n = 0; n < connector.bridges.length; n++) {\n                    var bridge = connector.bridges[n];\n                    if (bridge.segmentPointIndex === pointIndex) {\n                        if (!bridge.rendered) {\n                            if (bridge.segmentPointIndex === pointIndex) {\n                                pathData += ' L' + bridge.startPoint.x + ' ' + bridge.startPoint.y;\n                                pathData += bridge.path;\n                                bridge.rendered = true;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        return pathData;\n    };\n    /** @private */\n    Connector.prototype.updateDecoratorElement = function (element, pt, adjacentPoint, decorator) {\n        //let getPath: string;// let angle: number;\n        element.offsetX = pt.x;\n        element.offsetY = pt.y;\n        var angle = Point.findAngle(pt, adjacentPoint);\n        var getPath = getDecoratorShape(decorator.shape, decorator);\n        var size = new Size(decorator.width, decorator.height);\n        element.pivot.x = decorator.pivot.x;\n        element.pivot.y = decorator.pivot.y;\n        element.style = decorator.style;\n        element.rotateAngle = angle;\n        element.data = getPath;\n        element.canMeasurePath = true;\n        element.width = size.width;\n        element.height = size.height;\n    };\n    /** @private */\n    Connector.prototype.getSegmentPath = function (connector, points, diagramAction) {\n        var path = '';\n        var getPt;\n        var end;\n        var st;\n        var pts = [];\n        var j = 0;\n        while (j < points.length) {\n            pts.push({ x: points[j].x, y: points[j].y });\n            j++;\n        }\n        for (var m = 0; m < connector.bridges.length; m++) {\n            var bridge = connector.bridges[m];\n            bridge.rendered = false;\n        }\n        pts = this.clipDecorators(connector, pts, diagramAction);\n        if (this.cornerRadius > 0 && this.type !== 'Bezier') {\n            for (var j_1 = 0; j_1 < pts.length - 1; j_1++) {\n                getPt = pts[j_1];\n                if (j_1 === 0) {\n                    path = 'M' + getPt.x + ' ' + getPt.y;\n                }\n                var segLength = Point.distancePoints(pts[j_1], pts[j_1 + 1]);\n                if (segLength > 0) {\n                    if (j_1 < pts.length - 2) {\n                        if (segLength < this.cornerRadius * 2) {\n                            end = Point.adjustPoint(pts[j_1], pts[j_1 + 1], false, segLength / 2);\n                        }\n                        else {\n                            end = Point.adjustPoint(pts[j_1], pts[j_1 + 1], false, this.cornerRadius);\n                        }\n                    }\n                    else {\n                        end = pts[j_1 + 1];\n                    }\n                    if (j_1 > 0) {\n                        if (segLength < this.cornerRadius * 2) {\n                            st = Point.adjustPoint(pts[j_1], pts[j_1 + 1], true, segLength / 2);\n                            if (j_1 < pts.length - 2) {\n                                end = null;\n                            }\n                        }\n                        else {\n                            st = Point.adjustPoint(pts[j_1], pts[j_1 + 1], true, this.cornerRadius);\n                        }\n                    }\n                    if (st) {\n                        path += 'Q' + getPt.x + ' ' + getPt.y + ' ' + st.x + ' ' + st.y;\n                    }\n                    if (end) {\n                        if (connector.bridges.length > 0) {\n                            path = this.bridgePath(connector, path, j_1);\n                            if (connector.type === 'Orthogonal') {\n                                path = this.bridgePath(connector, path, j_1 + 1);\n                            }\n                        }\n                        path += ' L' + end.x + ' ' + end.y;\n                    }\n                }\n            }\n        }\n        else {\n            if (this.type === 'Bezier') {\n                var direction = void 0;\n                var segments = this.segments;\n                for (var j_2 = 0; j_2 < segments.length; j_2++) {\n                    if (pts.length > 2) {\n                        segments[j_2].bezierPoint1 = { x: 0, y: 0 };\n                        segments[j_2].bezierPoint2 = { x: 0, y: 0 };\n                    }\n                    if (Point.isEmptyPoint(segments[j_2].point1) && !segments[j_2].vector1.angle && !segments[j_2].vector1.distance) {\n                        if ((connector.sourceID || this.sourcePortID) && this.sourceWrapper) {\n                            direction = getDirection(this.sourceWrapper.bounds, pts[j_2], true);\n                        }\n                        segments[j_2].bezierPoint1 = getBezierPoints(pts[j_2], pts[j_2 + 1], direction);\n                    }\n                    else if (segments[j_2].vector1.angle || segments[j_2].vector1.distance) {\n                        segments[j_2].bezierPoint1 = Point.transform(pts[j_2], segments[j_2].vector1.angle, segments[j_2].vector1.distance);\n                    }\n                    else {\n                        segments[j_2].bezierPoint1 = {\n                            x: segments[j_2].point1.x || segments[j_2].bezierPoint1.x,\n                            y: segments[j_2].point1.y || segments[j_2].bezierPoint1.y\n                        };\n                    }\n                    if (Point.isEmptyPoint(segments[j_2].point2) && !segments[j_2].vector2.angle && !segments[j_2].vector2.distance) {\n                        if ((connector.targetID || this.targetPortID) && this.targetWrapper) {\n                            direction = getDirection(this.targetWrapper.bounds, pts[j_2 + 1], true);\n                        }\n                        segments[j_2].bezierPoint2 = getBezierPoints(pts[j_2 + 1], pts[j_2], direction);\n                    }\n                    else if (segments[j_2].vector2.angle || segments[j_2].vector2.distance) {\n                        segments[j_2].bezierPoint2 = Point.transform(pts[j_2 + 1], segments[j_2].vector2.angle, segments[j_2].vector2.distance);\n                    }\n                    else {\n                        segments[j_2].bezierPoint2 = {\n                            x: segments[j_2].point2.x || segments[j_2].bezierPoint2.x,\n                            y: segments[j_2].point2.y || segments[j_2].bezierPoint2.y\n                        };\n                    }\n                }\n                pts.splice(1, 0, { x: segments[0].bezierPoint1.x, y: segments[0].bezierPoint1.y });\n                pts.splice(pts.length - 1, 0, {\n                    x: segments[segments.length - 1].bezierPoint2.x, y: segments[segments.length - 1].bezierPoint2.y\n                });\n                pts = this.clipDecorators(connector, pts, diagramAction);\n                for (var j_3 = 0; j_3 < segments.length; j_3++) {\n                    if (j_3 === 0) {\n                        path = 'M' + pts[0].x + ' ' + pts[0].y;\n                    }\n                    var lastPoint = (j_3 === segments.length - 1) ? pts[pts.length - 1].x + ' ' + pts[pts.length - 1].y :\n                        segments[j_3].points[segments[j_3].points.length - 1].x + ' ' + segments[j_3].points[segments[j_3].points.length - 1].y;\n                    path += 'C' +\n                        segments[j_3].bezierPoint1.x + ' ' + segments[j_3].bezierPoint1.y + ' ' + segments[j_3].bezierPoint2.x + ' '\n                        + segments[j_3].bezierPoint2.y + ' ' + lastPoint;\n                }\n            }\n            else {\n                for (var k = 0; k < pts.length; k++) {\n                    getPt = pts[k];\n                    if (k === 0) {\n                        path = 'M' + getPt.x + ' ' + getPt.y;\n                    }\n                    if (k > 0) {\n                        path = this.bridgePath(connector, path, k);\n                        path += ' ' + 'L' + getPt.x + ' ' + getPt.y;\n                    }\n                }\n            }\n        }\n        return path;\n    };\n    /** @private */\n    Connector.prototype.updateShapeElement = function (connector) {\n        var element;\n        switch (connector.shape.type) {\n            case 'Bpmn':\n                if (connector.wrapper.children[3] instanceof PathElement) {\n                    element = connector.wrapper.children[3];\n                }\n                if (connector.shape.flow === 'Message' ||\n                    (isBlazor() && connector.shape.bpmnFlow === 'Message')) {\n                    this.updateShapePosition(connector, element);\n                }\n                break;\n            case 'UmlActivity':\n                if (connector.shape.flow === 'Exception' || (isBlazor() &&\n                    connector.shape.umlActivityFlow === 'Exception')) {\n                    this.getUMLExceptionFlow(connector.wrapper.children[0]);\n                }\n                break;\n        }\n    };\n    /** @private */\n    Connector.prototype.updateShapePosition = function (connector, element) {\n        var segmentOffset = 0.5;\n        var angle;\n        var pt;\n        var length = 0;\n        var anglePoints = this.intermediatePoints;\n        for (var i = 0; i < anglePoints.length - 1; i++) {\n            length = length + this.distance(anglePoints[i], anglePoints[i + 1]);\n            var offsetLength = length * segmentOffset;\n            if (length >= offsetLength) {\n                angle = findAngle(anglePoints[i], anglePoints[i + 1]);\n                pt = Point.transform(anglePoints[i], angle, offsetLength);\n            }\n        }\n        element.offsetX = pt.x;\n        element.offsetY = pt.y;\n    };\n    /** @hidden */\n    Connector.prototype.scale = function (sw, sh, width, height, refObject) {\n        var tx = 0;\n        var ty = 0;\n        if (this.wrapper && this.wrapper.outerBounds) {\n            var outerBounds = getOuterBounds(this);\n            var connWidth = (this.wrapper.bounds.width || this.style.strokeWidth || 1) - 2;\n            var connHeight = (this.wrapper.bounds.height || this.style.strokeWidth || 1) - 2;\n            tx = (outerBounds.width - connWidth);\n            ty = (outerBounds.height - connHeight);\n            sw = (width - (Math.max(tx, ty))) / connWidth;\n            sh = (height - (Math.max(tx, ty))) / connHeight;\n            tx = ty = Math.min(tx, ty);\n        }\n        sw = sh = Math.min(sw, sh);\n        var matrix = identityMatrix();\n        refObject = refObject || this.wrapper;\n        rotateMatrix(matrix, -refObject.rotateAngle, refObject.offsetX, refObject.offsetY);\n        scaleMatrix(matrix, sw, sh, refObject.offsetX, refObject.offsetY);\n        rotateMatrix(matrix, refObject.rotateAngle, refObject.offsetX, refObject.offsetY);\n        var points = transformPointsByMatrix(matrix, this.intermediatePoints);\n        this.sourcePoint = points[0];\n        this.targetPoint = points[points.length - 1];\n        points = this.intermediatePoints = findConnectorPoints(this);\n        updateConnector(this, points);\n        return { x: tx, y: ty };\n    };\n    /**\n     * @private\n     * Returns the name of class Connector\n     */\n    Connector.prototype.getClassName = function () {\n        return 'Connector';\n    };\n    __decorate([\n        ComplexFactory(getConnectorType)\n    ], Connector.prototype, \"shape\", void 0);\n    __decorate([\n        Property(ConnectorConstraints.Default)\n    ], Connector.prototype, \"constraints\", void 0);\n    __decorate([\n        Property(10)\n    ], Connector.prototype, \"bridgeSpace\", void 0);\n    __decorate([\n        Collection([], PathAnnotation)\n    ], Connector.prototype, \"annotations\", void 0);\n    __decorate([\n        Complex({}, Point)\n    ], Connector.prototype, \"sourcePoint\", void 0);\n    __decorate([\n        Complex({}, Point)\n    ], Connector.prototype, \"targetPoint\", void 0);\n    __decorate([\n        Collection([], ConnectorFixedUserHandle)\n    ], Connector.prototype, \"fixedUserHandles\", void 0);\n    __decorate([\n        CollectionFactory(getSegmentType)\n    ], Connector.prototype, \"segments\", void 0);\n    __decorate([\n        Property('')\n    ], Connector.prototype, \"sourceID\", void 0);\n    __decorate([\n        Property('')\n    ], Connector.prototype, \"targetID\", void 0);\n    __decorate([\n        Property(10)\n    ], Connector.prototype, \"hitPadding\", void 0);\n    __decorate([\n        Property(0)\n    ], Connector.prototype, \"connectionPadding\", void 0);\n    __decorate([\n        Property('Straight')\n    ], Connector.prototype, \"type\", void 0);\n    __decorate([\n        Property(0)\n    ], Connector.prototype, \"cornerRadius\", void 0);\n    __decorate([\n        Complex({ shape: 'None' }, Decorator)\n    ], Connector.prototype, \"sourceDecorator\", void 0);\n    __decorate([\n        Complex({ shape: 'Arrow' }, Decorator)\n    ], Connector.prototype, \"targetDecorator\", void 0);\n    __decorate([\n        Complex({}, DiagramTooltip)\n    ], Connector.prototype, \"tooltip\", void 0);\n    __decorate([\n        Property('')\n    ], Connector.prototype, \"sourcePortID\", void 0);\n    __decorate([\n        Property('')\n    ], Connector.prototype, \"targetPortID\", void 0);\n    __decorate([\n        Property(0)\n    ], Connector.prototype, \"sourcePadding\", void 0);\n    __decorate([\n        Complex({}, SymbolSize)\n    ], Connector.prototype, \"previewSize\", void 0);\n    __decorate([\n        Complex({}, SymbolSize)\n    ], Connector.prototype, \"dragSize\", void 0);\n    __decorate([\n        Property(0)\n    ], Connector.prototype, \"targetPadding\", void 0);\n    __decorate([\n        Complex({ strokeWidth: 1, strokeColor: 'black' }, StrokeStyle)\n    ], Connector.prototype, \"style\", void 0);\n    __decorate([\n        Property(null)\n    ], Connector.prototype, \"wrapper\", void 0);\n    return Connector;\n}(NodeBase));\nexport { Connector };\n"]},"metadata":{},"sourceType":"module"}