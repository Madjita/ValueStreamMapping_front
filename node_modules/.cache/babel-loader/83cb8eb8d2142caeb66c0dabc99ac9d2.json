{"ast":null,"code":"/* eslint-disable no-case-declarations */\n\n/* eslint-disable @typescript-eslint/indent */\nimport { Size } from './../primitives/size';\nimport { Point } from './../primitives/point';\nimport { processPathData, pathSegmentCollection, getRectanglePath } from './../utility/path-util';\nimport { overFlow } from './../utility/base-util';\nimport { createHtmlElement, setChildPosition } from './../utility/dom-util';\n/**\n * Canvas Renderer\n */\n\n/** @private */\n\nvar CanvasRenderer =\n/** @class */\nfunction () {\n  function CanvasRenderer() {}\n  /**\n   * Provide the context value for the canvas \\\n   *\n   *  @returns {CanvasRenderingContext2D} Provide the context value for the canvas .\\\n   *  @param { HTMLCanvasElement} canvas - Return the dashed array values .\n   *  @private\n   */\n\n\n  CanvasRenderer.getContext = function (canvas) {\n    return canvas.getContext('2d');\n  };\n\n  CanvasRenderer.setCanvasSize = function (canvas, width, height) {\n    if (canvas) {\n      canvas.setAttribute('width', width.toString());\n      canvas.setAttribute('height', height.toString());\n    }\n  };\n  /**\n   * Draw the gradient for the diagram shapes .\\\n   *\n   *  @returns {SVGElement} Draw the gradient for the diagram shapes.\n   *  @param {StyleAttributes} options - Provide the options  for the gradient  element .\n   *  @param {SVGElement} ctx - Provide canvas values .\n   *  @param {string} x - Provide the x value for the gradient .\n   *  @param {string} y - Provide the x value for the gradient .\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.renderGradient = function (options, ctx, x, y) {\n    var max;\n    var min;\n    var grd;\n\n    if (options.gradient.type !== 'None') {\n      for (var i = 0; i < options.gradient.stops.length; i++) {\n        max = max !== undefined ? options.gradient.stops[i].offset : Math.max(max, options.gradient.stops[i].offset);\n        min = min !== undefined ? options.gradient.stops[i].offset : Math.min(min, options.gradient.stops[i].offset);\n      }\n\n      if (options.gradient.type === 'Linear') {\n        var linear = options.gradient;\n        grd = ctx.createLinearGradient(x + linear.x1, y + linear.y1, x + linear.x2, y + linear.y2);\n      } else {\n        var radial = options.gradient;\n        grd = ctx.createRadialGradient(x + radial.fx, y + radial.fy, 0, x + radial.cx, y + radial.cy, radial.r);\n      }\n\n      for (var i = 0; i < options.gradient.stops.length; i++) {\n        var stop_1 = options.gradient.stops[i];\n        var offset = min < 0 ? (max + stop_1.offset) / (2 * max) : stop_1.offset / max;\n        grd.addColorStop(offset, stop_1.color);\n      }\n\n      ctx.fillStyle = grd;\n    }\n\n    return ctx;\n  };\n  /**\n   * Draw the shawdow  for the rectangle shape in diagram \\\n   *\n   *  @returns {void}  Draw the shawdow  for the rectangle shape in diagram .\\\n   *\n   *  @param { SVGElement} options - Provide the base attributes .\n   *  @param { RectAttributes} canvas - Provide the canvas values .\n   *  @param { string} collection - Provide the collection value.\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.renderShadow = function (options, canvas, collection) {\n    if (collection === void 0) {\n      collection = null;\n    }\n\n    var ctx = CanvasRenderer.getContext(canvas);\n    ctx.save();\n    ctx.beginPath();\n    ctx.strokeStyle = ctx.fillStyle = options.shadow.color;\n    ctx.globalAlpha = options.shadow.opacity;\n    var ptModel = {\n      x: 0,\n      y: 0\n    };\n    var point = Point.transform(ptModel, options.shadow.angle, options.shadow.distance);\n    var transX = options.x + point.x;\n    var transY = options.y + point.y;\n    var pivotX = transX + options.width * options.pivotX;\n    var pivotY = transY + options.height * options.pivotY;\n    this.rotateContext(canvas, options.angle, pivotX, pivotY);\n\n    if (collection) {\n      ctx.translate(transX, transY);\n      this.renderPath(canvas, options, collection);\n      ctx.translate(-transX, -transY);\n    } else {\n      ctx.rect(transX, transY, options.width, options.height);\n      ctx.fillRect(transX, transY, options.width, options.height);\n    }\n\n    ctx.fill();\n    ctx.stroke();\n    ctx.closePath();\n    ctx.restore();\n  };\n  /**\n   * Create canvas element for the diagram \\\n   *\n   *  @returns {HTMLCanvasElement}    Create canvas element for the diagram .\\\n   *\n   *  @param { SVGElement} id - Provide the id for the canvas.\n   *  @param { Object} width - Provide the width for the canvas.\n   *  @param { Object} height - Provide the height for the canvas.\n   *  @private\n   */\n\n\n  CanvasRenderer.createCanvas = function (id, width, height) {\n    var canvasObj = createHtmlElement('canvas', {\n      'id': id\n    });\n    this.setCanvasSize(canvasObj, width, height);\n    return canvasObj;\n  };\n\n  CanvasRenderer.prototype.setStyle = function (canvas, style) {\n    var ctx = CanvasRenderer.getContext(canvas);\n\n    if (style.fill === 'none') {\n      style.fill = 'transparent';\n    }\n\n    if (style.stroke === 'none') {\n      style.stroke = 'transparent';\n    }\n\n    ctx.strokeStyle = style.stroke;\n    ctx.lineWidth = style.strokeWidth;\n\n    if (style.strokeWidth === 0) {\n      ctx.strokeStyle = 'transparent';\n    }\n\n    ctx.globalAlpha = style.opacity;\n    var dashArray = [];\n\n    if (style.dashArray) {\n      dashArray = this.parseDashArray(style.dashArray);\n    }\n\n    ctx.setLineDash(dashArray);\n\n    if (style.gradient && style.gradient.type !== 'None') {\n      this.renderGradient(style, ctx, style.x, style.y);\n    } else {\n      ctx.fillStyle = style.fill;\n    }\n  };\n\n  CanvasRenderer.prototype.rotateContext = function (canvas, angle, x, y) {\n    var ctx = CanvasRenderer.getContext(canvas);\n    ctx.translate(x, y);\n    ctx.rotate(angle * Math.PI / 180);\n    ctx.translate(-x, -y);\n  };\n\n  CanvasRenderer.prototype.setFontStyle = function (canvas, text) {\n    var ctx = CanvasRenderer.getContext(canvas);\n    var font = '';\n\n    if (text.italic) {\n      font += 'italic ';\n    }\n\n    if (text.bold) {\n      font += 'bold ';\n    }\n\n    font += text.fontSize + 'px ';\n    font += text.fontFamily;\n    ctx.font = font;\n  };\n  /**\n   * Return the dashed array values \\\n   *\n   *  @returns {number[]}  Return the dashed array values .\\\n   *  @param { SVGElement} dashArray - Return the dashed array values .\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.parseDashArray = function (dashArray) {\n    var dashes = [];\n    var separator = dashArray.indexOf(' ') !== -1 ? ' ' : ',';\n    var splittedDashes = dashArray.split(separator);\n\n    for (var _i = 0, splittedDashes_1 = splittedDashes; _i < splittedDashes_1.length; _i++) {\n      var i = splittedDashes_1[_i];\n      dashes.push(Number(i));\n    }\n\n    return dashes;\n  };\n\n  CanvasRenderer.prototype.drawRoundedRect = function (canvas, options) {\n    var context = CanvasRenderer.getContext(canvas);\n    context.beginPath();\n    var x = options.x;\n    var y = options.y;\n    var w = options.width;\n    var h = options.height;\n    var mx = x + w / 2;\n    var my = y + h / 2;\n    context.beginPath();\n    this.setStyle(canvas, options);\n    context.moveTo(x, my);\n    context.quadraticCurveTo(x, y, mx, y);\n    context.quadraticCurveTo(x + w, y, x + w, my);\n    context.quadraticCurveTo(x + w, y + h, mx, y + h);\n    context.quadraticCurveTo(x, y + h, x, my);\n    context.stroke();\n  }; //Rendering Part\n\n  /**\n   * Draw the Rectangle for the diagram \\\n   *\n   *  @returns {void}  Draw the Rectangle for the diagram .\\\n   *\n   *  @param { SVGElement} canvas - Provide the SVG .\n   *  @param { RectAttributes} options - Provide the Rect attributes .\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.drawRectangle = function (canvas, options) {\n    if (options.visible === true) {\n      if (options.cornerRadius) {\n        if (options.width < 30 || options.height < 30) {\n          this.drawRoundedRect(canvas, options);\n        } else {\n          options.data = getRectanglePath(options.cornerRadius, options.height, options.width);\n          this.drawPath(canvas, options);\n        }\n      } else {\n        var ctx = CanvasRenderer.getContext(canvas);\n\n        if (options.shadow) {\n          this.renderShadow(options, canvas);\n        }\n\n        ctx.save();\n        ctx.beginPath(); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n        var cornerRadius = options.cornerRadius;\n        var pivotX = options.x + options.width * options.pivotX;\n        var pivotY = options.y + options.height * options.pivotY;\n        this.rotateContext(canvas, options.angle, pivotX, pivotY);\n        this.setStyle(canvas, options);\n        ctx.rect(options.x, options.y, options.width, options.height);\n        ctx.fillRect(options.x, options.y, options.width, options.height);\n        ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n      }\n    }\n  }; // public updateSelectionRegion(canvas: HTMLCanvasElement, options: RectAttributes): void {\n  //     this.drawRectangle(canvas, options);\n  // }\n  // public drawLine(canvas: HTMLCanvasElement, options: LineAttributes): void {\n  //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);\n  //     ctx.save();\n  //     ctx.beginPath();\n  //     let pivotX: number = options.x + options.width * options.pivotX;\n  //     let pivotY: number = options.y + options.height * options.pivotY;\n  //     this.rotateContext(canvas, options.angle, pivotX, pivotY);\n  //     this.setStyle(canvas, options as StyleAttributes);\n  //     ctx.translate(options.x, options.y);\n  //     ctx.moveTo(options.startPoint.x, options.startPoint.y);\n  //     ctx.lineTo(options.endPoint.x, options.endPoint.y);\n  //     ctx.translate(-options.x, -options.y);\n  //     ctx.stroke();\n  //     ctx.closePath();\n  //     ctx.restore();\n  // }\n  // public drawCircle(canvas: HTMLCanvasElement, options: CircleAttributes): void {\n  //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);\n  //     ctx.save();\n  //     ctx.beginPath();\n  //     let pivotY: number = options.y + options.height * options.pivotY;\n  //     let pivotX: number = options.x + options.width * options.pivotX;\n  //     this.setStyle(canvas, options as StyleAttributes);\n  //     this.rotateContext(canvas, options.angle, pivotX, pivotY);\n  //     ctx.arc(options.centerX, options.centerY, options.radius, 0, 2 * Math.PI);\n  //     ctx.fill();\n  //     ctx.stroke();\n  //     ctx.closePath();\n  //     ctx.restore();\n  // }\n\n  /**\n   * Draw the path element for the diagram\\\n   *\n   *  @returns {void}  Draw the path element for the diagram .\\\n   *\n   *  @param { SVGElement} canvas - Provide the SVG element .\n   *  @param { PathAttributes} options - Provide the path element attributes .\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.drawPath = function (canvas, options) {\n    var collection = [];\n    collection = processPathData(options.data);\n    collection = pathSegmentCollection(collection);\n\n    if (options.shadow) {\n      this.renderShadow(options, canvas, collection);\n    }\n\n    var ctx = CanvasRenderer.getContext(canvas);\n    ctx.save();\n    ctx.beginPath();\n    var pivotY = options.y + options.height * options.pivotY;\n    var pivotX = options.x + options.width * options.pivotX;\n\n    if (options.flip === 'Horizontal' || options.flip === 'Vertical') {\n      ctx.translate(options.x + options.width / 2, options.y + options.height / 2);\n      ctx.rotate(-options.angle * Math.PI / 180);\n      ctx.translate(-options.x - options.width / 2, -options.y - options.height / 2);\n    } else {\n      this.rotateContext(canvas, options.angle, pivotX, pivotY);\n    }\n\n    this.setStyle(canvas, options);\n    ctx.translate(options.x, options.y);\n\n    if (options.flip === 'Horizontal') {\n      ctx.scale(-1, 1);\n      ctx.translate(options.width * -1, 0);\n    } else if (options.flip === 'Vertical') {\n      ctx.scale(1, -1);\n      ctx.translate(0, options.height * -1);\n    } else if (options.flip === 'Both') {\n      ctx.scale(-1, -1);\n      ctx.translate(options.width * -1, options.height * -1);\n    }\n\n    this.renderPath(canvas, options, collection);\n    ctx.fill();\n    ctx.translate(-options.x, -options.y);\n    ctx.stroke();\n    ctx.restore();\n  };\n  /**\n   * Draw the path element for the diagram\\\n   *\n   *  @returns {void}  Draw the path element for the diagram .\\\n   *\n   *  @param { SVGElement} canvas - Provide the SVG element .\n   *  @param {PathAttributes} options - Provide the path element attributes .\n   *  @param {Object[]} collection - Provide the parent SVG element .\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.renderPath = function (canvas, options, collection) {\n    if (options.visible === true) {\n      var ctx = CanvasRenderer.getContext(canvas);\n      var x0 = void 0;\n      var y0 = void 0;\n      var x1 = void 0;\n      var y1 = void 0;\n      var x2 = void 0;\n      var y2 = void 0;\n      var x = void 0;\n      var y = void 0;\n      var length_1;\n      var i = void 0;\n      var segs = collection;\n\n      for (x = 0, y = 0, i = 0, length_1 = segs.length; i < length_1; ++i) {\n        var obj = segs[i];\n        var seg = obj;\n        var char = seg.command;\n\n        if ('x1' in seg) {\n          x1 = seg.x1;\n        }\n\n        if ('x2' in seg) {\n          x2 = seg.x2;\n        }\n\n        if ('y1' in seg) {\n          y1 = seg.y1;\n        }\n\n        if ('y2' in seg) {\n          y2 = seg.y2;\n        }\n\n        if ('x' in seg) {\n          x = seg.x;\n        }\n\n        if ('y' in seg) {\n          y = seg.y;\n        }\n\n        switch (char) {\n          case 'M':\n            ctx.moveTo(x, y);\n            seg.x = x;\n            seg.y = y;\n            break;\n\n          case 'L':\n            ctx.lineTo(x, y);\n            seg.x = x;\n            seg.y = y;\n            break;\n\n          case 'C':\n            ctx.bezierCurveTo(x1, y1, x2, y2, x, y);\n            seg.x = x;\n            seg.y = y;\n            seg.x1 = x1;\n            seg.y1 = y1;\n            seg.x2 = x2;\n            seg.y2 = y2;\n            break;\n\n          case 'Q':\n            ctx.quadraticCurveTo(x1, y1, x, y);\n            seg.x = x;\n            seg.y = y;\n            seg.x1 = x1;\n            seg.y1 = y1;\n            break;\n\n          case 'A':\n            // eslint-disable-next-line\n            var curr = {\n              x: x0,\n              y: y0\n            };\n            var rx = seg.r1;\n            var ry = seg.r2;\n            var xAxisRotation = seg.angle * (Math.PI / 180.0);\n            var largeArc = seg.largeArc;\n            var sweep = seg.sweep;\n            var cp = {\n              x: x,\n              y: y\n            };\n            var currp = {\n              x: Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,\n              y: -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0\n            };\n            var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);\n\n            if (l > 1) {\n              rx *= Math.sqrt(l);\n              ry *= Math.sqrt(l);\n            }\n\n            var k = Math.pow(ry, 2) * Math.pow(currp.x, 2);\n            var s = (largeArc === sweep ? -1 : 1) * Math.sqrt((Math.pow(rx, 2) * Math.pow(ry, 2) - Math.pow(rx, 2) * Math.pow(currp.y, 2) - k) / (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));\n\n            if (isNaN(s)) {\n              s = 0;\n            }\n\n            var cpp = {\n              x: s * rx * currp.y / ry,\n              y: s * -ry * currp.x / rx\n            };\n            var centp = {\n              x: (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,\n              y: (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y\n            };\n            var a1 = this.a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);\n            var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];\n            var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];\n            var ad = this.a(u, v);\n\n            if (this.r(u, v) <= -1) {\n              ad = Math.PI;\n            }\n\n            if (this.r(u, v) >= 1) {\n              ad = 0;\n            }\n\n            var dir = !sweep ? -1.0 : 1.0;\n            var ah = a1 + dir * (ad / 2.0); // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n            var halfWay = {\n              x: centp.x + rx * Math.cos(ah),\n              y: centp.y + ry * Math.sin(ah)\n            };\n            seg.centp = centp;\n            seg.xAxisRotation = xAxisRotation;\n            seg.rx = rx;\n            seg.ry = ry;\n            seg.a1 = a1;\n            seg.ad = ad;\n            seg.sweep = sweep;\n\n            if (ctx != null) {\n              var ra = rx > ry ? rx : ry;\n              var sx = rx > ry ? 1 : rx / ry;\n              var sy = rx > ry ? ry / rx : 1;\n              ctx.save();\n              ctx.translate(centp.x, centp.y);\n              ctx.rotate(xAxisRotation);\n              ctx.scale(sx, sy);\n              ctx.arc(0, 0, ra, a1, a1 + ad, !sweep);\n              ctx.scale(1 / sx, 1 / sy);\n              ctx.rotate(-xAxisRotation);\n              ctx.translate(-centp.x, -centp.y);\n              ctx.restore();\n            }\n\n            break;\n\n          case 'Z':\n          case 'z':\n            ctx.closePath();\n            x = x0;\n            y = y0;\n            break;\n        }\n\n        x0 = x;\n        y0 = y;\n      }\n    }\n  };\n  /**\n   * Draw the text element for the diagram\\\n   *\n   *  @returns {void}  Draw the text element for the diagram .\\\n   *\n   *  @param { SVGElement} canvas - Provide the SVG element .\n   *  @param {TextAttributes} options - Provide the text element attributes .\n   *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .\n   *  @param {Object} ariaLabel - Provide the label properties .\n   *  @param {string} diagramId - Provide the diagram id .\n   *  @param {number} scaleValue - Provide the scale value .\n   *  @param {Container} parentNode - Provide the parent node .\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.drawText = function (canvas, options, parentSvg, ariaLabel, diagramId, scaleValue, parentNode) {\n    if (options.content && options.visible === true) {\n      var ctx = CanvasRenderer.getContext(canvas);\n      ctx.save();\n      this.setStyle(canvas, options);\n\n      if (scaleValue) {\n        options.fontSize *= scaleValue;\n      }\n\n      var pivotX = options.x + options.width * options.pivotX;\n      var pivotY = options.y + options.height * options.pivotY;\n      this.rotateContext(canvas, options.angle, pivotX, pivotY);\n      this.setFontStyle(canvas, options);\n      var i = 0;\n      var childNodes = [];\n      childNodes = options.childNodes;\n      var wrapBounds = options.wrapBounds;\n      ctx.fillStyle = options.color;\n\n      if (wrapBounds) {\n        var position = this.labelAlign(options, wrapBounds, childNodes);\n\n        for (i = 0; i < childNodes.length; i++) {\n          var child = childNodes[i];\n          child.x = setChildPosition(child, childNodes, i, options);\n          var offsetX = position.x + (scaleValue ? child.x * scaleValue : child.x) - wrapBounds.x;\n          var offsetY = position.y + (scaleValue ? child.dy * scaleValue : child.dy) * i + options.fontSize * 0.8;\n\n          if (wrapBounds.width > options.width && options.textOverflow !== 'Wrap' && options.textWrapping === 'NoWrap') {\n            child.text = overFlow(child.text, options);\n          }\n\n          if ((options.textOverflow === 'Clip' || options.textOverflow === 'Ellipsis') && options.textWrapping === 'Wrap') {\n            if (offsetY < parentNode.actualSize.height + parentNode.bounds.y) {\n              if (options.textOverflow === 'Ellipsis' && childNodes[i + 1]) {\n                var temp = childNodes[i + 1];\n                var y = position.y + temp.dy * (i + 1) + options.fontSize * 0.8;\n\n                if (y > parentNode.actualSize.height + parentNode.bounds.y) {\n                  child.text = child.text.slice(0, child.text.length - 3);\n                  child.text = child.text.concat('...');\n                }\n              }\n\n              ctx.fillText(child.text, offsetX, offsetY);\n            }\n          } else {\n            ctx.fillText(child.text, offsetX, offsetY);\n          }\n\n          if (options.textDecoration === 'Underline' || options.textDecoration === 'Overline' || options.textDecoration === 'LineThrough') {\n            var startPointX = offsetX;\n            var startPointY = void 0;\n            var textlength = ctx.measureText(child.text).width;\n            var endPointX = offsetX + textlength;\n            var endPointY = void 0;\n\n            switch (options.textDecoration) {\n              case 'Underline':\n                startPointY = offsetY + 2;\n                endPointY = offsetY + 2;\n                break;\n\n              case 'Overline':\n                startPointY = position.y + child.dy * i;\n                endPointY = position.y + child.dy * i;\n                break;\n\n              case 'LineThrough':\n                startPointY = (offsetY + position.y + child.dy * i) / 2 + 2;\n                endPointY = (offsetY + position.y + child.dy * i) / 2 + 2;\n            }\n\n            ctx.beginPath();\n            ctx.moveTo(startPointX, startPointY);\n            ctx.lineTo(endPointX, endPointY);\n            ctx.strokeStyle = options.color;\n            ctx.lineWidth = options.fontSize * .08;\n            ctx.globalAlpha = options.opacity;\n            ctx.stroke();\n          }\n        }\n      }\n\n      ctx.restore();\n    }\n  };\n\n  CanvasRenderer.prototype.loadImage = function (ctx, obj, canvas, pivotX, pivotY) {\n    this.rotateContext(canvas, obj.angle, pivotX, pivotY);\n    var image = new Image();\n    image.src = obj.source;\n    this.image(ctx, image, obj.x, obj.y, obj.width, obj.height, obj);\n  };\n  /**\n   * Draw the image element for the diagram\\\n   *\n   *  @returns {void} Draw the image element for the diagram .\n   *  @param { SVGElement | HTMLCanvasElement} canvas - Provide the SVG element .\n   *  @param {ImageAttributes} obj - Provide the image attributes .\n   *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .\n   *  @param {boolean} fromPalette - Provide the pointer event value .\n   *  @private\n   */\n\n\n  CanvasRenderer.prototype.drawImage = function (canvas, obj, parentSvg, fromPalette) {\n    var _this = this;\n\n    if (obj.visible) {\n      var ctx_1 = CanvasRenderer.getContext(canvas);\n      ctx_1.save();\n      var pivotX_1 = obj.x + obj.width * obj.pivotX;\n      var pivotY_1 = obj.y + obj.height * obj.pivotY;\n      var imageObj = new Image();\n      imageObj.src = obj.source;\n      var id = ctx_1.canvas.id.split('_'); // eslint-disable-next-line\n\n      var value = id[id.length - 1] === ('diagram' || 'diagramLayer') ? true : false; // eslint-disable-next-line\n\n      /**\n       *  Since Clipping portion for node with slice option is not calculated properly\n       * if (obj.sourceX !== undefined && obj.sourceY !== undefined && obj.sourceWidth !== undefined\n       *  && obj.sourceHeight !== undefined) {\n       *  ctx.drawImage(imageObj, obj.sourceX, obj.sourceY, obj.sourceWidth, obj.sourceHeight, obj.x, obj.y, obj.width, obj.height);\n       *  } else {\n       *             ctx.drawImage(imageObj, obj.x, obj.y, obj.width, obj.height);\n       * }\n       */\n\n      if (!fromPalette) {\n        this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);\n      } else {\n        imageObj.onload = function () {\n          _this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);\n        };\n      }\n\n      ctx_1.restore();\n    }\n  };\n\n  CanvasRenderer.prototype.image = function (ctx, image, x, y, width, height, alignOptions) {\n    ctx.beginPath();\n    var srcWidth = image.width;\n    var srcHeight = image.height;\n    var destinationW = width;\n    var destinationH = height;\n    var resultWidth = 0;\n    var resultHeight = 0;\n\n    if (alignOptions && alignOptions.alignment !== 'None') {\n      var xalign = alignOptions.alignment.toLowerCase().substr(1, 3);\n      var yalign = alignOptions.alignment.toLowerCase().substr(5, 3);\n\n      if (alignOptions.scale === 'Slice') {\n        // eslint-disable-next-line\n        var a = function () {\n          resultWidth = destinationW;\n          resultHeight = srcHeight * destinationW / srcWidth;\n        }; // eslint-disable-next-line\n\n\n        var b = function () {\n          resultWidth = srcWidth * destinationH / srcHeight;\n          resultHeight = destinationH;\n        };\n\n        if (destinationW > destinationH) {\n          a();\n\n          if (destinationH > resultHeight) {\n            b();\n          }\n        } else if (destinationW === destinationH) {\n          if (srcWidth > srcHeight) {\n            b();\n          } else {\n            a();\n          }\n        } else {\n          b();\n\n          if (destinationW > resultWidth) {\n            a();\n          }\n        }\n\n        var x1 = this.getSliceOffset(xalign, resultWidth, destinationW, srcWidth);\n        var y1 = this.getSliceOffset(yalign, resultHeight, destinationH, srcHeight);\n        var sWidth = srcWidth - x1;\n        var sHeight = srcHeight - y1;\n        var dWidth = resultWidth - x1 * (resultWidth / srcWidth);\n        var dHeight = resultHeight - y1 * (resultHeight / srcHeight);\n        var canvas1 = createHtmlElement('canvas', {\n          'width': width.toString(),\n          'height': height.toString()\n        });\n        var ctx1 = canvas1.getContext('2d');\n        ctx1.drawImage(image, x1, y1, sWidth, sHeight, 0, 0, dWidth, dHeight);\n        ctx.drawImage(canvas1, x, y, width, height);\n      } else if (alignOptions.scale === 'Meet') {\n        var srcRatio = srcHeight / srcWidth;\n        var destRatio = destinationH / destinationW;\n        resultWidth = destRatio > srcRatio ? destinationW : destinationH / srcRatio;\n        resultHeight = destRatio > srcRatio ? destinationW * srcRatio : destinationH;\n        x += this.getMeetOffset(xalign, resultWidth, destinationW);\n        y += this.getMeetOffset(yalign, resultHeight, destinationH);\n        ctx.drawImage(image, 0, 0, srcWidth, srcHeight, x, y, resultWidth, resultHeight);\n      } else {\n        ctx.drawImage(image, x, y, width, height);\n      }\n    } else if (alignOptions.flip !== 'None') {\n      var scaleX = 1;\n      var scaleY = 1;\n\n      if (alignOptions.flip === 'Horizontal' || alignOptions.flip === 'Both') {\n        x = -x;\n        width = -width;\n        scaleX = -1;\n      }\n\n      if (alignOptions.flip === 'Vertical' || alignOptions.flip === 'Both') {\n        y = -y;\n        height = -height;\n        scaleY = -1;\n      }\n\n      ctx.scale(scaleX, scaleY);\n      ctx.drawImage(image, x, y, width, height);\n    } else {\n      ctx.drawImage(image, x, y, width, height);\n    }\n\n    ctx.closePath();\n  };\n\n  CanvasRenderer.prototype.getSliceOffset = function (arg, res, dest, src) {\n    switch (arg) {\n      case 'min':\n        return 0;\n\n      case 'mid':\n        return (res - dest) / 2 * src / res;\n\n      case 'max':\n        return (res - dest) * src / res;\n\n      default:\n        return 0;\n    }\n  };\n\n  CanvasRenderer.prototype.getMeetOffset = function (arg, res, dest) {\n    var max = Math.max(res, dest);\n    var min = Math.min(res, dest);\n\n    switch (arg) {\n      case 'min':\n        return 0;\n\n      case 'mid':\n        return (max - min) / 2;\n\n      case 'max':\n        return max - min;\n\n      default:\n        return 0;\n    }\n  }; //end region\n  // vector magnitude\n\n\n  CanvasRenderer.prototype.m = function (v) {\n    return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2));\n  }; // ratio between two vectors\n\n\n  CanvasRenderer.prototype.r = function (u, v) {\n    return (u[0] * v[0] + u[1] * v[1]) / (this.m(u) * this.m(v));\n  }; // angle between two vectors\n\n\n  CanvasRenderer.prototype.a = function (u, v) {\n    return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(this.r(u, v));\n  }; // text utility\n\n  /**\n   * Draw the SVG label.\\\n   *\n   * @returns {PointModel} Draw the SVG label .\n   *  @param {TextAttributes} text - Provide the canvas element .\n   *  @param {Object} wrapBounds - Provide the canvas element .\n   *  @param {SubTextElement []} childNodes - Provide the canvas element .\n   * @private\n   */\n\n\n  CanvasRenderer.prototype.labelAlign = function (text, wrapBounds, childNodes) {\n    var bounds = new Size(wrapBounds.width, childNodes.length * (text.fontSize * 1.2));\n    var position = {\n      x: 0,\n      y: 0\n    };\n    var labelX = text.x;\n    var labelY = text.y;\n    var offsetx = text.width * 0.5;\n    var offsety = text.height * 0.5;\n    var pointx = offsetx;\n    var pointy = offsety;\n\n    if (text.textAlign === 'left') {\n      pointx = 0;\n    } else if (text.textAlign === 'center') {\n      if (wrapBounds.width > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {\n        if (text.textWrapping === 'NoWrap') {\n          pointx = 0;\n        } else {\n          pointx = text.width * 0.5;\n        }\n      } else {\n        pointx = text.width * 0.5;\n      }\n    } else if (text.textAlign === 'right') {\n      pointx = text.width * 1;\n    }\n\n    position.x = labelX + pointx + (wrapBounds ? wrapBounds.x : 0);\n    position.y = labelY + pointy - bounds.height / 2;\n    return position;\n  };\n\n  return CanvasRenderer;\n}();\n\nexport { CanvasRenderer };","map":{"version":3,"sources":["/Users/sergeismogliuk/Documents/Project/Project_node/Diplom/react-diplom/react-diplom/node_modules/@syncfusion/ej2-diagrams/src/diagram/rendering/canvas-renderer.js"],"names":["Size","Point","processPathData","pathSegmentCollection","getRectanglePath","overFlow","createHtmlElement","setChildPosition","CanvasRenderer","getContext","canvas","setCanvasSize","width","height","setAttribute","toString","prototype","renderGradient","options","ctx","x","y","max","min","grd","gradient","type","i","stops","length","undefined","offset","Math","linear","createLinearGradient","x1","y1","x2","y2","radial","createRadialGradient","fx","fy","cx","cy","r","stop_1","addColorStop","color","fillStyle","renderShadow","collection","save","beginPath","strokeStyle","shadow","globalAlpha","opacity","ptModel","point","transform","angle","distance","transX","transY","pivotX","pivotY","rotateContext","translate","renderPath","rect","fillRect","fill","stroke","closePath","restore","createCanvas","id","canvasObj","setStyle","style","lineWidth","strokeWidth","dashArray","parseDashArray","setLineDash","rotate","PI","setFontStyle","text","font","italic","bold","fontSize","fontFamily","dashes","separator","indexOf","splittedDashes","split","_i","splittedDashes_1","push","Number","drawRoundedRect","context","w","h","mx","my","moveTo","quadraticCurveTo","drawRectangle","visible","cornerRadius","data","drawPath","flip","scale","x0","y0","length_1","segs","obj","seg","char","command","lineTo","bezierCurveTo","curr","rx","r1","ry","r2","xAxisRotation","largeArc","sweep","cp","currp","cos","sin","l","pow","sqrt","k","s","isNaN","cpp","centp","a1","a","u","v","ad","dir","ah","halfWay","ra","sx","sy","arc","drawText","parentSvg","ariaLabel","diagramId","scaleValue","parentNode","content","childNodes","wrapBounds","position","labelAlign","child","offsetX","offsetY","dy","textOverflow","textWrapping","actualSize","bounds","temp","slice","concat","fillText","textDecoration","startPointX","startPointY","textlength","measureText","endPointX","endPointY","loadImage","image","Image","src","source","drawImage","fromPalette","_this","ctx_1","pivotX_1","pivotY_1","imageObj","value","onload","alignOptions","srcWidth","srcHeight","destinationW","destinationH","resultWidth","resultHeight","alignment","xalign","toLowerCase","substr","yalign","b","getSliceOffset","sWidth","sHeight","dWidth","dHeight","canvas1","ctx1","srcRatio","destRatio","getMeetOffset","scaleX","scaleY","arg","res","dest","m","acos","labelX","labelY","offsetx","offsety","pointx","pointy","textAlign"],"mappings":"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","sourcesContent":["/* eslint-disable no-case-declarations */\n/* eslint-disable @typescript-eslint/indent */\nimport { Size } from './../primitives/size';\nimport { Point } from './../primitives/point';\nimport { processPathData, pathSegmentCollection, getRectanglePath } from './../utility/path-util';\nimport { overFlow } from './../utility/base-util';\nimport { createHtmlElement, setChildPosition } from './../utility/dom-util';\n/**\n * Canvas Renderer\n */\n/** @private */\nvar CanvasRenderer = /** @class */ (function () {\n    function CanvasRenderer() {\n    }\n    /**\n     * Provide the context value for the canvas \\\n     *\n     *  @returns {CanvasRenderingContext2D} Provide the context value for the canvas .\\\n     *  @param { HTMLCanvasElement} canvas - Return the dashed array values .\n     *  @private\n     */\n    CanvasRenderer.getContext = function (canvas) {\n        return canvas.getContext('2d');\n    };\n    CanvasRenderer.setCanvasSize = function (canvas, width, height) {\n        if (canvas) {\n            canvas.setAttribute('width', width.toString());\n            canvas.setAttribute('height', height.toString());\n        }\n    };\n    /**\n     * Draw the gradient for the diagram shapes .\\\n     *\n     *  @returns {SVGElement} Draw the gradient for the diagram shapes.\n     *  @param {StyleAttributes} options - Provide the options  for the gradient  element .\n     *  @param {SVGElement} ctx - Provide canvas values .\n     *  @param {string} x - Provide the x value for the gradient .\n     *  @param {string} y - Provide the x value for the gradient .\n     *  @private\n     */\n    CanvasRenderer.prototype.renderGradient = function (options, ctx, x, y) {\n        var max;\n        var min;\n        var grd;\n        if (options.gradient.type !== 'None') {\n            for (var i = 0; i < options.gradient.stops.length; i++) {\n                max = max !== undefined ? options.gradient.stops[i].offset : Math.max(max, options.gradient.stops[i].offset);\n                min = min !== undefined ? options.gradient.stops[i].offset : Math.min(min, options.gradient.stops[i].offset);\n            }\n            if (options.gradient.type === 'Linear') {\n                var linear = options.gradient;\n                grd = ctx.createLinearGradient(x + linear.x1, y + linear.y1, x + linear.x2, y + linear.y2);\n            }\n            else {\n                var radial = options.gradient;\n                grd = ctx.createRadialGradient(x + radial.fx, y + radial.fy, 0, x + radial.cx, y + radial.cy, radial.r);\n            }\n            for (var i = 0; i < options.gradient.stops.length; i++) {\n                var stop_1 = options.gradient.stops[i];\n                var offset = min < 0 ? (max + stop_1.offset) / (2 * max) : stop_1.offset / max;\n                grd.addColorStop(offset, stop_1.color);\n            }\n            ctx.fillStyle = grd;\n        }\n        return ctx;\n    };\n    /**\n     * Draw the shawdow  for the rectangle shape in diagram \\\n     *\n     *  @returns {void}  Draw the shawdow  for the rectangle shape in diagram .\\\n     *\n     *  @param { SVGElement} options - Provide the base attributes .\n     *  @param { RectAttributes} canvas - Provide the canvas values .\n     *  @param { string} collection - Provide the collection value.\n     *  @private\n     */\n    CanvasRenderer.prototype.renderShadow = function (options, canvas, collection) {\n        if (collection === void 0) { collection = null; }\n        var ctx = CanvasRenderer.getContext(canvas);\n        ctx.save();\n        ctx.beginPath();\n        ctx.strokeStyle = ctx.fillStyle = options.shadow.color;\n        ctx.globalAlpha = options.shadow.opacity;\n        var ptModel = { x: 0, y: 0 };\n        var point = Point.transform(ptModel, options.shadow.angle, options.shadow.distance);\n        var transX = options.x + point.x;\n        var transY = options.y + point.y;\n        var pivotX = transX + options.width * options.pivotX;\n        var pivotY = transY + options.height * options.pivotY;\n        this.rotateContext(canvas, options.angle, pivotX, pivotY);\n        if (collection) {\n            ctx.translate(transX, transY);\n            this.renderPath(canvas, options, collection);\n            ctx.translate(-transX, -transY);\n        }\n        else {\n            ctx.rect(transX, transY, options.width, options.height);\n            ctx.fillRect(transX, transY, options.width, options.height);\n        }\n        ctx.fill();\n        ctx.stroke();\n        ctx.closePath();\n        ctx.restore();\n    };\n    /**\n     * Create canvas element for the diagram \\\n     *\n     *  @returns {HTMLCanvasElement}    Create canvas element for the diagram .\\\n     *\n     *  @param { SVGElement} id - Provide the id for the canvas.\n     *  @param { Object} width - Provide the width for the canvas.\n     *  @param { Object} height - Provide the height for the canvas.\n     *  @private\n     */\n    CanvasRenderer.createCanvas = function (id, width, height) {\n        var canvasObj = createHtmlElement('canvas', { 'id': id });\n        this.setCanvasSize(canvasObj, width, height);\n        return canvasObj;\n    };\n    CanvasRenderer.prototype.setStyle = function (canvas, style) {\n        var ctx = CanvasRenderer.getContext(canvas);\n        if (style.fill === 'none') {\n            style.fill = 'transparent';\n        }\n        if (style.stroke === 'none') {\n            style.stroke = 'transparent';\n        }\n        ctx.strokeStyle = style.stroke;\n        ctx.lineWidth = style.strokeWidth;\n        if (style.strokeWidth === 0) {\n            ctx.strokeStyle = 'transparent';\n        }\n        ctx.globalAlpha = style.opacity;\n        var dashArray = [];\n        if (style.dashArray) {\n            dashArray = this.parseDashArray(style.dashArray);\n        }\n        ctx.setLineDash(dashArray);\n        if (style.gradient && style.gradient.type !== 'None') {\n            this.renderGradient(style, ctx, style.x, style.y);\n        }\n        else {\n            ctx.fillStyle = style.fill;\n        }\n    };\n    CanvasRenderer.prototype.rotateContext = function (canvas, angle, x, y) {\n        var ctx = CanvasRenderer.getContext(canvas);\n        ctx.translate(x, y);\n        ctx.rotate(angle * Math.PI / 180);\n        ctx.translate(-x, -y);\n    };\n    CanvasRenderer.prototype.setFontStyle = function (canvas, text) {\n        var ctx = CanvasRenderer.getContext(canvas);\n        var font = '';\n        if (text.italic) {\n            font += 'italic ';\n        }\n        if (text.bold) {\n            font += 'bold ';\n        }\n        font += (text.fontSize) + 'px ';\n        font += text.fontFamily;\n        ctx.font = font;\n    };\n    /**\n     * Return the dashed array values \\\n     *\n     *  @returns {number[]}  Return the dashed array values .\\\n     *  @param { SVGElement} dashArray - Return the dashed array values .\n     *  @private\n     */\n    CanvasRenderer.prototype.parseDashArray = function (dashArray) {\n        var dashes = [];\n        var separator = dashArray.indexOf(' ') !== -1 ? ' ' : ',';\n        var splittedDashes = dashArray.split(separator);\n        for (var _i = 0, splittedDashes_1 = splittedDashes; _i < splittedDashes_1.length; _i++) {\n            var i = splittedDashes_1[_i];\n            dashes.push(Number(i));\n        }\n        return dashes;\n    };\n    CanvasRenderer.prototype.drawRoundedRect = function (canvas, options) {\n        var context = CanvasRenderer.getContext(canvas);\n        context.beginPath();\n        var x = options.x;\n        var y = options.y;\n        var w = options.width;\n        var h = options.height;\n        var mx = x + w / 2;\n        var my = y + h / 2;\n        context.beginPath();\n        this.setStyle(canvas, options);\n        context.moveTo(x, my);\n        context.quadraticCurveTo(x, y, mx, y);\n        context.quadraticCurveTo(x + w, y, x + w, my);\n        context.quadraticCurveTo(x + w, y + h, mx, y + h);\n        context.quadraticCurveTo(x, y + h, x, my);\n        context.stroke();\n    };\n    //Rendering Part\n    /**\n     * Draw the Rectangle for the diagram \\\n     *\n     *  @returns {void}  Draw the Rectangle for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG .\n     *  @param { RectAttributes} options - Provide the Rect attributes .\n     *  @private\n     */\n    CanvasRenderer.prototype.drawRectangle = function (canvas, options) {\n        if (options.visible === true) {\n            if (options.cornerRadius) {\n                if (options.width < 30 || options.height < 30) {\n                    this.drawRoundedRect(canvas, options);\n                }\n                else {\n                    options.data = getRectanglePath(options.cornerRadius, options.height, options.width);\n                    this.drawPath(canvas, options);\n                }\n            }\n            else {\n                var ctx = CanvasRenderer.getContext(canvas);\n                if (options.shadow) {\n                    this.renderShadow(options, canvas);\n                }\n                ctx.save();\n                ctx.beginPath();\n                // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                var cornerRadius = options.cornerRadius;\n                var pivotX = options.x + options.width * options.pivotX;\n                var pivotY = options.y + options.height * options.pivotY;\n                this.rotateContext(canvas, options.angle, pivotX, pivotY);\n                this.setStyle(canvas, options);\n                ctx.rect(options.x, options.y, options.width, options.height);\n                ctx.fillRect(options.x, options.y, options.width, options.height);\n                ctx.fill();\n                ctx.stroke();\n                ctx.closePath();\n                ctx.restore();\n            }\n        }\n    };\n    // public updateSelectionRegion(canvas: HTMLCanvasElement, options: RectAttributes): void {\n    //     this.drawRectangle(canvas, options);\n    // }\n    // public drawLine(canvas: HTMLCanvasElement, options: LineAttributes): void {\n    //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);\n    //     ctx.save();\n    //     ctx.beginPath();\n    //     let pivotX: number = options.x + options.width * options.pivotX;\n    //     let pivotY: number = options.y + options.height * options.pivotY;\n    //     this.rotateContext(canvas, options.angle, pivotX, pivotY);\n    //     this.setStyle(canvas, options as StyleAttributes);\n    //     ctx.translate(options.x, options.y);\n    //     ctx.moveTo(options.startPoint.x, options.startPoint.y);\n    //     ctx.lineTo(options.endPoint.x, options.endPoint.y);\n    //     ctx.translate(-options.x, -options.y);\n    //     ctx.stroke();\n    //     ctx.closePath();\n    //     ctx.restore();\n    // }\n    // public drawCircle(canvas: HTMLCanvasElement, options: CircleAttributes): void {\n    //     let ctx: CanvasRenderingContext2D = CanvasRenderer.getContext(canvas);\n    //     ctx.save();\n    //     ctx.beginPath();\n    //     let pivotY: number = options.y + options.height * options.pivotY;\n    //     let pivotX: number = options.x + options.width * options.pivotX;\n    //     this.setStyle(canvas, options as StyleAttributes);\n    //     this.rotateContext(canvas, options.angle, pivotX, pivotY);\n    //     ctx.arc(options.centerX, options.centerY, options.radius, 0, 2 * Math.PI);\n    //     ctx.fill();\n    //     ctx.stroke();\n    //     ctx.closePath();\n    //     ctx.restore();\n    // }\n    /**\n     * Draw the path element for the diagram\\\n     *\n     *  @returns {void}  Draw the path element for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG element .\n     *  @param { PathAttributes} options - Provide the path element attributes .\n     *  @private\n     */\n    CanvasRenderer.prototype.drawPath = function (canvas, options) {\n        var collection = [];\n        collection = processPathData(options.data);\n        collection = pathSegmentCollection(collection);\n        if (options.shadow) {\n            this.renderShadow(options, canvas, collection);\n        }\n        var ctx = CanvasRenderer.getContext(canvas);\n        ctx.save();\n        ctx.beginPath();\n        var pivotY = options.y + options.height * options.pivotY;\n        var pivotX = options.x + options.width * options.pivotX;\n        if (options.flip === 'Horizontal' || options.flip === 'Vertical') {\n            ctx.translate(options.x + options.width / 2, options.y + options.height / 2);\n            ctx.rotate(-options.angle * Math.PI / 180);\n            ctx.translate(-options.x - options.width / 2, -options.y - options.height / 2);\n        }\n        else {\n            this.rotateContext(canvas, options.angle, pivotX, pivotY);\n        }\n        this.setStyle(canvas, options);\n        ctx.translate(options.x, options.y);\n        if (options.flip === 'Horizontal') {\n            ctx.scale(-1, 1);\n            ctx.translate(options.width * -1, 0);\n        }\n        else if (options.flip === 'Vertical') {\n            ctx.scale(1, -1);\n            ctx.translate(0, options.height * -1);\n        }\n        else if (options.flip === 'Both') {\n            ctx.scale(-1, -1);\n            ctx.translate(options.width * -1, options.height * -1);\n        }\n        this.renderPath(canvas, options, collection);\n        ctx.fill();\n        ctx.translate(-options.x, -options.y);\n        ctx.stroke();\n        ctx.restore();\n    };\n    /**\n     * Draw the path element for the diagram\\\n     *\n     *  @returns {void}  Draw the path element for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG element .\n     *  @param {PathAttributes} options - Provide the path element attributes .\n     *  @param {Object[]} collection - Provide the parent SVG element .\n     *  @private\n     */\n    CanvasRenderer.prototype.renderPath = function (canvas, options, collection) {\n        if (options.visible === true) {\n            var ctx = CanvasRenderer.getContext(canvas);\n            var x0 = void 0;\n            var y0 = void 0;\n            var x1 = void 0;\n            var y1 = void 0;\n            var x2 = void 0;\n            var y2 = void 0;\n            var x = void 0;\n            var y = void 0;\n            var length_1;\n            var i = void 0;\n            var segs = collection;\n            for (x = 0, y = 0, i = 0, length_1 = segs.length; i < length_1; ++i) {\n                var obj = segs[i];\n                var seg = obj;\n                var char = seg.command;\n                if ('x1' in seg) {\n                    x1 = seg.x1;\n                }\n                if ('x2' in seg) {\n                    x2 = seg.x2;\n                }\n                if ('y1' in seg) {\n                    y1 = seg.y1;\n                }\n                if ('y2' in seg) {\n                    y2 = seg.y2;\n                }\n                if ('x' in seg) {\n                    x = seg.x;\n                }\n                if ('y' in seg) {\n                    y = seg.y;\n                }\n                switch (char) {\n                    case 'M':\n                        ctx.moveTo(x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        break;\n                    case 'L':\n                        ctx.lineTo(x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        break;\n                    case 'C':\n                        ctx.bezierCurveTo(x1, y1, x2, y2, x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        seg.x1 = x1;\n                        seg.y1 = y1;\n                        seg.x2 = x2;\n                        seg.y2 = y2;\n                        break;\n                    case 'Q':\n                        ctx.quadraticCurveTo(x1, y1, x, y);\n                        seg.x = x;\n                        seg.y = y;\n                        seg.x1 = x1;\n                        seg.y1 = y1;\n                        break;\n                    case 'A':\n                        // eslint-disable-next-line\n                        var curr = { x: x0, y: y0 };\n                        var rx = seg.r1;\n                        var ry = seg.r2;\n                        var xAxisRotation = seg.angle * (Math.PI / 180.0);\n                        var largeArc = seg.largeArc;\n                        var sweep = seg.sweep;\n                        var cp = { x: x, y: y };\n                        var currp = {\n                            x: Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0,\n                            y: -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0\n                        };\n                        var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);\n                        if (l > 1) {\n                            rx *= Math.sqrt(l);\n                            ry *= Math.sqrt(l);\n                        }\n                        var k = (Math.pow(ry, 2) * Math.pow(currp.x, 2));\n                        var s = (largeArc === sweep ? -1 : 1) * Math.sqrt(((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - k) /\n                            (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));\n                        if (isNaN(s)) {\n                            s = 0;\n                        }\n                        var cpp = { x: s * rx * currp.y / ry, y: s * -ry * currp.x / rx };\n                        var centp = {\n                            x: (curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y,\n                            y: (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y\n                        };\n                        var a1 = this.a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);\n                        var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];\n                        var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];\n                        var ad = this.a(u, v);\n                        if (this.r(u, v) <= -1) {\n                            ad = Math.PI;\n                        }\n                        if (this.r(u, v) >= 1) {\n                            ad = 0;\n                        }\n                        var dir = !sweep ? -1.0 : 1.0;\n                        var ah = a1 + dir * (ad / 2.0);\n                        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n                        var halfWay = {\n                            x: centp.x + rx * Math.cos(ah),\n                            y: centp.y + ry * Math.sin(ah)\n                        };\n                        seg.centp = centp;\n                        seg.xAxisRotation = xAxisRotation;\n                        seg.rx = rx;\n                        seg.ry = ry;\n                        seg.a1 = a1;\n                        seg.ad = ad;\n                        seg.sweep = sweep;\n                        if (ctx != null) {\n                            var ra = rx > ry ? rx : ry;\n                            var sx = rx > ry ? 1 : rx / ry;\n                            var sy = rx > ry ? ry / rx : 1;\n                            ctx.save();\n                            ctx.translate(centp.x, centp.y);\n                            ctx.rotate(xAxisRotation);\n                            ctx.scale(sx, sy);\n                            ctx.arc(0, 0, ra, a1, a1 + ad, !sweep);\n                            ctx.scale(1 / sx, 1 / sy);\n                            ctx.rotate(-xAxisRotation);\n                            ctx.translate(-centp.x, -centp.y);\n                            ctx.restore();\n                        }\n                        break;\n                    case 'Z':\n                    case 'z':\n                        ctx.closePath();\n                        x = x0;\n                        y = y0;\n                        break;\n                }\n                x0 = x;\n                y0 = y;\n            }\n        }\n    };\n    /**\n     * Draw the text element for the diagram\\\n     *\n     *  @returns {void}  Draw the text element for the diagram .\\\n     *\n     *  @param { SVGElement} canvas - Provide the SVG element .\n     *  @param {TextAttributes} options - Provide the text element attributes .\n     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .\n     *  @param {Object} ariaLabel - Provide the label properties .\n     *  @param {string} diagramId - Provide the diagram id .\n     *  @param {number} scaleValue - Provide the scale value .\n     *  @param {Container} parentNode - Provide the parent node .\n     *  @private\n     */\n    CanvasRenderer.prototype.drawText = function (canvas, options, parentSvg, ariaLabel, diagramId, scaleValue, parentNode) {\n        if (options.content && options.visible === true) {\n            var ctx = CanvasRenderer.getContext(canvas);\n            ctx.save();\n            this.setStyle(canvas, options);\n            if (scaleValue) {\n                options.fontSize *= scaleValue;\n            }\n            var pivotX = options.x + options.width * options.pivotX;\n            var pivotY = options.y + options.height * options.pivotY;\n            this.rotateContext(canvas, options.angle, pivotX, pivotY);\n            this.setFontStyle(canvas, options);\n            var i = 0;\n            var childNodes = [];\n            childNodes = options.childNodes;\n            var wrapBounds = options.wrapBounds;\n            ctx.fillStyle = options.color;\n            if (wrapBounds) {\n                var position = this.labelAlign(options, wrapBounds, childNodes);\n                for (i = 0; i < childNodes.length; i++) {\n                    var child = childNodes[i];\n                    child.x = setChildPosition(child, childNodes, i, options);\n                    var offsetX = position.x + (scaleValue ? child.x * scaleValue : child.x) - wrapBounds.x;\n                    var offsetY = position.y + (scaleValue ? child.dy * scaleValue : child.dy) * i + ((options.fontSize) * 0.8);\n                    if (wrapBounds.width > options.width && options.textOverflow !== 'Wrap' && options.textWrapping === 'NoWrap') {\n                        child.text = overFlow(child.text, options);\n                    }\n                    if ((options.textOverflow === 'Clip' || options.textOverflow === 'Ellipsis') && options.textWrapping === 'Wrap') {\n                        if (offsetY < parentNode.actualSize.height + parentNode.bounds.y) {\n                            if (options.textOverflow === 'Ellipsis' && childNodes[i + 1]) {\n                                var temp = childNodes[i + 1];\n                                var y = position.y + temp.dy * (i + 1) + ((options.fontSize) * 0.8);\n                                if (y > parentNode.actualSize.height + parentNode.bounds.y) {\n                                    child.text = child.text.slice(0, child.text.length - 3);\n                                    child.text = child.text.concat('...');\n                                }\n                            }\n                            ctx.fillText(child.text, offsetX, offsetY);\n                        }\n                    }\n                    else {\n                        ctx.fillText(child.text, offsetX, offsetY);\n                    }\n                    if (options.textDecoration === 'Underline'\n                        || options.textDecoration === 'Overline'\n                        || options.textDecoration === 'LineThrough') {\n                        var startPointX = offsetX;\n                        var startPointY = void 0;\n                        var textlength = ctx.measureText(child.text).width;\n                        var endPointX = offsetX + textlength;\n                        var endPointY = void 0;\n                        switch (options.textDecoration) {\n                            case 'Underline':\n                                startPointY = offsetY + 2;\n                                endPointY = offsetY + 2;\n                                break;\n                            case 'Overline':\n                                startPointY = (position.y + child.dy * i);\n                                endPointY = (position.y + child.dy * i);\n                                break;\n                            case 'LineThrough':\n                                startPointY = ((offsetY + position.y + child.dy * i) / 2) + 2;\n                                endPointY = ((offsetY + position.y + child.dy * i) / 2) + 2;\n                        }\n                        ctx.beginPath();\n                        ctx.moveTo(startPointX, startPointY);\n                        ctx.lineTo(endPointX, endPointY);\n                        ctx.strokeStyle = options.color;\n                        ctx.lineWidth = options.fontSize * .08;\n                        ctx.globalAlpha = options.opacity;\n                        ctx.stroke();\n                    }\n                }\n            }\n            ctx.restore();\n        }\n    };\n    CanvasRenderer.prototype.loadImage = function (ctx, obj, canvas, pivotX, pivotY) {\n        this.rotateContext(canvas, obj.angle, pivotX, pivotY);\n        var image = new Image();\n        image.src = obj.source;\n        this.image(ctx, image, obj.x, obj.y, obj.width, obj.height, obj);\n    };\n    /**\n     * Draw the image element for the diagram\\\n     *\n     *  @returns {void} Draw the image element for the diagram .\n     *  @param { SVGElement | HTMLCanvasElement} canvas - Provide the SVG element .\n     *  @param {ImageAttributes} obj - Provide the image attributes .\n     *  @param {SVGSVGElement} parentSvg - Provide the parent SVG element .\n     *  @param {boolean} fromPalette - Provide the pointer event value .\n     *  @private\n     */\n    CanvasRenderer.prototype.drawImage = function (canvas, obj, parentSvg, fromPalette) {\n        var _this = this;\n        if (obj.visible) {\n            var ctx_1 = CanvasRenderer.getContext(canvas);\n            ctx_1.save();\n            var pivotX_1 = obj.x + obj.width * obj.pivotX;\n            var pivotY_1 = obj.y + obj.height * obj.pivotY;\n            var imageObj = new Image();\n            imageObj.src = obj.source;\n            var id = ctx_1.canvas.id.split('_');\n            // eslint-disable-next-line\n            var value = id[id.length - 1] === ('diagram' || 'diagramLayer') ? true : false;\n            // eslint-disable-next-line\n            /**\n             *  Since Clipping portion for node with slice option is not calculated properly\n             * if (obj.sourceX !== undefined && obj.sourceY !== undefined && obj.sourceWidth !== undefined\n             *  && obj.sourceHeight !== undefined) {\n             *  ctx.drawImage(imageObj, obj.sourceX, obj.sourceY, obj.sourceWidth, obj.sourceHeight, obj.x, obj.y, obj.width, obj.height);\n             *  } else {\n             *             ctx.drawImage(imageObj, obj.x, obj.y, obj.width, obj.height);\n             * }\n             */\n            if (!fromPalette) {\n                this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);\n            }\n            else {\n                imageObj.onload = function () {\n                    _this.loadImage(ctx_1, obj, canvas, pivotX_1, pivotY_1);\n                };\n            }\n            ctx_1.restore();\n        }\n    };\n    CanvasRenderer.prototype.image = function (ctx, image, x, y, width, height, alignOptions) {\n        ctx.beginPath();\n        var srcWidth = image.width;\n        var srcHeight = image.height;\n        var destinationW = width;\n        var destinationH = height;\n        var resultWidth = 0;\n        var resultHeight = 0;\n        if (alignOptions && alignOptions.alignment !== 'None') {\n            var xalign = alignOptions.alignment.toLowerCase().substr(1, 3);\n            var yalign = alignOptions.alignment.toLowerCase().substr(5, 3);\n            if (alignOptions.scale === 'Slice') {\n                // eslint-disable-next-line\n                var a = function () {\n                    resultWidth = destinationW;\n                    resultHeight = srcHeight * destinationW / srcWidth;\n                };\n                // eslint-disable-next-line\n                var b = function () {\n                    resultWidth = srcWidth * destinationH / srcHeight;\n                    resultHeight = destinationH;\n                };\n                if (destinationW > destinationH) {\n                    a();\n                    if (destinationH > resultHeight) {\n                        b();\n                    }\n                }\n                else if (destinationW === destinationH) {\n                    if (srcWidth > srcHeight) {\n                        b();\n                    }\n                    else {\n                        a();\n                    }\n                }\n                else {\n                    b();\n                    if (destinationW > resultWidth) {\n                        a();\n                    }\n                }\n                var x1 = this.getSliceOffset(xalign, resultWidth, destinationW, srcWidth);\n                var y1 = this.getSliceOffset(yalign, resultHeight, destinationH, srcHeight);\n                var sWidth = srcWidth - x1;\n                var sHeight = srcHeight - y1;\n                var dWidth = resultWidth - (x1 * (resultWidth / srcWidth));\n                var dHeight = resultHeight - (y1 * (resultHeight / srcHeight));\n                var canvas1 = createHtmlElement('canvas', { 'width': width.toString(), 'height': height.toString() });\n                var ctx1 = canvas1.getContext('2d');\n                ctx1.drawImage(image, x1, y1, sWidth, sHeight, 0, 0, dWidth, dHeight);\n                ctx.drawImage(canvas1, x, y, width, height);\n            }\n            else if (alignOptions.scale === 'Meet') {\n                var srcRatio = (srcHeight / srcWidth);\n                var destRatio = (destinationH / destinationW);\n                resultWidth = destRatio > srcRatio ? destinationW : destinationH / srcRatio;\n                resultHeight = destRatio > srcRatio ? destinationW * srcRatio : destinationH;\n                x += this.getMeetOffset(xalign, resultWidth, destinationW);\n                y += this.getMeetOffset(yalign, resultHeight, destinationH);\n                ctx.drawImage(image, 0, 0, srcWidth, srcHeight, x, y, resultWidth, resultHeight);\n            }\n            else {\n                ctx.drawImage(image, x, y, width, height);\n            }\n        }\n        else if (alignOptions.flip !== 'None') {\n            var scaleX = 1;\n            var scaleY = 1;\n            if (alignOptions.flip === 'Horizontal' || alignOptions.flip === 'Both') {\n                x = -x;\n                width = -width;\n                scaleX = -1;\n            }\n            if (alignOptions.flip === 'Vertical' || alignOptions.flip === 'Both') {\n                y = -y;\n                height = -height;\n                scaleY = -1;\n            }\n            ctx.scale(scaleX, scaleY);\n            ctx.drawImage(image, x, y, width, height);\n        }\n        else {\n            ctx.drawImage(image, x, y, width, height);\n        }\n        ctx.closePath();\n    };\n    CanvasRenderer.prototype.getSliceOffset = function (arg, res, dest, src) {\n        switch (arg) {\n            case 'min': return 0;\n            case 'mid': return (res - dest) / 2 * src / res;\n            case 'max': return (res - dest) * src / res;\n            default: return 0;\n        }\n    };\n    CanvasRenderer.prototype.getMeetOffset = function (arg, res, dest) {\n        var max = Math.max(res, dest);\n        var min = Math.min(res, dest);\n        switch (arg) {\n            case 'min': return 0;\n            case 'mid': return (max - min) / 2;\n            case 'max': return max - min;\n            default: return 0;\n        }\n    };\n    //end region\n    // vector magnitude\n    CanvasRenderer.prototype.m = function (v) { return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2)); };\n    // ratio between two vectors\n    CanvasRenderer.prototype.r = function (u, v) { return (u[0] * v[0] + u[1] * v[1]) / (this.m(u) * this.m(v)); };\n    // angle between two vectors\n    CanvasRenderer.prototype.a = function (u, v) { return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(this.r(u, v)); };\n    // text utility\n    /**\n     * Draw the SVG label.\\\n     *\n     * @returns {PointModel} Draw the SVG label .\n     *  @param {TextAttributes} text - Provide the canvas element .\n     *  @param {Object} wrapBounds - Provide the canvas element .\n     *  @param {SubTextElement []} childNodes - Provide the canvas element .\n     * @private\n     */\n    CanvasRenderer.prototype.labelAlign = function (text, wrapBounds, childNodes) {\n        var bounds = new Size(wrapBounds.width, childNodes.length * (text.fontSize * 1.2));\n        var position = { x: 0, y: 0 };\n        var labelX = text.x;\n        var labelY = text.y;\n        var offsetx = text.width * 0.5;\n        var offsety = text.height * 0.5;\n        var pointx = offsetx;\n        var pointy = offsety;\n        if (text.textAlign === 'left') {\n            pointx = 0;\n        }\n        else if (text.textAlign === 'center') {\n            if (wrapBounds.width > text.width && (text.textOverflow === 'Ellipsis' || text.textOverflow === 'Clip')) {\n                if (text.textWrapping === 'NoWrap') {\n                    pointx = 0;\n                }\n                else {\n                    pointx = text.width * 0.5;\n                }\n            }\n            else {\n                pointx = text.width * 0.5;\n            }\n        }\n        else if (text.textAlign === 'right') {\n            pointx = (text.width * 1);\n        }\n        position.x = labelX + pointx + (wrapBounds ? wrapBounds.x : 0);\n        position.y = labelY + pointy - bounds.height / 2;\n        return position;\n    };\n    return CanvasRenderer;\n}());\nexport { CanvasRenderer };\n"]},"metadata":{},"sourceType":"module"}